diff -rN --unified llvm-toolchain-7-7.0.1/CMakeLists.txt llvm-toolchain-7-7.0.1.patched/CMakeLists.txt
--- llvm-toolchain-7-7.0.1/CMakeLists.txt	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/CMakeLists.txt	2019-05-19 11:21:50.925903000 +0000
@@ -2,6 +2,9 @@
 
 cmake_minimum_required(VERSION 3.4.3)
 
+set(CMAKE_LIBRARY_PATH ${CMAKE_LIBRARY_PATH} /usr/lib/i386-linux-gnu/)
+include_directories(/usr/include/i386-linux-gnu/ /usr/include/)
+
 cmake_policy(SET CMP0022 NEW)
 
 cmake_policy(SET CMP0048 NEW)
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/AST/ASTContext.h llvm-toolchain-7-7.0.1.patched/clang/include/clang/AST/ASTContext.h
--- llvm-toolchain-7-7.0.1/clang/include/clang/AST/ASTContext.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/AST/ASTContext.h	2019-05-19 11:21:50.925903000 +0000
@@ -291,6 +291,9 @@
   /// The typedef for the predefined \c __builtin_ms_va_list type.
   mutable TypedefDecl *BuiltinMSVaListDecl = nullptr;
 
+  /// The typedef for the predefined \c __builtin_va_list32 type.
+  mutable TypedefDecl *BuiltinVaList32Decl = nullptr;
+
   /// The typedef for the predefined \c id type.
   mutable TypedefDecl *ObjCIdDecl = nullptr;
 
@@ -549,6 +552,14 @@
   IntrusiveRefCntPtr<ExternalASTSource> ExternalSource;
   ASTMutationListener *Listener = nullptr;
 
+  /// The default address space for pointer types that don't have one
+  /// explicitly given.
+  LangAS DefaultAddrSpace = LangAS::Default;
+
+  /// The default address space for global variables that don't have one
+  /// explicitly given.
+  LangAS StorageAddrSpace = LangAS::Default;
+
   /// Contains parents of a node.
   using ParentVector = llvm::SmallVector<ast_type_traits::DynTypedNode, 2>;
 
@@ -1208,9 +1219,10 @@
 
   /// Return the uniqued reference to the type for a pointer to
   /// the specified type.
-  QualType getPointerType(QualType T) const;
-  CanQualType getPointerType(CanQualType T) const {
-    return CanQualType::CreateUnsafe(getPointerType((QualType) T));
+  QualType getPointerType(QualType T, bool HonorASPragma = false) const;
+  CanQualType getPointerType(CanQualType T, bool HonorASPragma = false) const {
+    return CanQualType::CreateUnsafe(getPointerType((QualType) T,
+                                                    HonorASPragma));
   }
 
   /// Return the uniqued reference to a type adjusted from the original
@@ -1277,12 +1289,13 @@
 
   /// Return the uniqued reference to the type for an lvalue reference
   /// to the specified type.
-  QualType getLValueReferenceType(QualType T, bool SpelledAsLValue = true)
+  QualType getLValueReferenceType(QualType T, bool SpelledAsLValue = true,
+                                  bool HonorASPragma = false)
     const;
 
   /// Return the uniqued reference to the type for an rvalue reference
   /// to the specified type.
-  QualType getRValueReferenceType(QualType T) const;
+  QualType getRValueReferenceType(QualType T, bool HonorASPragma = false) const;
 
   /// Return the uniqued reference to the type for a member pointer to
   /// the specified type in the specified class.
@@ -1904,6 +1917,15 @@
     return getTypeDeclType(getBuiltinMSVaListDecl());
   }
 
+  /// Retrieve the C type declaration corresponding to the predefined
+  /// \c __builtin_va_list32 type.
+  TypedefDecl *getBuiltinVaList32Decl() const;
+
+  /// Retrieve the type of the \c __builtin_va_list32 type.
+  QualType getBuiltinVaList32Type() const {
+    return getTypeDeclType(getBuiltinVaList32Decl());
+  }
+
   /// Return whether a declaration to a builtin is allowed to be
   /// overloaded/redeclared.
   bool canBuiltinBeRedeclared(const FunctionDecl *) const;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/AST/Expr.h llvm-toolchain-7-7.0.1.patched/clang/include/clang/AST/Expr.h
--- llvm-toolchain-7-7.0.1/clang/include/clang/AST/Expr.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/AST/Expr.h	2019-05-19 11:21:50.935903000 +0000
@@ -3953,17 +3953,23 @@
 /// Represents a call to the builtin function \c __builtin_va_arg.
 class VAArgExpr : public Expr {
   Stmt *Val;
-  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfo;
+  llvm::PointerIntPair<TypeSourceInfo *, 2, unsigned> TInfo;
   SourceLocation BuiltinLoc, RParenLoc;
 public:
+  /// The kind of \c va_arg expression this is.
+  enum Kind {
+    Default,  ///< A normal \c va_arg.
+    MSABI,    ///< A \c __builtin_ms_va_arg for a \c __builtin_ms_va_list.
+    ABI32     ///< A \c __builtin_va_arg32 for a \c __builtin_va_list32.
+  };
   VAArgExpr(SourceLocation BLoc, Expr *e, TypeSourceInfo *TInfo,
-            SourceLocation RPLoc, QualType t, bool IsMS)
+            SourceLocation RPLoc, QualType t, Kind k)
       : Expr(VAArgExprClass, t, VK_RValue, OK_Ordinary, t->isDependentType(),
              false, (TInfo->getType()->isInstantiationDependentType() ||
                      e->isInstantiationDependent()),
              (TInfo->getType()->containsUnexpandedParameterPack() ||
               e->containsUnexpandedParameterPack())),
-        Val(e), TInfo(TInfo, IsMS), BuiltinLoc(BLoc), RParenLoc(RPLoc) {}
+        Val(e), TInfo(TInfo, k), BuiltinLoc(BLoc), RParenLoc(RPLoc) {}
 
   /// Create an empty __builtin_va_arg expression.
   explicit VAArgExpr(EmptyShell Empty)
@@ -3973,9 +3979,17 @@
   Expr *getSubExpr() { return cast<Expr>(Val); }
   void setSubExpr(Expr *E) { Val = E; }
 
-  /// Returns whether this is really a Win64 ABI va_arg expression.
-  bool isMicrosoftABI() const { return TInfo.getInt(); }
-  void setIsMicrosoftABI(bool IsMS) { TInfo.setInt(IsMS); }
+  /// Returns whether this is really a Win64 ABI \c va_arg expression.
+  bool isMicrosoftABI() const { return getABIKind() == MSABI; }
+
+  /// Returns whether this is really a 32-bit ABI \c va_arg expression.
+  bool is32BitABI() const { return getABIKind() == ABI32; }
+
+  /// Returns the ABI kind of this \c va_arg expression.
+  Kind getABIKind() const { return static_cast<Kind>(TInfo.getInt()); }
+
+  /// Changes the kind of this \c va_arg expression.
+  void setABIKind(Kind k) { TInfo.setInt(k); }
 
   TypeSourceInfo *getWrittenTypeInfo() const { return TInfo.getPointer(); }
   void setWrittenTypeInfo(TypeSourceInfo *TI) { TInfo.setPointer(TI); }
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/AST/Type.h llvm-toolchain-7-7.0.1.patched/clang/include/clang/AST/Type.h
--- llvm-toolchain-7-7.0.1/clang/include/clang/AST/Type.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/AST/Type.h	2019-05-19 11:21:50.935903000 +0000
@@ -487,6 +487,10 @@
     return
         // Address spaces must match exactly.
         getAddressSpace() == other.getAddressSpace() ||
+        // For 64-32 interop, the default address space is a superset
+        // of the 32-bit space.
+        (getAddressSpace() == LangAS::Default &&
+         other.getAddressSpace() == LangAS::ptr32) ||
         // Otherwise in OpenCLC v2.0 s6.5.5: every address space except
         // for __constant can be used as __generic.
         (getAddressSpace() == LangAS::opencl_generic &&
@@ -4227,6 +4231,10 @@
     attr_sysv_abi,
     attr_preserve_most,
     attr_preserve_all,
+    attr_cdecl32,
+    attr_stdcall32,
+    attr_fastcall32,
+    attr_thiscall32,
     attr_ptr32,
     attr_ptr64,
     attr_sptr,
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/AddressSpaces.h llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/AddressSpaces.h
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/AddressSpaces.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/AddressSpaces.h	2019-05-19 11:21:50.935903000 +0000
@@ -43,6 +43,9 @@
   cuda_constant,
   cuda_shared,
 
+  // 64-32 interop address spaces.
+  ptr32,
+
   // This denotes the count of language-specific address spaces and also
   // the offset added to the target-specific address spaces, which are usually
   // specified by address space attributes __attribute__(address_space(n))).
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/Attr.td llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/Attr.td
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/Attr.td	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/Attr.td	2019-05-19 11:21:50.935903000 +0000
@@ -290,6 +290,7 @@
 def RenderScript : LangOpt<"RenderScript">;
 def ObjC : LangOpt<"ObjC1">;
 def BlocksSupported : LangOpt<"Blocks">;
+def Interop6432 : LangOpt<"Interop6432">;
 
 // Defines targets for target-specific attributes. Empty lists are unchecked.
 class TargetSpec {
@@ -318,6 +319,7 @@
 def TargetRISCV : TargetArch<["riscv32", "riscv64"]>;
 def TargetX86 : TargetArch<["x86"]>;
 def TargetAnyX86 : TargetArch<["x86", "x86_64"]>;
+def TargetWindowsArches : TargetArch<["x86", "x86_64", "arm", "thumb", "aarch64"]>;
 def TargetWindows : TargetArch<["x86", "x86_64", "arm", "thumb", "aarch64"]> {
   let OSes = ["Win32"];
 }
@@ -786,6 +788,13 @@
   let Documentation = [Undocumented];
 }
 
+def CDecl32 : DeclOrTypeAttr {
+  let Spellings = [Clang<"cdecl32">];
+//  let Subjects = [Function, ObjCMethod];
+  let LangOpts = [Interop6432];
+  let Documentation = [CallingConv32Docs];
+}
+
 // cf_audited_transfer indicates that the given function has been
 // audited and has been marked with the appropriate cf_consumed and
 // cf_returns_retained attributes.  It is generally applied by
@@ -1109,6 +1118,13 @@
   let Documentation = [FastCallDocs];
 }
 
+def FastCall32 : DeclOrTypeAttr {
+  let Spellings = [Clang<"fastcall32">];
+//  let Subjects = [Function, ObjCMethod];
+  let LangOpts = [Interop6432];
+  let Documentation = [CallingConv32Docs];
+}
+
 def RegCall : DeclOrTypeAttr {
   let Spellings = [GCC<"regcall">, Keyword<"__regcall">];
   let Documentation = [RegCallDocs];
@@ -1871,6 +1887,13 @@
   let Documentation = [StdCallDocs];
 }
 
+def StdCall32 : DeclOrTypeAttr {
+  let Spellings = [Clang<"stdcall32">];
+//  let Subjects = [Function, ObjCMethod];
+  let LangOpts = [Interop6432];
+  let Documentation = [CallingConv32Docs];
+}
+
 def SwiftCall : DeclOrTypeAttr {
   let Spellings = [Clang<"swiftcall">];
 //  let Subjects = SubjectList<[Function]>;
@@ -1911,6 +1934,13 @@
   let Documentation = [ThisCallDocs];
 }
 
+def ThisCall32 : DeclOrTypeAttr {
+  let Spellings = [Clang<"thiscall32">];
+//  let Subjects = [Function, ObjCMethod];
+  let LangOpts = [Interop6432];
+  let Documentation = [CallingConv32Docs];
+}
+
 def VectorCall : DeclOrTypeAttr {
   let Spellings = [Clang<"vectorcall">, Keyword<"__vectorcall">,
                    Keyword<"_vectorcall">];
@@ -2636,6 +2666,12 @@
 
 // Microsoft-related attributes
 
+def MSHookPrologue : InheritableAttr, TargetSpecificAttr<TargetWindowsArches> {
+  let Spellings = [GCC<"ms_hook_prologue">];
+  let Subjects = SubjectList<[Function]>;
+  let Documentation = [MSHookPrologueDocs];
+}
+
 def MSNoVTable : InheritableAttr, TargetSpecificAttr<TargetMicrosoftCXXABI> {
   let Spellings = [Declspec<"novtable">];
   let Subjects = SubjectList<[CXXRecord]>;
@@ -3004,3 +3040,42 @@
   let Subjects = SubjectList<[Var, Function, CXXRecord]>;
   let Documentation = [InternalLinkageDocs];
 }
+
+def Ptr32ThunkPrefix : InheritableAttr {
+  let Spellings = [Pragma<"clang", "ptr32_thunk_prefix">];
+  let Subjects = SubjectList<[Function, ObjCMethod, Block]>;
+  let Args = [StringArgument<"Prefix">];
+  let LangOpts = [Interop6432];
+  let Documentation = [Ptr32ThunkPrefixDocs];
+  let AdditionalMembers = [{
+  void printPrettyPragma(raw_ostream &OS, const PrintingPolicy &Policy) const {
+    OS << " (\"" << getPrefix() << "\")";
+  }
+  }];
+}
+
+def Ptr32CS32Name : InheritableAttr {
+  let Spellings = [Pragma<"clang", "ptr32_cs32_name">];
+  let Subjects = SubjectList<[Function, ObjCMethod, Block]>;
+  let Args = [StringArgument<"Name">];
+  let LangOpts = [Interop6432];
+  let Documentation = [Ptr32CS32NameDocs];
+  let AdditionalMembers = [{
+  void printPrettyPragma(raw_ostream &OS, const PrintingPolicy &Policy) const {
+    OS << " (\"" << getName() << "\")";
+  }
+  }];
+}
+
+def Ptr32CS64Name : InheritableAttr {
+  let Spellings = [Pragma<"clang", "ptr32_cs64_name">];
+  let Subjects = SubjectList<[Function, ObjCMethod, Block]>;
+  let Args = [StringArgument<"Name">];
+  let LangOpts = [Interop6432];
+  let Documentation = [Ptr32CS64NameDocs];
+  let AdditionalMembers = [{
+  void printPrettyPragma(raw_ostream &OS, const PrintingPolicy &Policy) const {
+    OS << " (\"" << getName() << "\")";
+  }
+  }];
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/AttrDocs.td llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/AttrDocs.td
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/AttrDocs.td	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/AttrDocs.td	2019-05-19 11:21:50.935903000 +0000
@@ -843,6 +843,22 @@
   }];
 }
 
+def MSHookPrologueDocs : Documentation {
+  let Category = DocCatFunction;
+  let Content = [{
+The ``ms_hook_prologue`` attribute marks a function as "hotpatchable" according
+to conventions used on Windows. Specifically, enough space will be ensured
+in the prologue for a short jump, and an architecturally dependently sized
+patch space will be reserved prior to the entry point. See the documentation
+for the `/HOTPATCH`_ switch on MSDN.
+
+This attribute cannot be used in conjunction with the ``naked``,
+``always_inline``, or ``__forceinline`` attributes.
+
+.. _`/HOTPATCH`: https://msdn.microsoft.com/en-us/library/ms173507.aspx
+  }];
+}
+
 def NoDebugDocs : Documentation {
   let Category = DocCatVariable;
   let Content = [{
@@ -3458,3 +3474,55 @@
 corresponding line within the inlined callee.
   }];
 }
+
+def CallingConv32Docs : Documentation {
+  let Category = DocCatCallingConvs;
+  let Content = [{
+This attribute is similar to its unsuffixed counterpart, only it applies in
+64-bit mode as well. In addition, it also marks this function as using a
+32-bit calling convention. This calling convention may only be used when
+64-32 interop has been enabled.
+  }];
+}
+
+def Ptr32ThunkPrefixDocs : Documentation {
+  let Category = DocCatFunction;
+  let Content = [{
+The ``ptr32_thunk_prefix`` pragma sets the prefix used when naming
+automatically generated thunks for a 32-bit-callable function, as well as the
+prefix used for naming thunks for invoking 32-bit function pointers. It applies
+to all functions defined after the pragma. It may also be set on the command
+line with the ``-minterop64-32-thunk-prefix`` option. If not specified, the
+default is ``__i386_on_x86_64_``. This attribute may only be used when 64-32
+interop has been enabled.
+  }];
+}
+
+def Ptr32CS32NameDocs : Documentation {
+  let Category = DocCatFunction;
+  let Content = [{
+The ``ptr32_cs32_name`` pragma sets the name of the variable holding the 32-bit
+code segment selector to use to invoke 32-bit functions. Any call to a 32-bit
+function pointer will use the selector in this variable as the target segment
+in the far call. It applies to all functions defined after the pragma. It may
+also be set on the command line with the ``-minterop64-32-cs32-name`` option. If
+not specified, the default is ``__i386_on_x86_64_cs32``. This attribute may only
+be used when 64-32 interop has been enabled.
+  }];
+}
+
+def Ptr32CS64NameDocs : Documentation {
+  let Category = DocCatFunction;
+  let Content = [{
+The ``ptr32_cs64_name`` pragma sets the name of the variable holding the 64-bit
+code segment selector to use to invoke 64-bit functions. The 32-bit side of
+any automatically generated thunk will use the selector in this variable as the
+target segment in the far call. In addition, any call to a 32-bit function
+pointer will check the selector in this variable against the current ``%cs`` to
+ensure that it is possible to call 32-bit code. It applies to all functions
+defined after the pragma. It may also be set on the command line with the
+``-minterop64-32-cs64-name`` option. If not specified, the default is
+``__i386_on_x86_64_cs64``. This attribute may only be used when 64-32 interop
+has been enabled.
+  }];
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/Builtins.def llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/Builtins.def
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/Builtins.def	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/Builtins.def	2019-05-19 11:21:50.935903000 +0000
@@ -36,6 +36,8 @@
 //  M -> struct objc_super
 //  a -> __builtin_va_list
 //  A -> "reference" to __builtin_va_list
+//  Sa -> __builtin_va_list32
+//  SA -> "reference" to __builtin_va_list32
 //  V -> Vector, followed by the number of elements and the base type.
 //  E -> ext_vector, followed by the number of elements and the base type.
 //  X -> _Complex, followed by the base type.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/BuiltinsX86.def llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/BuiltinsX86.def
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/BuiltinsX86.def	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/BuiltinsX86.def	2019-05-19 11:21:50.935903000 +0000
@@ -34,6 +34,11 @@
 BUILTIN(__builtin_cpu_supports, "bcC*", "nc")
 BUILTIN(__builtin_cpu_is, "bcC*", "nc")
 
+// 32-bit-compatible va_list functions
+BUILTIN(__builtin_va_start32, "vSA.", "nt")
+BUILTIN(__builtin_va_end32, "vSA", "n")
+BUILTIN(__builtin_va_copy32, "vSASA", "n")
+
 // Undefined Values
 //
 TARGET_BUILTIN(__builtin_ia32_undef128, "V2d", "ncV:128:", "")
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/DiagnosticParseKinds.td llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/DiagnosticParseKinds.td
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/DiagnosticParseKinds.td	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/DiagnosticParseKinds.td	2019-05-19 11:21:50.935903000 +0000
@@ -907,6 +907,9 @@
   "expected identifier in '#pragma %0' - ignored">, InGroup<IgnoredPragmas>;
 def warn_pragma_expected_string : Warning<
   "expected string literal in '#pragma %0' - ignoring">, InGroup<IgnoredPragmas>;
+def warn_pragma_expected_identifier_or_integer : Warning<
+  "expected identifier or integer in '#pragma %0' - ignored">,
+  InGroup<IgnoredPragmas>;
 def warn_pragma_missing_argument : Warning<
   "missing argument to '#pragma %0'%select{|; expected %2}1">, InGroup<IgnoredPragmas>;
 def warn_pragma_invalid_argument : Warning<
@@ -1059,6 +1062,10 @@
   "sub-rules: %3}2">;
 def err_pragma_attribute_duplicate_subject : Error<
   "duplicate attribute subject matcher '%0'">;
+// #pragma clang default_addr_space(...)
+def warn_pragma_expected_addr_space : Warning<
+  "expected address space name in '#pragma clang %0' - ignoring">,
+  InGroup<IgnoredPragmas>;
 
 def err_opencl_unroll_hint_on_non_loop : Error<
   "OpenCL only supports 'opencl_unroll_hint' attribute on for, while, and do statements">;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/DiagnosticSemaKinds.td llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/DiagnosticSemaKinds.td
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/DiagnosticSemaKinds.td	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/DiagnosticSemaKinds.td	2019-05-19 11:21:50.935903000 +0000
@@ -8125,9 +8125,11 @@
 def err_va_start_fixed_function : Error<
   "'va_start' used in function with fixed args">;
 def err_va_start_used_in_wrong_abi_function : Error<
-  "'va_start' used in %select{System V|Win64}0 ABI function">;
-def err_ms_va_start_used_in_sysv_function : Error<
-  "'__builtin_ms_va_start' used in System V ABI function">;
+  "'va_start' used in %select{System V|Win64|32-bit}0 ABI function">;
+def err_ms_va_start_used_in_wrong_abi_function : Error<
+  "'__builtin_ms_va_start' used in %select{System V|32-bit}0 ABI function">;
+def err_va_start32_used_in_wrong_abi_function : Error<
+  "'__builtin_va_start32' used in %select{System V|Win64}0 ABI function">;
 def warn_second_arg_of_va_start_not_last_named_param : Warning<
   "second argument to 'va_start' is not the last named parameter">,
   InGroup<Varargs>;
@@ -8257,6 +8259,8 @@
   "this builtin is only available on x86-64 and aarch64 targets">;
 def err_ppc_builtin_only_on_pwr7 : Error<
   "this builtin is only valid on POWER7 or later CPUs">;
+def err_x86_builtin_only_on_wine32 : Error<
+  "this builtin is only available on Wine32 targets">;
 def err_x86_builtin_invalid_rounding : Error<
   "invalid rounding argument">;
 def err_x86_builtin_invalid_scale : Error<
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/LangOptions.def llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/LangOptions.def
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/LangOptions.def	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/LangOptions.def	2019-05-19 11:21:50.935903000 +0000
@@ -308,6 +308,8 @@
 LANGOPT(PaddingOnUnsignedFixedPoint, 1, 0,
         "unsigned fixed point types having one extra padding bit")
 
+COMPATIBLE_LANGOPT(Interop6432, 1, 0, "64-32 interop extensions")
+
 #undef LANGOPT
 #undef COMPATIBLE_LANGOPT
 #undef BENIGN_LANGOPT
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/Specifiers.h llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/Specifiers.h
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/Specifiers.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/Specifiers.h	2019-05-19 11:21:50.935903000 +0000
@@ -251,8 +251,19 @@
     CC_Swift,        // __attribute__((swiftcall))
     CC_PreserveMost, // __attribute__((preserve_most))
     CC_PreserveAll,  // __attribute__((preserve_all))
+    CC_X86C32,        // __attribute__((cdecl32))
+    CC_X86StdCall32,  // __attribute__((stdcall32))
+    CC_X86FastCall32, // __attribute__((fastcall32))
+    CC_X86ThisCall32, // __attribute__((thiscall32))
   };
 
+  /// Checks whether the given calling convention supports interoperation
+  /// between 64-bit and 32-bit code.
+  inline bool is32BitInteropCC(CallingConv CC) {
+    return CC == CC_X86C32 || CC == CC_X86StdCall32 ||
+           CC == CC_X86FastCall32 || CC == CC_X86ThisCall32;
+  }
+
   /// Checks whether the given calling convention supports variadic
   /// calls. Unprototyped calls also use the variadic call rules.
   inline bool supportsVariadicCall(CallingConv CC) {
@@ -266,6 +277,9 @@
     case CC_SpirFunction:
     case CC_OpenCLKernel:
     case CC_Swift:
+    case CC_X86StdCall32:
+    case CC_X86FastCall32:
+    case CC_X86ThisCall32:
       return false;
     default:
       return true;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/TargetInfo.h llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/TargetInfo.h
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/TargetInfo.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/TargetInfo.h	2019-05-19 11:21:50.935903000 +0000
@@ -125,6 +125,7 @@
   unsigned ComplexLongDoubleUsesFP2Ret : 1;
 
   unsigned HasBuiltinMSVaList : 1;
+  unsigned HasBuiltinVaList32 : 1;
 
   unsigned IsRenderScriptTarget : 1;
 
@@ -742,10 +743,14 @@
   /// with this target.
   virtual BuiltinVaListKind getBuiltinVaListKind() const = 0;
 
-  /// Returns whether or not type \c __builtin_ms_va_list type is
+  /// Returns whether or not the \c __builtin_ms_va_list type is
   /// available on this target.
   bool hasBuiltinMSVaList() const { return HasBuiltinMSVaList; }
 
+  /// Returns whether or not the \c __builtin_va_list32 type is
+  /// available on this target.
+  bool hasBuiltinVaList32() const { return HasBuiltinVaList32; }
+
   /// Returns true for RenderScript.
   bool isRenderScriptTarget() const { return IsRenderScriptTarget; }
 
@@ -1176,6 +1181,11 @@
     return LangAS::Default;
   }
 
+  /// Return an AST address space which can be used for stack memory.
+  virtual LangAS getStackAddressSpace(const LangOptions &) const {
+    return LangAS::Default;
+  }
+
   /// Retrieve the name of the platform as it is used in the
   /// availability attribute.
   StringRef getPlatformName() const { return PlatformName; }
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/TargetOptions.h llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/TargetOptions.h
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/TargetOptions.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/TargetOptions.h	2019-05-19 11:21:50.935903000 +0000
@@ -17,6 +17,7 @@
 
 #include <string>
 #include <vector>
+#include "clang/Basic/AddressSpaces.h"
 #include "clang/Basic/OpenCLOptions.h"
 #include "llvm/Target/TargetOptions.h"
 
@@ -67,6 +68,29 @@
   /// \brief If enabled, use 32-bit pointers for accessing const/local/shared
   /// address space.
   bool NVPTXUseShortPointers = false;
+
+  /// The default address space for pointers.
+  LangAS DefaultAddrSpace = LangAS::Default;
+
+  /// The default address space for global data.
+  LangAS StorageAddrSpace = LangAS::Default;
+
+  /// The default address space for pointers in a system header.
+  LangAS SystemAddrSpace = LangAS::Default;
+
+  /// The default prefix to use for automatically generated 64-32 interop
+  /// thunks.
+  std::string Ptr32ThunkPrefix;
+
+  /// The default name to use for the variable holding the 32-bit code
+  /// segment selector.
+  std::string Ptr32CS32Name;
+
+  /// The default name to use for the variable holding the 64-bit code
+  /// segment selector.
+  std::string Ptr32CS64Name;
+
+  ///
 };
 
 }  // end namespace clang
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Basic/TokenKinds.def llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/TokenKinds.def
--- llvm-toolchain-7-7.0.1/clang/include/clang/Basic/TokenKinds.def	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Basic/TokenKinds.def	2019-05-19 11:21:50.945903000 +0000
@@ -816,6 +816,14 @@
 // Annotation for the attribute pragma directives - #pragma clang attribute ...
 ANNOTATION(pragma_attribute)
 
+// Annotation for the default address space pragma directive -
+// #pragma clang default_addr_space(...)
+ANNOTATION(pragma_default_as)
+
+// Annotation for the default storage address space pragma directive -
+// #pragma clang storage_addr_space(...)
+ANNOTATION(pragma_storage_as)
+
 // Annotations for module import translated from #include etc.
 ANNOTATION(module_include)
 ANNOTATION(module_begin)
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Driver/Options.td llvm-toolchain-7-7.0.1.patched/clang/include/clang/Driver/Options.td
--- llvm-toolchain-7-7.0.1/clang/include/clang/Driver/Options.td	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Driver/Options.td	2019-05-19 11:21:50.945903000 +0000
@@ -1885,7 +1885,12 @@
 def mqdsp6_compat : Flag<["-"], "mqdsp6-compat">, Group<m_Group>, Flags<[DriverOption,CC1Option]>,
   HelpText<"Enable hexagon-qdsp6 backward compatibility">;
 def m64 : Flag<["-"], "m64">, Group<m_Group>, Flags<[DriverOption, CoreOption]>;
+def mwine32 : Flag<["-"], "mwine32">, Group<m_Group>, Flags<[DriverOption, CoreOption]>,
+  HelpText<"Enable Wine32 support (32-bit pointers and calls)">;
 def mx32 : Flag<["-"], "mx32">, Group<m_Group>, Flags<[DriverOption, CoreOption]>;
+def m64_32_interop : Flag<["-"], "m64-32-interop">, Group<m_Group>, Flags<[CC1Option]>,
+  HelpText<"Enable 64-32 interop support">;
+def mno_64_32_interop : Flag<["-"], "mno-64-32-interop">, Group<m_Group>, Flags<[CC1Option]>;
 def mabi_EQ : Joined<["-"], "mabi=">, Group<m_Group>;
 def miamcu : Flag<["-"], "miamcu">, Group<m_Group>, Flags<[DriverOption, CoreOption]>,
   HelpText<"Use Intel MCU ABI">;
@@ -1917,6 +1922,9 @@
 def masm_EQ : Joined<["-"], "masm=">, Group<m_Group>, Flags<[DriverOption]>;
 def mcmodel_EQ : Joined<["-"], "mcmodel=">, Group<m_Group>;
 def mimplicit_it_EQ : Joined<["-"], "mimplicit-it=">, Group<m_Group>;
+def mdefault_address_space_EQ : Joined<["-"], "mdefault-address-space=">, Group<m_Group>, Flags<[CC1Option]>;
+def mstorage_address_space_EQ : Joined<["-"], "mstorage-address-space=">, Group<m_Group>, Flags<[CC1Option]>;
+def msystem_address_space_EQ : Joined<["-"], "msystem-address-space=">, Group<m_Group>, Flags<[CC1Option]>;
 def mdefault_build_attributes : Joined<["-"], "mdefault-build-attributes">, Group<m_Group>;
 def mno_default_build_attributes : Joined<["-"], "mno-default-build-attributes">, Group<m_Group>;
 def mconstant_cfstrings : Flag<["-"], "mconstant-cfstrings">, Group<clang_ignored_m_Group>;
@@ -1941,6 +1949,12 @@
 def mglobal_merge : Flag<["-"], "mglobal-merge">, Group<m_Group>, Flags<[CC1Option]>,
   HelpText<"Enable merging of globals">;
 def mhard_float : Flag<["-"], "mhard-float">, Group<m_Group>;
+def minterop64_32_thunk_prefix_EQ : Joined<["-"], "minterop64-32-thunk-prefix=">,
+  Group<m_Group>, Flags<[CC1Option]>, HelpText<"Set auto-generated thunk prefix">;
+def minterop64_32_cs32_name_EQ : Joined<["-"], "minterop64-32-cs32-name=">,
+  Group<m_Group>, Flags<[CC1Option]>, HelpText<"Set auto-generated 32-bit CS var name">;
+def minterop64_32_cs64_name_EQ : Joined<["-"], "minterop64-32-cs64-name=">,
+  Group<m_Group>, Flags<[CC1Option]>, HelpText<"Set auto-generated 64-bit CS var name">;
 def miphoneos_version_min_EQ : Joined<["-"], "miphoneos-version-min=">, Group<m_Group>;
 def mios_version_min_EQ : Joined<["-"], "mios-version-min=">,
   Alias<miphoneos_version_min_EQ>, HelpText<"Set iOS deployment target">;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Parse/Parser.h llvm-toolchain-7-7.0.1.patched/clang/include/clang/Parse/Parser.h
--- llvm-toolchain-7-7.0.1/clang/include/clang/Parse/Parser.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Parse/Parser.h	2019-05-19 11:21:50.945903000 +0000
@@ -190,6 +190,11 @@
   std::unique_ptr<PragmaHandler> STDCCXLIMITHandler;
   std::unique_ptr<PragmaHandler> STDCUnknownHandler;
   std::unique_ptr<PragmaHandler> AttributePragmaHandler;
+  std::unique_ptr<PragmaHandler> DefaultASHandler;
+  std::unique_ptr<PragmaHandler> StorageASHandler;
+  std::unique_ptr<PragmaHandler> Ptr32ThunkPrefixHandler;
+  std::unique_ptr<PragmaHandler> Ptr32CS32NameHandler;
+  std::unique_ptr<PragmaHandler> Ptr32CS64NameHandler;
 
   std::unique_ptr<CommentHandler> CommentSemaHandler;
 
@@ -689,6 +694,17 @@
 
   void HandlePragmaAttribute();
 
+  void HandlePragmaDefaultAS();
+
+  void HandlePragmaStorageAS();
+
+  bool HandlePragmaPtr32ThunkPrefix(StringRef PragmaName,
+                                    SourceLocation PragmaLocation);
+  bool HandlePragmaPtr32CS32Name(StringRef PragmaName,
+                                 SourceLocation PragmaLocation);
+  bool HandlePragmaPtr32CS64Name(StringRef PragmaName,
+                                 SourceLocation PragmaLocation);
+
   /// GetLookAheadToken - This peeks ahead N tokens and returns that token
   /// without consuming any tokens.  LookAhead(0) returns 'Tok', LookAhead(1)
   /// returns the token after Tok, etc.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Sema/Sema.h llvm-toolchain-7-7.0.1.patched/clang/include/clang/Sema/Sema.h
--- llvm-toolchain-7-7.0.1/clang/include/clang/Sema/Sema.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Sema/Sema.h	2019-05-19 11:21:50.945903000 +0000
@@ -467,6 +467,10 @@
   PragmaStack<StringLiteral *> ConstSegStack;
   PragmaStack<StringLiteral *> CodeSegStack;
 
+  // Address space #pragmas.
+  PragmaStack<LangAS> AddrSpaceStack;
+  PragmaStack<LangAS> StgAddrSpaceStack;
+
   // RAII object to push / pop sentinel slots for all MS #pragma stacks.
   // Actions should be performed only if we enter / exit a C++ method body.
   class PragmaStackSentinelRAII {
@@ -487,6 +491,18 @@
   StringLiteral *CurInitSeg;
   SourceLocation CurInitSegLoc;
 
+  /// Current prefix for auto-generated 64/32 interop thunks.
+  StringLiteral *CurPtr32ThunkPrefix;
+  SourceLocation CurPtr32ThunkPrefixLoc;
+
+  /// Current name of the 32-bit code segment selector variable.
+  StringLiteral *CurPtr32CS32Name;
+  SourceLocation CurPtr32CS32NameLoc;
+
+  /// Current name of the 64-bit code segment selector variable.
+  StringLiteral *CurPtr32CS64Name;
+  SourceLocation CurPtr32CS64NameLoc;
+
   /// VisContext - Manages the stack for \#pragma GCC visibility.
   void *VisContext; // Really a "PragmaVisStack*"
 
@@ -8538,6 +8554,23 @@
 
   bool checkNSReturnsRetainedReturnType(SourceLocation loc, QualType type);
 
+  /// Called on well-formed \#pragma clang default_addr_space(...).
+  void ActOnPragmaDefaultAS(SourceLocation Loc, PragmaMsStackAction Action,
+                            LangAS AS);
+
+  /// Called on well-formed \#pragma clang storage_addr_space(...).
+  void ActOnPragmaStorageAS(SourceLocation Loc, PragmaMsStackAction Action,
+                            LangAS AS);
+
+  /// Called on well-formed \#pragma clang ptr32_thunk_prefix(...).
+  void ActOnPragmaPtr32ThunkPrefix(SourceLocation Loc, StringLiteral *Prefix);
+
+  /// Called on well-formed \#pragma clang ptr32_cs32_name(...).
+  void ActOnPragmaPtr32CS32Name(SourceLocation Loc, StringLiteral *Name);
+
+  /// Called on well-formed \#pragma clang ptr32_cs64_name(...).
+  void ActOnPragmaPtr32CS64Name(SourceLocation Loc, StringLiteral *Name);
+
   //===--------------------------------------------------------------------===//
   // C++ Coroutines TS
   //
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang/Serialization/ASTBitCodes.h llvm-toolchain-7-7.0.1.patched/clang/include/clang/Serialization/ASTBitCodes.h
--- llvm-toolchain-7-7.0.1/clang/include/clang/Serialization/ASTBitCodes.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang/Serialization/ASTBitCodes.h	2019-05-19 11:21:50.945903000 +0000
@@ -1264,13 +1264,16 @@
 
       /// The internal '__type_pack_element' template.
       PREDEF_DECL_TYPE_PACK_ELEMENT_ID = 16,
+
+      /// The internal '__builtin_va_list32' typedef.
+      PREDEF_DECL_BUILTIN_VA_LIST32_ID = 17,
     };
 
     /// The number of declaration IDs that are predefined.
     ///
     /// For more information about predefined declarations, see the
     /// \c PredefinedDeclIDs type and the PREDEF_DECL_*_ID constants.
-    const unsigned int NUM_PREDEF_DECL_IDS = 17;
+    const unsigned int NUM_PREDEF_DECL_IDS = 18;
 
     /// Record of updates for a declaration that was modified after
     /// being deserialized. This can occur within DECLTYPES_BLOCK_ID.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/include/clang-c/Index.h llvm-toolchain-7-7.0.1.patched/clang/include/clang-c/Index.h
--- llvm-toolchain-7-7.0.1/clang/include/clang-c/Index.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/include/clang-c/Index.h	2019-05-19 11:21:50.945903000 +0000
@@ -32,7 +32,7 @@
  * compatible, thus CINDEX_VERSION_MAJOR is expected to remain stable.
  */
 #define CINDEX_VERSION_MAJOR 0
-#define CINDEX_VERSION_MINOR 49
+#define CINDEX_VERSION_MINOR 51
 
 #define CINDEX_VERSION_ENCODE(major, minor) ( \
       ((major) * 10000)                       \
@@ -3291,6 +3291,10 @@
   CXCallingConv_Swift = 13,
   CXCallingConv_PreserveMost = 14,
   CXCallingConv_PreserveAll = 15,
+  CXCallingConv_X86C32 = 16,
+  CXCallingConv_X86StdCall32 = 17,
+  CXCallingConv_X86FastCall32 = 18,
+  CXCallingConv_X86ThisCall32 = 19,
 
   CXCallingConv_Invalid = 100,
   CXCallingConv_Unexposed = 200
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/AST/ASTContext.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/AST/ASTContext.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/AST/ASTContext.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/AST/ASTContext.cpp	2019-05-19 11:21:50.945903000 +0000
@@ -759,7 +759,8 @@
       4, // opencl_generic
       5, // cuda_device
       6, // cuda_constant
-      7  // cuda_shared
+      7, // cuda_shared
+      8  // ptr32
     };
     return &FakeAddrSpaceMap;
   } else {
@@ -2776,9 +2777,32 @@
   return QualType(New, 0);
 }
 
+static bool isTypeDefinedInSystemHeader(const ASTContext &Ctx, QualType T) {
+  if (auto *TypedefTy = T->getAs<TypedefType>()) {
+    SourceLocation Loc = TypedefTy->getDecl()->getLocation();
+    if (Loc.isValid())
+      return Ctx.getSourceManager().isInSystemHeader(Loc);
+  } else if (auto *TagTy = T->getAs<TagType>()) {
+    SourceLocation Loc = TagTy->getDecl()->getLocation();
+    if (Loc.isValid())
+      return Ctx.getSourceManager().isInSystemHeader(Loc);
+  }
+  return false;
+}
+
 /// getPointerType - Return the uniqued reference to the type for a pointer to
 /// the specified type.
-QualType ASTContext::getPointerType(QualType T) const {
+QualType ASTContext::getPointerType(QualType T, bool HonorASPragma) const {
+  if (HonorASPragma && !T.getQualifiers().hasAddressSpace()) {
+    if (!isTypeDefinedInSystemHeader(*this, T) &&
+        DefaultAddrSpace != LangAS::Default)
+      T = getAddrSpaceQualType(T, DefaultAddrSpace);
+    else if (isTypeDefinedInSystemHeader(*this, T) &&
+           getTargetInfo().getTargetOpts().SystemAddrSpace != LangAS::Default)
+      T = getAddrSpaceQualType(T,
+                               getTargetInfo().getTargetOpts().SystemAddrSpace);
+  }
+
   // Unique pointers, to guarantee there is only one pointer of a particular
   // structure.
   llvm::FoldingSetNodeID ID;
@@ -2792,7 +2816,7 @@
   // so fill in the canonical type field.
   QualType Canonical;
   if (!T.isCanonical()) {
-    Canonical = getPointerType(getCanonicalType(T));
+    Canonical = getPointerType(getCanonicalType(T), HonorASPragma);
 
     // Get the new insert position for the node we care about.
     PointerType *NewIP = PointerTypes.FindNodeOrInsertPos(ID, InsertPos);
@@ -2898,10 +2922,21 @@
 /// getLValueReferenceType - Return the uniqued reference to the type for an
 /// lvalue reference to the specified type.
 QualType
-ASTContext::getLValueReferenceType(QualType T, bool SpelledAsLValue) const {
+ASTContext::getLValueReferenceType(QualType T, bool SpelledAsLValue,
+                                   bool HonorASPragma) const {
   assert(getCanonicalType(T) != OverloadTy &&
          "Unresolved overloaded function type");
 
+  if (HonorASPragma && !T.getQualifiers().hasAddressSpace()) {
+    if (!isTypeDefinedInSystemHeader(*this, T) &&
+        DefaultAddrSpace != LangAS::Default)
+      T = getAddrSpaceQualType(T, DefaultAddrSpace);
+    else if (isTypeDefinedInSystemHeader(*this, T) &&
+           getTargetInfo().getTargetOpts().SystemAddrSpace != LangAS::Default)
+      T = getAddrSpaceQualType(T,
+                               getTargetInfo().getTargetOpts().SystemAddrSpace);
+  }
+
   // Unique pointers, to guarantee there is only one pointer of a particular
   // structure.
   llvm::FoldingSetNodeID ID;
@@ -2919,7 +2954,8 @@
   QualType Canonical;
   if (!SpelledAsLValue || InnerRef || !T.isCanonical()) {
     QualType PointeeType = (InnerRef ? InnerRef->getPointeeType() : T);
-    Canonical = getLValueReferenceType(getCanonicalType(PointeeType));
+    Canonical = getLValueReferenceType(getCanonicalType(PointeeType),
+                                       true, HonorASPragma);
 
     // Get the new insert position for the node we care about.
     LValueReferenceType *NewIP =
@@ -2937,7 +2973,18 @@
 
 /// getRValueReferenceType - Return the uniqued reference to the type for an
 /// rvalue reference to the specified type.
-QualType ASTContext::getRValueReferenceType(QualType T) const {
+QualType ASTContext::getRValueReferenceType(QualType T,
+                                            bool HonorASPragma) const {
+  if (HonorASPragma && !T.getQualifiers().hasAddressSpace()) {
+    if (!isTypeDefinedInSystemHeader(*this, T) &&
+        DefaultAddrSpace != LangAS::Default)
+      T = getAddrSpaceQualType(T, DefaultAddrSpace);
+    else if (isTypeDefinedInSystemHeader(*this, T) &&
+           getTargetInfo().getTargetOpts().SystemAddrSpace != LangAS::Default)
+      T = getAddrSpaceQualType(T,
+                               getTargetInfo().getTargetOpts().SystemAddrSpace);
+  }
+
   // Unique pointers, to guarantee there is only one pointer of a particular
   // structure.
   llvm::FoldingSetNodeID ID;
@@ -2955,7 +3002,8 @@
   QualType Canonical;
   if (InnerRef || !T.isCanonical()) {
     QualType PointeeType = (InnerRef ? InnerRef->getPointeeType() : T);
-    Canonical = getRValueReferenceType(getCanonicalType(PointeeType));
+    Canonical = getRValueReferenceType(getCanonicalType(PointeeType),
+                                       HonorASPragma);
 
     // Get the new insert position for the node we care about.
     RValueReferenceType *NewIP =
@@ -3754,8 +3802,11 @@
 
 QualType ASTContext::adjustStringLiteralBaseType(QualType Ty) const {
   // OpenCL v1.1 s6.5.3: a string literal is in the constant address space.
-  return LangOpts.OpenCL ? getAddrSpaceQualType(Ty, LangAS::opencl_constant)
-                         : Ty;
+  return LangOpts.OpenCL
+           ? getAddrSpaceQualType(Ty, LangAS::opencl_constant)
+           : (StorageAddrSpace != LangAS::Default
+                ? getAddrSpaceQualType(Ty, StorageAddrSpace)
+                : Ty);
 }
 
 QualType ASTContext::getReadPipeType(QualType T) const {
@@ -5444,7 +5495,7 @@
   const ArrayType *PrettyArrayType = getAsArrayType(Ty);
   assert(PrettyArrayType && "Not an array type!");
 
-  QualType PtrTy = getPointerType(PrettyArrayType->getElementType());
+  QualType PtrTy = getPointerType(PrettyArrayType->getElementType(), true);
 
   // int x[restrict 4] ->  int *restrict
   QualType Result = getQualifiedType(PtrTy,
@@ -7139,6 +7190,31 @@
   return Context->buildImplicitTypedef(T, "__builtin_va_list");
 }
 
+static TypedefDecl *CreateVaList32Decl(const ASTContext *Context) {
+  // This needs to be semantically different from __builtin_ms_va_list,
+  // hence the complexity.
+  // struct __va_list32 {
+  RecordDecl *VaList32Decl = Context->buildImplicitRecord("__va_list32");
+  VaList32Decl->startDefinition();
+  //   char __dummy;
+  FieldDecl *Field = FieldDecl::Create(*Context, VaList32Decl,
+                                       SourceLocation(), SourceLocation(),
+                                       &Context->Idents.get("__dummy"),
+                                       Context->CharTy, /*TInfo=*/nullptr,
+                                       /*BitWidth=*/nullptr,
+                                       /*Mutable=*/false,
+                                       ICIS_NoInit);
+  Field->setAccess(AS_public);
+  VaList32Decl->addDecl(Field);
+  // };
+  VaList32Decl->completeDefinition();
+  // typedef struct __va_list32* __ptr32 __builtin_va_list32;
+  QualType VaList32Type = Context->getPointerType(
+      Context->getAddrSpaceQualType(Context->getRecordType(VaList32Decl),
+                                    LangAS::ptr32));
+  return Context->buildImplicitTypedef(VaList32Type, "__builtin_va_list32");
+}
+
 static TypedefDecl *
 CreateAArch64ABIBuiltinVaListDecl(const ASTContext *Context) {
   // struct __va_list
@@ -7473,6 +7549,13 @@
   return BuiltinMSVaListDecl;
 }
 
+TypedefDecl *ASTContext::getBuiltinVaList32Decl() const {
+  if (!BuiltinVaList32Decl)
+    BuiltinVaList32Decl = CreateVaList32Decl(this);
+
+  return BuiltinVaList32Decl;
+}
+
 bool ASTContext::canBuiltinBeRedeclared(const FunctionDecl *FD) const {
   return BuiltinInfo.canBeRedeclared(FD->getBuiltinID());
 }
@@ -9284,7 +9367,8 @@
     Type = Context.getObjCSuperType();
     break;
   case 'a':
-    Type = Context.getBuiltinVaListType();
+    Type = Signed ? Context.getBuiltinVaList32Type()
+                  : Context.getBuiltinVaListType();
     assert(!Type.isNull() && "builtin va list type not initialized!");
     break;
   case 'A':
@@ -9296,7 +9380,8 @@
     // is x86-64, where va_list is a __va_list_tag[1]. For x86,
     // we want this argument to be a char*&; for x86-64, we want
     // it to be a __va_list_tag*.
-    Type = Context.getBuiltinVaListType();
+    Type = Signed ? Context.getBuiltinVaList32Type()
+                  : Context.getBuiltinVaListType();
     assert(!Type.isNull() && "builtin va list type not initialized!");
     if (Type->isArrayType())
       Type = Context.getArrayDecayedType(Type);
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/AST/ASTDiagnostic.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/AST/ASTDiagnostic.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/AST/ASTDiagnostic.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/AST/ASTDiagnostic.cpp	2019-05-19 11:21:50.945903000 +0000
@@ -133,7 +133,8 @@
 
     // Don't desugar va_list.
     if (QualType(Ty, 0) == Context.getBuiltinVaListType() ||
-        QualType(Ty, 0) == Context.getBuiltinMSVaListType())
+        QualType(Ty, 0) == Context.getBuiltinMSVaListType() ||
+        QualType(Ty, 0) == Context.getBuiltinVaList32Type())
       break;
 
     // Otherwise, do a single-step desugar.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/AST/ASTImporter.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/AST/ASTImporter.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/AST/ASTImporter.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/AST/ASTImporter.cpp	2019-05-19 11:21:50.945903000 +0000
@@ -5448,7 +5448,7 @@
 
   return new (Importer.getToContext()) VAArgExpr(
         Importer.Import(E->getBuiltinLoc()), SubExpr, TInfo,
-        Importer.Import(E->getRParenLoc()), T, E->isMicrosoftABI());
+        Importer.Import(E->getRParenLoc()), T, E->getABIKind());
 }
 
 Expr *ASTNodeImporter::VisitGNUNullExpr(GNUNullExpr *E) {
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/AST/Decl.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/AST/Decl.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/AST/Decl.cpp	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/AST/Decl.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -1919,6 +1919,32 @@
                          SourceLocation StartL, SourceLocation IdL,
                          IdentifierInfo *Id, QualType T, TypeSourceInfo *TInfo,
                          StorageClass S) {
+  // Fix up the address space of this variable.
+  // FIXME: There should be a cleaner way to do this.
+  if (T.getAddressSpace() == LangAS::Default) {
+    LangAS AS;
+    switch (S) {
+    case SC_None:
+      if (DC->getRedeclContext()->isFileContext())
+        AS = C.StorageAddrSpace;
+      else
+        AS = C.getTargetInfo().getStackAddressSpace(C.getLangOpts());
+      break;
+    case SC_Register:
+      if (!DC->getRedeclContext()->isFunctionOrMethod()) {
+        AS = LangAS::Default;
+        break;
+      }
+      LLVM_FALLTHROUGH;
+    case SC_Auto:
+      AS = C.getTargetInfo().getStackAddressSpace(C.getLangOpts());
+      break;
+    default:
+      AS = C.StorageAddrSpace;
+    }
+    if (AS != LangAS::Default)
+      T = C.getAddrSpaceQualType(T, AS);
+  }
   return new (C, DC) VarDecl(Var, C, DC, StartL, IdL, Id, T, TInfo, S);
 }
 
@@ -2523,6 +2549,10 @@
                                  SourceLocation IdLoc, IdentifierInfo *Id,
                                  QualType T, TypeSourceInfo *TInfo,
                                  StorageClass S, Expr *DefArg) {
+  LangAS AS = C.getTargetInfo().getStackAddressSpace(C.getLangOpts());
+  if (AS != LangAS::Default && T.getAddressSpace() == LangAS::Default &&
+      !T->isVoidType())
+    T = C.getAddrSpaceQualType(T, AS);
   return new (C, DC) ParmVarDecl(ParmVar, C, DC, StartLoc, IdLoc, Id, T, TInfo,
                                  S, DefArg);
 }
@@ -4311,11 +4341,19 @@
                                              SourceLocation IdLoc,
                                              IdentifierInfo *Id, QualType Type,
                                              ImplicitParamKind ParamKind) {
+  LangAS AS = C.getTargetInfo().getStackAddressSpace(C.getLangOpts());
+  if (AS != LangAS::Default && Type.getAddressSpace() == LangAS::Default &&
+      !Type->isVoidType())
+    Type = C.getAddrSpaceQualType(Type, AS);
   return new (C, DC) ImplicitParamDecl(C, DC, IdLoc, Id, Type, ParamKind);
 }
 
 ImplicitParamDecl *ImplicitParamDecl::Create(ASTContext &C, QualType Type,
                                              ImplicitParamKind ParamKind) {
+  LangAS AS = C.getTargetInfo().getStackAddressSpace(C.getLangOpts());
+  if (AS != LangAS::Default && Type.getAddressSpace() == LangAS::Default &&
+      !Type->isVoidType())
+    Type = C.getAddrSpaceQualType(Type, AS);
   return new (C, nullptr) ImplicitParamDecl(C, Type, ParamKind);
 }
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/AST/DeclCXX.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/AST/DeclCXX.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/AST/DeclCXX.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/AST/DeclCXX.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -2147,7 +2147,7 @@
   QualType ClassTy = C.getTypeDeclType(getParent());
   ClassTy = C.getQualifiedType(ClassTy,
                                Qualifiers::fromCVRUMask(getTypeQualifiers()));
-  return C.getPointerType(ClassTy);
+  return C.getPointerType(ClassTy, /*HonorASPragma*/ true);
 }
 
 bool CXXMethodDecl::hasInlineBody() const {
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/AST/Expr.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/AST/Expr.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/AST/Expr.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/AST/Expr.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -568,8 +568,11 @@
       switch (AFT->getCallConv()) {
       case CC_C: POut << "__cdecl "; break;
       case CC_X86StdCall: POut << "__stdcall "; break;
+      case CC_X86StdCall32: POut << "__stdcall "; break;
       case CC_X86FastCall: POut << "__fastcall "; break;
+      case CC_X86FastCall32: POut << "__fastcall "; break;
       case CC_X86ThisCall: POut << "__thiscall "; break;
+      case CC_X86ThisCall32: POut << "__thiscall "; break;
       case CC_X86VectorCall: POut << "__vectorcall "; break;
       case CC_X86RegCall: POut << "__regcall "; break;
       // Only bother printing the conventions that MSVC knows about.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/AST/ItaniumMangle.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/AST/ItaniumMangle.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/AST/ItaniumMangle.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/AST/ItaniumMangle.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -2260,6 +2260,8 @@
       case LangAS::cuda_device:     ASString = "CUdevice";   break;
       case LangAS::cuda_constant:   ASString = "CUconstant"; break;
       case LangAS::cuda_shared:     ASString = "CUshared";   break;
+      //  <ptr32-addrspace> ::= "32"
+      case LangAS::ptr32:           ASString = "32";         break;
       }
     }
     if (!ASString.empty())
@@ -2677,6 +2679,10 @@
   case CC_OpenCLKernel:
   case CC_PreserveMost:
   case CC_PreserveAll:
+  case CC_X86C32:
+  case CC_X86StdCall32:
+  case CC_X86FastCall32:
+  case CC_X86ThisCall32:
     // FIXME: we should be mangling all of the above.
     return "";
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/AST/MicrosoftMangle.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/AST/MicrosoftMangle.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/AST/MicrosoftMangle.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/AST/MicrosoftMangle.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -2255,10 +2255,14 @@
     case CC_Win64:
     case CC_X86_64SysV:
     case CC_C: Out << 'A'; break;
+    case CC_X86C32: Out << 'A'; break;
     case CC_X86Pascal: Out << 'C'; break;
     case CC_X86ThisCall: Out << 'E'; break;
+    case CC_X86ThisCall32: Out << 'E'; break;
     case CC_X86StdCall: Out << 'G'; break;
+    case CC_X86StdCall32: Out << 'G'; break;
     case CC_X86FastCall: Out << 'I'; break;
+    case CC_X86FastCall32: Out << 'I'; break;
     case CC_X86VectorCall: Out << 'Q'; break;
     case CC_Swift: Out << 'S'; break;
     case CC_PreserveMost: Out << 'U'; break;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/AST/Type.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/AST/Type.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/AST/Type.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/AST/Type.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -2836,6 +2836,10 @@
   case CC_Swift: return "swiftcall";
   case CC_PreserveMost: return "preserve_most";
   case CC_PreserveAll: return "preserve_all";
+  case CC_X86C32: return "cdecl32";
+  case CC_X86StdCall32: return "stdcall32";
+  case CC_X86FastCall32: return "fastcall32";
+  case CC_X86ThisCall32: return "thiscall32";
   }
 
   llvm_unreachable("Invalid calling convention.");
@@ -3203,6 +3207,9 @@
   case AttributedType::attr_preserve_all:
   case AttributedType::attr_ms_abi:
   case AttributedType::attr_sysv_abi:
+  case AttributedType::attr_fastcall32:
+  case AttributedType::attr_thiscall32:
+  case AttributedType::attr_cdecl32:
   case AttributedType::attr_ptr32:
   case AttributedType::attr_ptr64:
   case AttributedType::attr_sptr:
@@ -3266,6 +3273,10 @@
   case attr_inteloclbicc:
   case attr_preserve_most:
   case attr_preserve_all:
+  case attr_cdecl32:
+  case attr_fastcall32:
+  case attr_stdcall32:
+  case attr_thiscall32:
     return true;
   }
   llvm_unreachable("invalid attr kind");
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/AST/TypePrinter.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/AST/TypePrinter.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/AST/TypePrinter.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/AST/TypePrinter.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -886,6 +886,18 @@
     case CC_PreserveAll:
       OS << " __attribute__((preserve_all))";
       break;
+    case CC_X86C32:
+      OS << " __attribute__((cdecl32))";
+      break;
+    case CC_X86StdCall32:
+      OS << " __attribute__((stdcall32))";
+      break;
+    case CC_X86FastCall32:
+      OS << " __attribute__((fastcall32))";
+      break;
+    case CC_X86ThisCall32:
+      OS << " __attribute__((thiscall32))";
+      break;
     }
   }
 
@@ -1768,7 +1780,7 @@
   }
   LangAS addrspace = getAddressSpace();
   if (addrspace != LangAS::Default) {
-    if (addrspace != LangAS::opencl_private) {
+    if (addrspace != LangAS::opencl_private && addrspace != LangAS::ptr32) {
       if (addSpace)
         OS << ' ';
       addSpace = true;
@@ -1794,6 +1806,8 @@
       case LangAS::cuda_shared:
         OS << "__shared";
         break;
+      case LangAS::ptr32:
+        break;
       default:
         OS << "__attribute__((address_space(";
         OS << toTargetAddressSpace(addrspace);
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Basic/IdentifierTable.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/IdentifierTable.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Basic/IdentifierTable.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/IdentifierTable.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -243,6 +243,11 @@
   if (LangOpts.DeclSpecKeyword)
     AddKeyword("__declspec", tok::kw___declspec, KEYALL, LangOpts, *this);
 
+  if (LangOpts.Interop6432) {
+    AddKeyword("__ptr32", tok::kw___ptr32, KEYALL, LangOpts, *this);
+    AddKeyword("__ptr64", tok::kw___ptr64, KEYALL, LangOpts, *this);
+  }
+
   // Add the '_experimental_modules_import' contextual keyword.
   get("import").setModulesImport(true);
 }
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Basic/TargetInfo.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/TargetInfo.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Basic/TargetInfo.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/TargetInfo.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -109,6 +109,7 @@
   SSERegParmMax = 0;
   HasAlignMac68kSupport = false;
   HasBuiltinMSVaList = false;
+  HasBuiltinVaList32 = false;
   IsRenderScriptTarget = false;
 
   // Default to no types using fpret.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/AMDGPU.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/AMDGPU.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/AMDGPU.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/AMDGPU.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -46,7 +46,8 @@
     Generic,  // opencl_generic
     Global,   // cuda_device
     Constant, // cuda_constant
-    Local     // cuda_shared
+    Local,    // cuda_shared
+    0         // ptr32
 };
 
 const LangASMap AMDGPUTargetInfo::AMDGPUDefIsPrivMap = {
@@ -58,7 +59,8 @@
     Generic,  // opencl_generic
     Global,   // cuda_device
     Constant, // cuda_constant
-    Local     // cuda_shared
+    Local,    // cuda_shared
+    0         // ptr32
 };
 } // namespace targets
 } // namespace clang
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/AMDGPU.h llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/AMDGPU.h
--- llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/AMDGPU.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/AMDGPU.h	2019-05-19 11:21:50.955903000 +0000
@@ -15,6 +15,7 @@
 #define LLVM_CLANG_LIB_BASIC_TARGETS_AMDGPU_H
 
 #include "clang/Basic/TargetInfo.h"
+#include "clang/Basic/LangOptions.h"
 #include "clang/Basic/TargetOptions.h"
 #include "llvm/ADT/StringSet.h"
 #include "llvm/ADT/Triple.h"
@@ -202,6 +203,12 @@
     return getTriple().getArch() == llvm::Triple::amdgcn ? 64 : 32;
   }
 
+  LangAS getStackAddressSpace(const LangOptions &Opts) const override {
+    if (Opts.OpenCL)
+      return LangAS::opencl_private;
+    return LangAS::Default;
+  }
+
   const char *getClobbers() const override { return ""; }
 
   ArrayRef<const char *> getGCCRegNames() const override;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/NVPTX.h llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/NVPTX.h
--- llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/NVPTX.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/NVPTX.h	2019-05-19 11:21:50.955903000 +0000
@@ -34,6 +34,7 @@
     1, // cuda_device
     4, // cuda_constant
     3, // cuda_shared
+    0  // ptr32
 };
 
 class LLVM_LIBRARY_VISIBILITY NVPTXTargetInfo : public TargetInfo {
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/SPIR.h llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/SPIR.h
--- llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/SPIR.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/SPIR.h	2019-05-19 11:21:50.955903000 +0000
@@ -31,7 +31,8 @@
     4, // opencl_generic
     0, // cuda_device
     0, // cuda_constant
-    0  // cuda_shared
+    0, // cuda_shared
+    0  // ptr32
 };
 
 class LLVM_LIBRARY_VISIBILITY SPIRTargetInfo : public TargetInfo {
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/TCE.h llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/TCE.h
--- llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/TCE.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/TCE.h	2019-05-19 11:21:50.955903000 +0000
@@ -40,7 +40,8 @@
     0, // opencl_generic
     0, // cuda_device
     0, // cuda_constant
-    0  // cuda_shared
+    0, // cuda_shared
+    0  // ptr32
 };
 
 class LLVM_LIBRARY_VISIBILITY TCETargetInfo : public TargetInfo {
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/X86.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/X86.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/X86.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/X86.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -90,6 +90,19 @@
 using namespace clang;
 using namespace clang::targets;
 
+static const LangASMap Interop6432ASMap = {
+    0, // Default
+    0, // opencl_global
+    0, // opencl_local
+    0, // opencl_constant
+    0, // opencl_private
+    0, // opencl_generic
+    0, // cuda_device
+    0, // cuda_constant
+    0, // cuda_shared
+    32 // ptr32
+};
+
 bool X86TargetInfo::setFPMath(StringRef Name) {
   if (Name == "387") {
     FPMath = FP_387;
@@ -876,6 +889,9 @@
     DefineStd(Builder, "i386", Opts);
   }
 
+  if (getTriple().getEnvironment() == llvm::Triple::Wine32)
+    Builder.defineMacro("__i386_on_x86_64__");
+
   // Subtarget options.
   // FIXME: We are hard-coding the tune parameters based on the CPU, but they
   // truly should be based on -mtune options.
@@ -1790,3 +1806,7 @@
   return llvm::makeArrayRef(BuiltinInfoX86,
                             X86::LastTSBuiltin - Builtin::FirstTSBuiltin);
 }
+
+void X86_64TargetInfo::set6432InteropAddrSpaceMap() {
+  AddrSpaceMap = &Interop6432ASMap;
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/X86.h llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/X86.h
--- llvm-toolchain-7-7.0.1/clang/lib/Basic/Targets/X86.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Basic/Targets/X86.h	2019-05-19 11:21:50.955903000 +0000
@@ -590,6 +590,7 @@
   X86_64TargetInfo(const llvm::Triple &Triple, const TargetOptions &Opts)
       : X86TargetInfo(Triple, Opts) {
     const bool IsX32 = getTriple().getEnvironment() == llvm::Triple::GNUX32;
+    const bool IsWine32 = getTriple().getEnvironment() == llvm::Triple::Wine32;
     bool IsWinCOFF =
         getTriple().isOSWindows() && getTriple().isOSBinFormatCOFF();
     LongWidth = LongAlign = PointerWidth = PointerAlign = IsX32 ? 32 : 64;
@@ -606,10 +607,18 @@
     RegParmMax = 6;
 
     // Pointers are 32-bit in x32.
-    resetDataLayout(IsX32
-                        ? "e-m:e-p:32:32-i64:64-f80:128-n8:16:32:64-S128"
-                        : IsWinCOFF ? "e-m:w-i64:64-f80:128-n8:16:32:64-S128"
-                                    : "e-m:e-i64:64-f80:128-n8:16:32:64-S128");
+    resetDataLayout(
+        IsX32
+            ? "e-m:e-p:32:32-i64:64-f80:128-n8:16:32:64-S128"
+            : IsWine32
+                ? IsWinCOFF
+                    ? "e-m:w-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+                    : "e-m:e-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+                : IsWinCOFF
+                    ? "e-m:w-i64:64-f80:128-n8:16:32:64-S128"
+                    : "e-m:e-i64:64-f80:128-n8:16:32:64-S128");
+    if (IsWine32)
+      set6432InteropAddrSpaceMap();
 
     // Use fpret only for long double.
     RealTypeUsesObjCFPRet = (1 << TargetInfo::LongDouble);
@@ -620,11 +629,25 @@
     // Make __builtin_ms_va_list available.
     HasBuiltinMSVaList = true;
 
+    // If 32-bit Interop is on, make __builtin_va_list32 available, too.
+    if (IsWine32)
+      HasBuiltinVaList32 = true;
+
     // x86-64 has atomics up to 16 bytes.
     MaxAtomicPromoteWidth = 128;
     MaxAtomicInlineWidth = 64;
   }
 
+  uint64_t getPointerWidthV(unsigned AS) const override {
+    if (AS == 32) return 32;
+    return PointerWidth;
+  }
+
+  uint64_t getPointerAlignV(unsigned AS) const override {
+    if (AS == 32) return 32;
+    return PointerAlign;
+  }
+
   BuiltinVaListKind getBuiltinVaListKind() const override {
     return TargetInfo::X86_64ABIBuiltinVaList;
   }
@@ -649,6 +672,13 @@
     case CC_X86RegCall:
     case CC_OpenCLKernel:
       return CCCR_OK;
+    case CC_X86C32:
+    case CC_X86StdCall32:
+    case CC_X86FastCall32:
+    case CC_X86ThisCall32:
+      if (getTriple().getEnvironment() == llvm::Triple::Wine32)
+        return CCCR_OK;
+      LLVM_FALLTHROUGH;
     default:
       return CCCR_Warning;
     }
@@ -686,6 +716,14 @@
   }
 
   ArrayRef<Builtin::Info> getTargetBuiltins() const override;
+
+  void set6432InteropAddrSpaceMap();
+
+  LangAS getStackAddressSpace(const LangOptions &) const override {
+    if (getTriple().getEnvironment() == llvm::Triple::Wine32)
+      return LangAS::ptr32;
+    return LangAS::Default;
+  }
 };
 
 // x86-64 Windows target
@@ -723,6 +761,13 @@
     case CC_X86RegCall:
     case CC_OpenCLKernel:
       return CCCR_OK;
+    case CC_X86C32:
+    case CC_X86StdCall32:
+    case CC_X86FastCall32:
+    case CC_X86ThisCall32:
+      if (getTriple().getEnvironment() == llvm::Triple::Wine32)
+        return CCCR_OK;
+      LLVM_FALLTHROUGH;
     default:
       return CCCR_Warning;
     }
@@ -795,12 +840,16 @@
 public:
   DarwinX86_64TargetInfo(const llvm::Triple &Triple, const TargetOptions &Opts)
       : DarwinTargetInfo<X86_64TargetInfo>(Triple, Opts) {
+    const bool IsWine32 = getTriple().getEnvironment() == llvm::Triple::Wine32;
+
     Int64Type = SignedLongLong;
     // The 64-bit iOS simulator uses the builtin bool type for Objective-C.
     llvm::Triple T = llvm::Triple(Triple);
     if (T.isiOS())
       UseSignedCharForObjCBool = false;
-    resetDataLayout("e-m:o-i64:64-f80:128-n8:16:32:64-S128");
+    resetDataLayout(IsWine32
+                        ? "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+                        : "e-m:o-i64:64-f80:128-n8:16:32:64-S128");
   }
 
   bool handleTargetFeatures(std::vector<std::string> &Features,
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/ABIInfo.h llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/ABIInfo.h
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/ABIInfo.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/ABIInfo.h	2019-05-19 11:21:50.955903000 +0000
@@ -95,6 +95,12 @@
                                          CodeGen::Address VAListAddr,
                                          QualType Ty) const;
 
+    /// Emit the target dependent code to load a value of
+    /// \arg Ty from the \c __builtin_va_list32 pointed to by \arg VAListAddr.
+    virtual CodeGen::Address EmitVAArg32(CodeGen::CodeGenFunction &CGF,
+                                         CodeGen::Address VAListAddr,
+                                         QualType Ty) const;
+
     virtual bool isHomogeneousAggregateBaseType(QualType Ty) const;
 
     virtual bool isHomogeneousAggregateSmallEnough(const Type *Base,
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGBlocks.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGBlocks.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGBlocks.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGBlocks.cpp	2019-05-19 11:21:50.955903000 +0000
@@ -922,8 +922,14 @@
       llvm::Value *byrefPointer;
       if (CI.isNested())
         byrefPointer = Builder.CreateLoad(src, "byref.capture");
-      else
-        byrefPointer = Builder.CreateBitCast(src.getPointer(), VoidPtrTy);
+      else {
+        byrefPointer = src.getPointer();
+        if (byrefPointer->getType()->getPointerAddressSpace() != 0)
+          byrefPointer = Builder.CreateAddrSpaceCast(
+              byrefPointer,
+              byrefPointer->getType()->getPointerElementType()->getPointerTo());
+        byrefPointer = Builder.CreateBitCast(byrefPointer, VoidPtrTy);
+      }
 
       // Write that void* into the capture field.
       Builder.CreateStore(byrefPointer, blockField);
@@ -2489,9 +2495,8 @@
   Address addr = emission.Addr;
 
   // That's an alloca of the byref structure type.
-  llvm::StructType *byrefType = cast<llvm::StructType>(
-    cast<llvm::PointerType>(addr.getPointer()->getType())->getElementType());
-
+  auto *byrefType = cast<llvm::StructType>(
+      addr.getType()->getPointerElementType());
   unsigned nextHeaderIndex = 0;
   CharUnits nextHeaderOffset;
   auto storeHeaderField = [&](llvm::Value *value, CharUnits fieldSize,
@@ -2525,7 +2530,11 @@
   storeHeaderField(V, getPointerSize(), "byref.isa");
 
   // Store the address of the variable into its own forwarding pointer.
-  storeHeaderField(addr.getPointer(), getPointerSize(), "byref.forwarding");
+  Address addr64 = addr;
+  if (addr64.getType()->getPointerAddressSpace() != 0)
+    addr64 = Builder.CreateAddrSpaceCast(
+        addr64, addr64.getType()->getPointerElementType()->getPointerTo());
+  storeHeaderField(addr64.getPointer(), getPointerSize(), "byref.forwarding");
 
   // Blocks ABI:
   //   c) the flags field is set to either 0 if no helper functions are
@@ -2594,7 +2603,8 @@
 void CodeGenFunction::BuildBlockRelease(llvm::Value *V, BlockFieldFlags flags) {
   llvm::Value *F = CGM.getBlockObjectDispose();
   llvm::Value *args[] = {
-    Builder.CreateBitCast(V, Int8PtrTy),
+    Builder.CreateBitCast(Builder.CreateAddrSpaceCast(
+        V, V->getType()->getPointerElementType()->getPointerTo()), Int8PtrTy),
     llvm::ConstantInt::get(Int32Ty, flags.getBitMask())
   };
   EmitNounwindRuntimeCall(F, args); // FIXME: throwing destructors?
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGBuiltin.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGBuiltin.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGBuiltin.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGBuiltin.cpp	2019-05-19 11:21:50.965903000 +0000
@@ -401,6 +401,13 @@
 
 Value *CodeGenFunction::EmitVAStartEnd(Value *ArgValue, bool IsStart) {
   llvm::Type *DestType = Int8PtrTy;
+  if (ArgValue->getType()->getPointerAddressSpace() != 0) {
+    llvm::Type *ElemType =
+        cast<llvm::PointerType>(ArgValue->getType())->getElementType();
+    ArgValue = Builder.CreateAddrSpaceCast(
+        ArgValue, llvm::PointerType::getUnqual(ElemType),
+        ArgValue->getName().data());
+  }
   if (ArgValue->getType() != DestType)
     ArgValue =
         Builder.CreateBitCast(ArgValue, DestType, ArgValue->getName().data());
@@ -1474,6 +1481,18 @@
 
     llvm::Type *Type = Int8PtrTy;
 
+    if (DstPtr->getType()->getPointerAddressSpace() != 0) {
+      llvm::Type *ElemType =
+          cast<llvm::PointerType>(DstPtr->getType())->getElementType();
+      DstPtr = Builder.CreateAddrSpaceCast(
+          DstPtr, llvm::PointerType::getUnqual(ElemType));
+    }
+    if (SrcPtr->getType()->getPointerAddressSpace() != 0) {
+      llvm::Type *ElemType =
+          cast<llvm::PointerType>(SrcPtr->getType())->getElementType();
+      SrcPtr = Builder.CreateAddrSpaceCast(
+          SrcPtr, llvm::PointerType::getUnqual(ElemType));
+    }
     DstPtr = Builder.CreateBitCast(DstPtr, Type);
     SrcPtr = Builder.CreateBitCast(SrcPtr, Type);
     return RValue::get(Builder.CreateCall(CGM.getIntrinsic(Intrinsic::vacopy),
@@ -1976,6 +1995,11 @@
     EmitNonNullArgCheck(RValue::get(Src.getPointer()), E->getArg(1)->getType(),
                         E->getArg(1)->getExprLoc(), FD, 1);
     Builder.CreateMemCpy(Dest, Src, SizeVal, false);
+    if (Dest.getPointer()->getType()->getPointerAddressSpace() != 0)
+      // Cast it to the correct AS.
+      Dest = Builder.CreateAddrSpaceCast(
+          Dest,
+         Dest.getPointer()->getType()->getPointerElementType()->getPointerTo());
     return RValue::get(Dest.getPointer());
   }
 
@@ -1995,6 +2019,11 @@
     Address Src = EmitPointerWithAlignment(E->getArg(1));
     Value *SizeVal = llvm::ConstantInt::get(Builder.getContext(), Size);
     Builder.CreateMemCpy(Dest, Src, SizeVal, false);
+    if (Dest.getPointer()->getType()->getPointerAddressSpace() != 0)
+      // Cast it to the correct AS.
+      Dest = Builder.CreateAddrSpaceCast(
+          Dest,
+         Dest.getPointer()->getType()->getPointerElementType()->getPointerTo());
     return RValue::get(Dest.getPointer());
   }
 
@@ -2019,6 +2048,11 @@
     Address Src = EmitPointerWithAlignment(E->getArg(1));
     Value *SizeVal = llvm::ConstantInt::get(Builder.getContext(), Size);
     Builder.CreateMemMove(Dest, Src, SizeVal, false);
+    if (Dest.getPointer()->getType()->getPointerAddressSpace() != 0)
+      // Cast it to the correct AS.
+      Dest = Builder.CreateAddrSpaceCast(
+          Dest,
+         Dest.getPointer()->getType()->getPointerElementType()->getPointerTo());
     return RValue::get(Dest.getPointer());
   }
 
@@ -2032,6 +2066,11 @@
     EmitNonNullArgCheck(RValue::get(Src.getPointer()), E->getArg(1)->getType(),
                         E->getArg(1)->getExprLoc(), FD, 1);
     Builder.CreateMemMove(Dest, Src, SizeVal, false);
+    if (Dest.getPointer()->getType()->getPointerAddressSpace() != 0)
+      // Cast it to the correct AS.
+      Dest = Builder.CreateAddrSpaceCast(
+          Dest,
+         Dest.getPointer()->getType()->getPointerElementType()->getPointerTo());
     return RValue::get(Dest.getPointer());
   }
   case Builtin::BImemset:
@@ -2043,6 +2082,11 @@
     EmitNonNullArgCheck(RValue::get(Dest.getPointer()), E->getArg(0)->getType(),
                         E->getArg(0)->getExprLoc(), FD, 0);
     Builder.CreateMemSet(Dest, ByteVal, SizeVal, false);
+    if (Dest.getPointer()->getType()->getPointerAddressSpace() != 0)
+      // Cast it to the correct AS.
+      Dest = Builder.CreateAddrSpaceCast(
+          Dest,
+         Dest.getPointer()->getType()->getPointerElementType()->getPointerTo());
     return RValue::get(Dest.getPointer());
   }
   case Builtin::BI__builtin___memset_chk: {
@@ -2058,6 +2102,11 @@
                                          Builder.getInt8Ty());
     Value *SizeVal = llvm::ConstantInt::get(Builder.getContext(), Size);
     Builder.CreateMemSet(Dest, ByteVal, SizeVal, false);
+    if (Dest.getPointer()->getType()->getPointerAddressSpace() != 0)
+      // Cast it to the correct AS.
+      Dest = Builder.CreateAddrSpaceCast(
+          Dest,
+         Dest.getPointer()->getType()->getPointerElementType()->getPointerTo());
     return RValue::get(Dest.getPointer());
   }
   case Builtin::BI__builtin_wmemcmp: {
@@ -3622,12 +3671,10 @@
     Address DestAddr = EmitMSVAListRef(E->getArg(0));
     Address SrcAddr = EmitMSVAListRef(E->getArg(1));
 
-    llvm::Type *BPP = Int8PtrPtrTy;
+    llvm::Type *Type = Int8PtrTy;
 
-    DestAddr = Address(Builder.CreateBitCast(DestAddr.getPointer(), BPP, "cp"),
-                       DestAddr.getAlignment());
-    SrcAddr = Address(Builder.CreateBitCast(SrcAddr.getPointer(), BPP, "ap"),
-                      SrcAddr.getAlignment());
+    DestAddr = Builder.CreateElementBitCast(DestAddr, Type, "cp");
+    SrcAddr = Builder.CreateElementBitCast(SrcAddr, Type, "ap");
 
     Value *ArgPtr = Builder.CreateLoad(SrcAddr, "ap.val");
     return RValue::get(Builder.CreateStore(ArgPtr, DestAddr));
@@ -8973,6 +9020,23 @@
   if (BuiltinID == X86::BI__builtin_cpu_init)
     return EmitX86CpuInit();
 
+  if (BuiltinID == X86::BI__builtin_va_start32 ||
+      BuiltinID == X86::BI__builtin_va_end32)
+    return EmitVAStartEnd(EmitVAList32Ref(E->getArg(0)).getPointer(),
+                          BuiltinID == X86::BI__builtin_va_start32);
+  if (BuiltinID == X86::BI__builtin_va_copy32) {
+    Address DestAddr = EmitVAList32Ref(E->getArg(0));
+    Address SrcAddr = EmitVAList32Ref(E->getArg(1));
+
+    llvm::Type *Type = llvm::PointerType::get(Int8Ty, 32);
+
+    DestAddr = Builder.CreateElementBitCast(DestAddr, Type, "cp");
+    SrcAddr = Builder.CreateElementBitCast(SrcAddr, Type, "ap");
+
+    Value *ArgPtr = Builder.CreateLoad(SrcAddr, "ap.val");
+    return Builder.CreateStore(ArgPtr, DestAddr);
+  }
+
   SmallVector<Value*, 4> Ops;
 
   // Find out if any arguments are required to be integer constant expressions.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGCall.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGCall.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGCall.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGCall.cpp	2019-05-19 11:21:50.965903000 +0000
@@ -41,15 +41,18 @@
 using namespace clang;
 using namespace CodeGen;
 
-/***/
+/** */
 
 unsigned CodeGenTypes::ClangCallConvToLLVMCallConv(CallingConv CC) {
   switch (CC) {
   default: return llvm::CallingConv::C;
-  case CC_X86StdCall: return llvm::CallingConv::X86_StdCall;
-  case CC_X86FastCall: return llvm::CallingConv::X86_FastCall;
+  case CC_X86StdCall:
+  case CC_X86StdCall32: return llvm::CallingConv::X86_StdCall;
+  case CC_X86FastCall:
+  case CC_X86FastCall32: return llvm::CallingConv::X86_FastCall;
   case CC_X86RegCall: return llvm::CallingConv::X86_RegCall;
-  case CC_X86ThisCall: return llvm::CallingConv::X86_ThisCall;
+  case CC_X86ThisCall:
+  case CC_X86ThisCall32: return llvm::CallingConv::X86_ThisCall;
   case CC_Win64: return llvm::CallingConv::Win64;
   case CC_X86_64SysV: return llvm::CallingConv::X86_64_SysV;
   case CC_AAPCS: return llvm::CallingConv::ARM_AAPCS;
@@ -64,6 +67,7 @@
   case CC_PreserveMost: return llvm::CallingConv::PreserveMost;
   case CC_PreserveAll: return llvm::CallingConv::PreserveAll;
   case CC_Swift: return llvm::CallingConv::Swift;
+  case CC_X86C32: return llvm::CallingConv::X86_64_C32;
   }
 }
 
@@ -229,6 +233,18 @@
   if (D->hasAttr<PreserveAllAttr>())
     return CC_PreserveAll;
 
+  if (D->hasAttr<StdCall32Attr>())
+    return CC_X86StdCall32;
+
+  if (D->hasAttr<FastCall32Attr>())
+    return CC_X86FastCall32;
+
+  if (D->hasAttr<ThisCall32Attr>())
+    return CC_X86ThisCall32;
+
+  if (D->hasAttr<CDecl32Attr>())
+    return CC_X86C32;
+
   return CC_C;
 }
 
@@ -1360,6 +1376,7 @@
 /// CGFunctionInfo should be passed to actual LLVM IR function.
 class ClangToLLVMArgMapping {
   static const unsigned InvalidIndex = ~0U;
+  unsigned ThunkDataArgNo;
   unsigned InallocaArgNo;
   unsigned SRetArgNo;
   unsigned TotalIRArgs;
@@ -1382,11 +1399,18 @@
 public:
   ClangToLLVMArgMapping(const ASTContext &Context, const CGFunctionInfo &FI,
                         bool OnlyRequiredArgs = false)
-      : InallocaArgNo(InvalidIndex), SRetArgNo(InvalidIndex), TotalIRArgs(0),
+      : ThunkDataArgNo(InvalidIndex), InallocaArgNo(InvalidIndex),
+        SRetArgNo(InvalidIndex), TotalIRArgs(0),
         ArgInfo(OnlyRequiredArgs ? FI.getNumRequiredArgs() : FI.arg_size()) {
     construct(Context, FI, OnlyRequiredArgs);
   }
 
+  bool hasThunkDataArg() const { return ThunkDataArgNo != InvalidIndex; }
+  unsigned getThunkDataArgNo() const {
+    assert(hasThunkDataArg());
+    return ThunkDataArgNo;
+  }
+
   bool hasInallocaArg() const { return InallocaArgNo != InvalidIndex; }
   unsigned getInallocaArgNo() const {
     assert(hasInallocaArg());
@@ -1423,6 +1447,14 @@
                  bool OnlyRequiredArgs);
 };
 
+static bool is32BitInteropCC(const CGFunctionInfo &FI, bool IsWine32Target) {
+  return FI.getCallingConvention() == llvm::CallingConv::X86_64_C32 ||
+    (IsWine32Target &&
+     (FI.getCallingConvention() == llvm::CallingConv::X86_StdCall ||
+      FI.getCallingConvention() == llvm::CallingConv::X86_FastCall ||
+      FI.getCallingConvention() == llvm::CallingConv::X86_ThisCall));
+}
+
 void ClangToLLVMArgMapping::construct(const ASTContext &Context,
                                       const CGFunctionInfo &FI,
                                       bool OnlyRequiredArgs) {
@@ -1435,6 +1467,12 @@
     SRetArgNo = SwapThisWithSRet ? 1 : IRArgNo++;
   }
 
+  if (is32BitInteropCC(
+        FI, Context.getTargetInfo().getTriple().getEnvironment() ==
+        llvm::Triple::Wine32)) {
+    ThunkDataArgNo = IRArgNo++;
+  }
+
   unsigned ArgNo = 0;
   unsigned NumArgs = OnlyRequiredArgs ? FI.getNumRequiredArgs() : FI.arg_size();
   for (CGFunctionInfo::const_arg_iterator I = FI.arg_begin(); ArgNo < NumArgs;
@@ -1599,6 +1637,15 @@
     ArgTypes[IRFunctionArgs.getInallocaArgNo()] = ArgStruct->getPointerTo();
   }
 
+  // Add type for thunkdata argument.
+  if (IRFunctionArgs.hasThunkDataArg()) {
+    auto *ThunkDataStruct = llvm::StructType::get(
+        llvm::ArrayType::get(CGM.Int64Ty, 6));
+    assert(ThunkDataStruct);
+    ArgTypes[IRFunctionArgs.getThunkDataArgNo()] =
+        ThunkDataStruct->getPointerTo(32);
+  }
+
   // Add in all of the required arguments.
   unsigned ArgNo = 0;
   CGFunctionInfo::const_arg_iterator it = FI.arg_begin(),
@@ -2005,6 +2052,14 @@
         llvm::AttributeSet::get(getLLVMContext(), Attrs);
   }
 
+  // Attach attributes to thunkdata argument.
+  if (IRFunctionArgs.hasThunkDataArg()) {
+    llvm::AttrBuilder Attrs;
+    Attrs.addAttribute(llvm::Attribute::ThunkData);
+    ArgAttrs[IRFunctionArgs.getThunkDataArgNo()] =
+        llvm::AttributeSet::get(getLLVMContext(), Attrs);
+  }
+
   unsigned ArgNo = 0;
   for (CGFunctionInfo::const_arg_iterator I = FI.arg_begin(),
                                           E = FI.arg_end();
@@ -2257,6 +2312,13 @@
     AI->addAttr(llvm::Attribute::NoAlias);
   }
 
+  // Name the thunk data parameter.
+  if (IRFunctionArgs.hasThunkDataArg()) {
+    auto AI = cast<llvm::Argument>(FnArgs[IRFunctionArgs.getThunkDataArgNo()]);
+    AI->setName("thunk.data");
+    AI->addAttr(llvm::Attribute::NoAlias);
+  }
+
   // Track if we received the parameter as a pointer (indirect, byval, or
   // inalloca).  If already have a pointer, EmitParmDecl doesn't need to copy it
   // into a local alloca for us.
@@ -2318,8 +2380,8 @@
           // copy.
           CharUnits Size = getContext().getTypeSizeInChars(Ty);
           auto SizeVal = llvm::ConstantInt::get(IntPtrTy, Size.getQuantity());
-          Address Dst = Builder.CreateBitCast(AlignedTemp, Int8PtrTy);
-          Address Src = Builder.CreateBitCast(ParamAddr, Int8PtrTy);
+          Address Dst = Builder.CreateBitCast(AlignedTemp, AllocaInt8PtrTy);
+          Address Src = Builder.CreateBitCast(ParamAddr, AllocaInt8PtrTy);
           Builder.CreateMemCpy(Dst, Src, SizeVal, false);
           V = AlignedTemp;
         }
@@ -3831,6 +3893,15 @@
   ClangToLLVMArgMapping IRFunctionArgs(CGM.getContext(), CallInfo);
   SmallVector<llvm::Value *, 16> IRCallArgs(IRFunctionArgs.totalIRArgs());
 
+  // If we need thunk data, add that now.
+  if (IRFunctionArgs.hasThunkDataArg()) {
+    if (!ThunkData.isValid())
+      ThunkData = CreateTempAllocaWithoutCast(
+          llvm::StructType::get(llvm::ArrayType::get(Int64Ty, 6)),
+          CharUnits::fromQuantity(8), "thunk.storage");
+    IRCallArgs[IRFunctionArgs.getThunkDataArgNo()] = ThunkData.getPointer();
+  }
+
   // If the call returns a temporary with struct return, create a temporary
   // alloca to hold the result, unless one is given to us.
   Address SRetPtr = Address::invalid();
@@ -3848,7 +3919,13 @@
       }
     }
     if (IRFunctionArgs.hasSRetArg()) {
-      IRCallArgs[IRFunctionArgs.getSRetArgNo()] = SRetPtr.getPointer();
+      Address SRetPtr64 = SRetPtr;
+      if (SRetPtr64.getType()->getPointerAddressSpace() !=
+         IRFuncTy->getParamType(IRFunctionArgs.getSRetArgNo())
+             ->getPointerAddressSpace())
+        SRetPtr64 = Builder.CreateAddrSpaceCast(
+            SRetPtr64, IRFuncTy->getParamType(IRFunctionArgs.getSRetArgNo()));
+      IRCallArgs[IRFunctionArgs.getSRetArgNo()] = SRetPtr64.getPointer();
     } else if (RetAI.isInAlloca()) {
       Address Addr = createInAllocaStructGEP(RetAI.getInAllocaFieldIndex());
       Builder.CreateStore(SRetPtr.getPointer(), Addr);
@@ -3949,7 +4026,8 @@
                (LV.getAlignment() >=
                 getContext().getTypeAlignInChars(I->Ty))) ||
               (ArgInfo.getIndirectByVal() &&
-               ((AS != LangAS::Default && AS != LangAS::opencl_private &&
+               ((AS != Target.getStackAddressSpace(getLangOpts()) &&
+                 AS != LangAS::opencl_private &&
                  AS != CGM.getASTAllocaAddressSpace())))) {
             NeedCopy = true;
           }
@@ -3965,8 +4043,8 @@
           auto *T = V->getType()->getPointerElementType()->getPointerTo(
               CGM.getDataLayout().getAllocaAddrSpace());
           IRCallArgs[FirstIRArg] = getTargetHooks().performAddrSpaceCast(
-              *this, V, LangAS::Default, CGM.getASTAllocaAddressSpace(), T,
-              true);
+              *this, V, Target.getStackAddressSpace(getLangOpts()),
+              CGM.getASTAllocaAddressSpace(), T, true);
         }
       }
       break;
@@ -4514,9 +4592,13 @@
 Address CodeGenFunction::EmitVAArg(VAArgExpr *VE, Address &VAListAddr) {
   VAListAddr = VE->isMicrosoftABI()
                  ? EmitMSVAListRef(VE->getSubExpr())
-                 : EmitVAListRef(VE->getSubExpr());
+                 : VE->is32BitABI()
+                   ? EmitVAList32Ref(VE->getSubExpr())
+                   : EmitVAListRef(VE->getSubExpr());
   QualType Ty = VE->getType();
   if (VE->isMicrosoftABI())
     return CGM.getTypes().getABIInfo().EmitMSVAArg(*this, VAListAddr, Ty);
+  if (VE->is32BitABI())
+    return CGM.getTypes().getABIInfo().EmitVAArg32(*this, VAListAddr, Ty);
   return CGM.getTypes().getABIInfo().EmitVAArg(*this, VAListAddr, Ty);
 }
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGClass.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGClass.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGClass.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGClass.cpp	2019-05-19 11:21:50.965903000 +0000
@@ -2791,7 +2791,8 @@
     CGM.getTypes().arrangeCXXMethodDeclaration(callOperator);
   llvm::Constant *calleePtr =
     CGM.GetAddrOfFunction(GlobalDecl(callOperator),
-                          CGM.getTypes().GetFunctionType(calleeFnInfo));
+                          CGM.getTypes().GetFunctionType(calleeFnInfo),
+                          /*ForCall=*/true);
 
   // Prepare the return slot.
   const FunctionProtoType *FPT =
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGDebugInfo.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGDebugInfo.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGDebugInfo.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGDebugInfo.cpp	2019-05-19 11:21:50.965903000 +0000
@@ -1043,11 +1043,16 @@
     // Avoid emitting DW_AT_calling_convention if the C convention was used.
     return 0;
 
+  case CC_X86C32:
+    return llvm::dwarf::DW_CC_LLVM_C32;
   case CC_X86StdCall:
+  case CC_X86StdCall32:
     return llvm::dwarf::DW_CC_BORLAND_stdcall;
   case CC_X86FastCall:
+  case CC_X86FastCall32:
     return llvm::dwarf::DW_CC_BORLAND_msfastcall;
   case CC_X86ThisCall:
+  case CC_X86ThisCall32:
     return llvm::dwarf::DW_CC_BORLAND_thiscall;
   case CC_X86VectorCall:
     return llvm::dwarf::DW_CC_LLVM_vectorcall;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGDecl.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGDecl.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGDecl.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGDecl.cpp	2019-05-19 11:21:50.965903000 +0000
@@ -1152,7 +1152,7 @@
 CodeGenFunction::EmitAutoVarAlloca(const VarDecl &D) {
   QualType Ty = D.getType();
   assert(
-      Ty.getAddressSpace() == LangAS::Default ||
+      Ty.getAddressSpace() == Target.getStackAddressSpace(getLangOpts()) ||
       (Ty.getAddressSpace() == LangAS::opencl_private && getLangOpts().OpenCL));
 
   AutoVarEmission emission(D);
@@ -1702,7 +1702,7 @@
   if (const CleanupAttr *CA = D.getAttr<CleanupAttr>()) {
     const FunctionDecl *FD = CA->getFunctionDecl();
 
-    llvm::Constant *F = CGM.GetAddrOfFunction(FD);
+    llvm::Constant *F = CGM.GetAddrOfFunction(FD, nullptr, /*ForCall=*/true);
     assert(F && "Could not find function!");
 
     const CGFunctionInfo &Info = CGM.getTypes().arrangeFunctionDeclaration(FD);
@@ -2080,8 +2080,9 @@
     auto AllocaAS = CGM.getASTAllocaAddressSpace();
     auto *V = DeclPtr.getPointer();
     auto SrcLangAS = getLangOpts().OpenCL ? LangAS::opencl_private : AllocaAS;
-    auto DestLangAS =
-        getLangOpts().OpenCL ? LangAS::opencl_private : LangAS::Default;
+    auto DestLangAS = getLangOpts().OpenCL
+        ? LangAS::opencl_private
+        : getTarget().getStackAddressSpace(getLangOpts());
     if (SrcLangAS != DestLangAS) {
       assert(getContext().getTargetAddressSpace(SrcLangAS) ==
              CGM.getDataLayout().getAllocaAddrSpace());
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGExpr.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGExpr.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGExpr.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGExpr.cpp	2019-05-19 11:21:50.965903000 +0000
@@ -84,8 +84,9 @@
   // be different from the type defined by the language. For example,
   // in C++ the auto variables are in the default address space. Therefore
   // cast alloca to the default address space when necessary.
-  if (getASTAllocaAddressSpace() != LangAS::Default) {
-    auto DestAddrSpace = getContext().getTargetAddressSpace(LangAS::Default);
+  if (getASTAllocaAddressSpace() != Target.getStackAddressSpace(getLangOpts())){
+    auto DestAddrSpace = getContext().getTargetAddressSpace(
+        Target.getStackAddressSpace(getLangOpts()));
     llvm::IRBuilderBase::InsertPointGuard IPG(Builder);
     // When ArraySize is nullptr, alloca is inserted at AllocaInsertPt,
     // otherwise alloca is inserted at the current insertion point of the
@@ -93,7 +94,8 @@
     if (!ArraySize)
       Builder.SetInsertPoint(AllocaInsertPt);
     V = getTargetHooks().performAddrSpaceCast(
-        *this, V, getASTAllocaAddressSpace(), LangAS::Default,
+        *this, V, getASTAllocaAddressSpace(),
+        Target.getStackAddressSpace(getLangOpts()),
         Ty->getPointerTo(DestAddrSpace), /*non-null*/ true);
   }
 
@@ -2329,13 +2331,14 @@
 }
 
 static llvm::Constant *EmitFunctionDeclPointer(CodeGenModule &CGM,
-                                               const FunctionDecl *FD) {
+                                               const FunctionDecl *FD,
+                                               bool ForCall = false) {
   if (FD->hasAttr<WeakRefAttr>()) {
     ConstantAddress aliasee = CGM.GetWeakRefReference(FD);
     return aliasee.getPointer();
   }
 
-  llvm::Constant *V = CGM.GetAddrOfFunction(FD);
+  llvm::Constant *V = CGM.GetAddrOfFunction(FD, nullptr, ForCall);
   if (!FD->hasPrototype()) {
     if (const FunctionProtoType *Proto =
             FD->getType()->getAs<FunctionProtoType>()) {
@@ -2637,15 +2640,17 @@
   std::string GVName = llvm::join(NameItems, NameItems + 2, ".");
   if (auto *BD = dyn_cast_or_null<BlockDecl>(CurCodeDecl)) {
     std::string Name = SL->getString();
+    LangAS AS = CGM.getContext().getAsConstantArrayType(
+        SL->getType())->getElementType().getAddressSpace();
     if (!Name.empty()) {
       unsigned Discriminator =
           CGM.getCXXABI().getMangleContext().getBlockId(BD, true);
       if (Discriminator)
         Name += "_" + Twine(Discriminator + 1).str();
-      auto C = CGM.GetAddrOfConstantCString(Name, GVName.c_str());
+      auto C = CGM.GetAddrOfConstantCString(Name, GVName.c_str(), AS);
       return MakeAddrLValue(C, E->getType(), AlignmentSource::Decl);
     } else {
-      auto C = CGM.GetAddrOfConstantCString(FnName, GVName.c_str());
+      auto C = CGM.GetAddrOfConstantCString(FnName, GVName.c_str(), AS);
       return MakeAddrLValue(C, E->getType(), AlignmentSource::Decl);
     }
   }
@@ -3197,6 +3202,15 @@
   llvm::Type *NewTy = ConvertType(E->getType());
   Addr = Builder.CreateElementBitCast(Addr, NewTy);
 
+  // If the array is a temporary from a GNU compound literal, and the stack
+  // address space is different from the global address space, then the temp
+  // will be in the wrong AS. We have to emit an addrspacecast in that case.
+  unsigned TargetAS =
+      CGM.getContext().getTargetAddressSpace(E->getType().getAddressSpace());
+  if (TargetAS != Addr.getType()->getAddressSpace())
+    Addr = Builder.CreateAddrSpaceCast(Addr, NewTy->getPointerTo(TargetAS),
+                                       "arraydecay.as");
+
   // Note that VLA pointers are always decayed, so we don't need to do
   // anything here.
   if (!E->getType()->isVariableArrayType()) {
@@ -4333,7 +4347,8 @@
     return CGCallee::forBuiltin(builtinID, FD);
   }
 
-  llvm::Constant *calleePtr = EmitFunctionDeclPointer(CGF.CGM, FD);
+  llvm::Constant *calleePtr = EmitFunctionDeclPointer(CGF.CGM, FD,
+                                                      /*ForCall=*/true);
   return CGCallee::forDirect(calleePtr, FD);
 }
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGExprCXX.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGExprCXX.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGExprCXX.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGExprCXX.cpp	2019-05-19 11:21:50.965903000 +0000
@@ -177,7 +177,8 @@
 
   if (MD->isStatic()) {
     // The method is static, emit it as we would a regular call.
-    CGCallee callee = CGCallee::forDirect(CGM.GetAddrOfFunction(MD), MD);
+    CGCallee callee = CGCallee::forDirect(
+        CGM.GetAddrOfFunction(MD, nullptr, /*ForCall=*/true), MD);
     return EmitCall(getContext().getPointerType(MD->getType()), callee, CE,
                     ReturnValue);
   }
@@ -358,7 +359,8 @@
         const CXXDestructorDecl *DDtor =
           cast<CXXDestructorDecl>(DevirtualizedMethod);
         Callee = CGCallee::forDirect(
-                  CGM.GetAddrOfFunction(GlobalDecl(DDtor, Dtor_Complete), Ty),
+                  CGM.GetAddrOfFunction(GlobalDecl(DDtor, Dtor_Complete), Ty,
+                                        /*ForCall=*/true),
                                      DDtor);
       }
       EmitCXXMemberOrOperatorCall(
@@ -371,7 +373,8 @@
   CGCallee Callee;
   if (const CXXConstructorDecl *Ctor = dyn_cast<CXXConstructorDecl>(MD)) {
     Callee = CGCallee::forDirect(
-                  CGM.GetAddrOfFunction(GlobalDecl(Ctor, Ctor_Complete), Ty),
+                  CGM.GetAddrOfFunction(GlobalDecl(Ctor, Ctor_Complete), Ty,
+                                        /*ForCall=*/true),
                                  Ctor);
   } else if (UseVirtualCall) {
     Callee = CGCallee::forVirtual(CE, MD, This.getAddress(), Ty);
@@ -389,11 +392,12 @@
     if (getLangOpts().AppleKext && MD->isVirtual() && HasQualifier)
       Callee = BuildAppleKextVirtualCall(MD, Qualifier, Ty);
     else if (!DevirtualizedMethod)
-      Callee = CGCallee::forDirect(CGM.GetAddrOfFunction(MD, Ty), MD);
+      Callee = CGCallee::forDirect(
+          CGM.GetAddrOfFunction(MD, Ty, /*ForCall=*/true), MD);
     else {
       Callee = CGCallee::forDirect(
-                                CGM.GetAddrOfFunction(DevirtualizedMethod, Ty),
-                                   DevirtualizedMethod);
+          CGM.GetAddrOfFunction(DevirtualizedMethod, Ty, /*ForCall=*/true),
+          DevirtualizedMethod);
     }
   }
 
@@ -1292,7 +1296,8 @@
                                 const FunctionProtoType *CalleeType,
                                 const CallArgList &Args) {
   llvm::Instruction *CallOrInvoke;
-  llvm::Constant *CalleePtr = CGF.CGM.GetAddrOfFunction(CalleeDecl);
+  llvm::Constant *CalleePtr =
+      CGF.CGM.GetAddrOfFunction(CalleeDecl, nullptr, /*ForCall=*/true);
   CGCallee Callee = CGCallee::forDirect(CalleePtr, CalleeDecl);
   RValue RV =
       CGF.EmitCall(CGF.CGM.getTypes().arrangeFreeFunctionCall(
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGObjC.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGObjC.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGObjC.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGObjC.cpp	2019-05-19 11:21:50.965903000 +0000
@@ -932,8 +932,11 @@
     if (ivarSize > retTySize) {
       llvm::Type *newTy = llvm::Type::getIntNTy(getLLVMContext(), retTySize);
       ivarVal = Builder.CreateTrunc(load, newTy);
-      bitcastType = newTy->getPointerTo();
-    }
+      bitcastType = newTy->getPointerTo(
+          ReturnValue.getType()->getPointerAddressSpace());
+    } else
+      bitcastType = bitcastType->getPointerElementType()->getPointerTo(
+          ReturnValue.getType()->getPointerAddressSpace());
     Builder.CreateStore(ivarVal,
                         Builder.CreateBitCast(ReturnValue, bitcastType));
 
@@ -1537,7 +1540,11 @@
   CallArgList Args;
 
   // The first argument is a temporary of the enumeration-state type.
-  Args.add(RValue::get(StatePtr.getPointer()),
+  Address StatePtr64 = StatePtr;
+  if (StatePtr64.getType()->getPointerAddressSpace() != 0)
+    StatePtr64 = Builder.CreateAddrSpaceCast(
+      StatePtr64,StatePtr64.getType()->getPointerElementType()->getPointerTo());
+  Args.add(RValue::get(StatePtr64.getPointer()),
            getContext().getPointerType(StateTy));
 
   // The second argument is a temporary array with space for NumItems
@@ -1545,6 +1552,9 @@
   // pointer written into the control state; this buffer is so that
   // collections that *aren't* backed by arrays can still queue up
   // batches of elements.
+  if (ItemsPtr.getType()->getPointerAddressSpace() != 0)
+    ItemsPtr = Builder.CreateAddrSpaceCast(
+        ItemsPtr, ItemsPtr.getType()->getPointerElementType()->getPointerTo());
   Args.add(RValue::get(ItemsPtr.getPointer()),
            getContext().getPointerType(ItemsTy));
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGObjCMac.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGObjCMac.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGObjCMac.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGObjCMac.cpp	2019-05-19 11:21:50.965903000 +0000
@@ -2037,6 +2037,9 @@
   Target = CGF.Builder.CreateBitCast(Target, ClassTy);
   CGF.Builder.CreateStore(Target,
           CGF.Builder.CreateStructGEP(ObjCSuper, 1, CGF.getPointerSize()));
+  if (ObjCSuper.getType()->getPointerAddressSpace() != 0)
+    ObjCSuper = CGF.Builder.CreateAddrSpaceCast(
+        ObjCSuper,ObjCSuper.getType()->getPointerElementType()->getPointerTo());
   return EmitMessageSend(CGF, Return, ResultType,
                          EmitSelector(CGF, Sel),
                          ObjCSuper.getPointer(), ObjCTypes.SuperPtrCTy,
@@ -7289,6 +7292,9 @@
   CGF.Builder.CreateStore(
       Target, CGF.Builder.CreateStructGEP(ObjCSuper, 1, CGF.getPointerSize()));
 
+  if (ObjCSuper.getType()->getPointerAddressSpace() != 0)
+    ObjCSuper = CGF.Builder.CreateAddrSpaceCast(
+        ObjCSuper,ObjCSuper.getType()->getPointerElementType()->getPointerTo());
   return (isVTableDispatchedSelector(Sel))
     ? EmitVTableMessageSend(CGF, Return, ResultType, Sel,
                             ObjCSuper.getPointer(), ObjCTypes.SuperPtrCTy,
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGStmt.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGStmt.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CGStmt.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CGStmt.cpp	2019-05-19 11:21:50.975903000 +0000
@@ -1980,8 +1980,16 @@
             << OutExpr->getType() << OutputConstraint;
       }
     } else {
-      ArgTypes.push_back(Dest.getAddress().getType());
-      Args.push_back(Dest.getPointer());
+      if (llvm::Type* AdjTy = getTargetHooks().adjustInlineAsmType(
+              *this, OutputConstraint, Dest.getAddress().getType())) {
+        llvm::Value *Arg = Builder.CreateAddrSpaceCast(
+            Dest.getPointer(), AdjTy);
+        ArgTypes.push_back(AdjTy);
+        Args.push_back(Arg);
+      } else {
+        ArgTypes.push_back(Dest.getAddress().getType());
+        Args.push_back(Dest.getPointer());
+      }
       Constraints += "=*";
       Constraints += OutputConstraint;
       ReadOnly = ReadNone = false;
@@ -1997,8 +2005,16 @@
 
       if (llvm::Type* AdjTy =
           getTargetHooks().adjustInlineAsmType(*this, OutputConstraint,
-                                               Arg->getType()))
+                                               Arg->getType())) {
+        if (AdjTy->isPointerTy() &&
+            AdjTy->getPointerAddressSpace() !=
+                Arg->getType()->getPointerAddressSpace())
+          Arg = Builder.CreateAddrSpaceCast(
+              Arg,
+              Arg->getType()->getPointerElementType()->getPointerTo(
+                  AdjTy->getPointerAddressSpace()));
         Arg = Builder.CreateBitCast(Arg, AdjTy);
+      }
 
       if (Info.allowsRegister())
         InOutConstraints += llvm::utostr(i);
@@ -2074,9 +2090,16 @@
     }
     if (llvm::Type* AdjTy =
               getTargetHooks().adjustInlineAsmType(*this, InputConstraint,
-                                                   Arg->getType()))
+                                                   Arg->getType())) {
+      if (AdjTy->isPointerTy() &&
+          AdjTy->getPointerAddressSpace() !=
+              Arg->getType()->getPointerAddressSpace())
+        Arg = Builder.CreateAddrSpaceCast(
+            Arg,
+            Arg->getType()->getPointerElementType()->getPointerTo(
+                AdjTy->getPointerAddressSpace()));
       Arg = Builder.CreateBitCast(Arg, AdjTy);
-    else
+    } else
       CGM.getDiags().Report(S.getAsmLoc(), diag::err_asm_invalid_type_in_input)
           << InputExpr->getType() << InputConstraint;
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CodeGenFunction.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CodeGenFunction.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CodeGenFunction.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CodeGenFunction.cpp	2019-05-19 11:21:50.975903000 +0000
@@ -2154,6 +2154,10 @@
   return EmitLValue(E).getAddress();
 }
 
+Address CodeGenFunction::EmitVAList32Ref(const Expr *E) {
+  return EmitLValue(E).getAddress();
+}
+
 void CodeGenFunction::EmitDeclRefExprDbgValue(const DeclRefExpr *E,
                                               const APValue &Init) {
   assert(!Init.isUninit() && "Invalid DeclRefExpr initializer!");
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CodeGenFunction.h llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CodeGenFunction.h
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CodeGenFunction.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CodeGenFunction.h	2019-05-19 11:21:50.975903000 +0000
@@ -327,6 +327,9 @@
   /// value. This is invalid iff the function has no return value.
   Address ReturnValue = Address::invalid();
 
+  /// An alloca to hold the thunk data, if needed.
+  Address ThunkData = Address::invalid();
+
   /// Return true if a label was seen in the current scope.
   bool hasLabelBeenSeenInCurrentScope() const {
     if (CurLexicalScope)
@@ -2256,6 +2259,11 @@
   /// pointer to a char.
   Address EmitMSVAListRef(const Expr *E);
 
+  /// Emit a "reference" to a __builtin_va_list32; this is
+  /// always the value of the expression, because a __builtin_va_list32 is a
+  /// pointer to a char.
+  Address EmitVAList32Ref(const Expr *E);
+
   /// EmitAnyExprToTemp - Similarly to EmitAnyExpr(), however, the result will
   /// always be accessible even if no aggregate location is provided.
   RValue EmitAnyExprToTemp(const Expr *E);
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CodeGenModule.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CodeGenModule.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CodeGenModule.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CodeGenModule.cpp	2019-05-19 11:21:50.975903000 +0000
@@ -1301,6 +1301,13 @@
       B.addAttribute(llvm::Attribute::MinSize);
   }
 
+  if (auto *A = D->getAttr<Ptr32ThunkPrefixAttr>())
+    B.addAttribute("thunk-prefix", A->getPrefix());
+  if (auto *A = D->getAttr<Ptr32CS32NameAttr>())
+    B.addAttribute("thunk-cs32-name", A->getName());
+  if (auto *A = D->getAttr<Ptr32CS64NameAttr>())
+    B.addAttribute("thunk-cs64-name", A->getName());
+
   F->addAttributes(llvm::AttributeList::FunctionIndex, B);
 
   unsigned alignment = D->getMaxAlignment() / Context.getCharWidth();
@@ -2430,8 +2437,9 @@
               const CGFunctionInfo &FI =
                   getTypes().arrangeGlobalDeclaration(GD);
               llvm::FunctionType *Ty = getTypes().GetFunctionType(FI);
-              Func = GetAddrOfFunction(CurGD, Ty, /*ForVTable=*/false,
-                                       /*DontDefer=*/false, ForDefinition);
+              Func = GetAddrOfFunction(CurGD, Ty, /*ForCall=*/false,
+                                       /*ForVTable=*/false, /*DontDefer=*/false,
+                                       ForDefinition);
             }
             assert(Func && "This should have just been created");
           }
@@ -2760,12 +2768,13 @@
 /// create it (this occurs when we see a definition of the function).
 llvm::Constant *CodeGenModule::GetAddrOfFunction(GlobalDecl GD,
                                                  llvm::Type *Ty,
+                                                 bool ForCall,
                                                  bool ForVTable,
                                                  bool DontDefer,
                                               ForDefinition_t IsForDefinition) {
+  const auto *FD = cast<FunctionDecl>(GD.getDecl());
   // If there was no specific requested type, just convert it now.
   if (!Ty) {
-    const auto *FD = cast<FunctionDecl>(GD.getDecl());
     auto CanonTy = Context.getCanonicalType(FD->getType());
     Ty = getTypes().ConvertFunctionType(CanonTy, FD);
   }
@@ -2780,7 +2789,21 @@
       GD = GlobalDecl(DD, Dtor_Base);
   }
 
-  StringRef MangledName = getMangledName(GD);
+  std::string MangledName = getMangledName(GD);
+  // If we're getting the address of a function with a 32-bit calling
+  // convention, return the address of the thunk instead.
+  // FIXME: We should only do this if we're downcasting the function pointer to
+  // a 32-bit pointer.
+  if (LangOpts.Interop6432 && !IsForDefinition && !ForCall) {
+    if (is32BitInteropCC(
+            FD->getType()->castAs<FunctionType>()->getCallConv())) {
+      if (auto *A = FD->getAttr<Ptr32ThunkPrefixAttr>())
+        MangledName = (A->getPrefix() + "thunk32_" + MangledName).str();
+      else
+        MangledName = (Twine("__i386_on_x86_64_thunk32_") + MangledName).str();
+    }
+  }
+
   return GetOrCreateLLVMFunction(MangledName, Ty, GD, ForVTable, DontDefer,
                                  /*IsThunk=*/false, llvm::AttributeList(),
                                  IsForDefinition);
@@ -3093,13 +3116,13 @@
     auto FInfo = &getTypes().arrangeCXXMethodDeclaration(
         cast<CXXMethodDecl>(D));
     auto Ty = getTypes().GetFunctionType(*FInfo);
-    return GetAddrOfFunction(GD, Ty, /*ForVTable=*/false, /*DontDefer=*/false,
-                             IsForDefinition);
+    return GetAddrOfFunction(GD, Ty, /*ForCall=*/false, /*ForVTable=*/false,
+                             /*DontDefer=*/false, IsForDefinition);
   } else if (isa<FunctionDecl>(D)) {
     const CGFunctionInfo &FI = getTypes().arrangeGlobalDeclaration(GD);
     llvm::FunctionType *Ty = getTypes().GetFunctionType(FI);
-    return GetAddrOfFunction(GD, Ty, /*ForVTable=*/false, /*DontDefer=*/false,
-                             IsForDefinition);
+    return GetAddrOfFunction(GD, Ty, /*ForCall=*/false, /*ForVTable=*/false,
+                             /*DontDefer=*/false, IsForDefinition);
   } else
     return GetAddrOfGlobalVar(cast<VarDecl>(D), /*Ty=*/nullptr,
                               IsForDefinition);
@@ -3841,7 +3864,8 @@
 
   // Get or create the prototype for the function.
   if (!GV || (GV->getType()->getElementType() != Ty))
-    GV = cast<llvm::GlobalValue>(GetAddrOfFunction(GD, Ty, /*ForVTable=*/false,
+    GV = cast<llvm::GlobalValue>(GetAddrOfFunction(GD, Ty, /*ForCall=*/false,
+                                                   /*ForVTable=*/false,
                                                    /*DontDefer=*/true,
                                                    ForDefinition));
 
@@ -4269,9 +4293,10 @@
 static llvm::GlobalVariable *
 GenerateStringLiteral(llvm::Constant *C, llvm::GlobalValue::LinkageTypes LT,
                       CodeGenModule &CGM, StringRef GlobalName,
-                      CharUnits Alignment) {
-  unsigned AddrSpace = CGM.getContext().getTargetAddressSpace(
-      CGM.getStringLiteralAddressSpace());
+                      CharUnits Alignment, LangAS AS) {
+  if (CGM.getStringLiteralAddressSpace() != LangAS::Default)
+    AS = CGM.getStringLiteralAddressSpace();
+  unsigned AddrSpace = CGM.getContext().getTargetAddressSpace(AS);
 
   llvm::Module &M = CGM.getModule();
   // Create a global variable for this string
@@ -4327,7 +4352,10 @@
     GlobalVariableName = Name;
   }
 
-  auto GV = GenerateStringLiteral(C, LT, *this, GlobalVariableName, Alignment);
+  auto GV = GenerateStringLiteral(
+      C, LT, *this, GlobalVariableName, Alignment,
+      Context.getAsConstantArrayType(
+          S->getType())->getElementType().getAddressSpace());
   if (Entry)
     *Entry = GV;
 
@@ -4352,7 +4380,7 @@
 /// the literal and a terminating '\0' character.
 /// The result has pointer to array type.
 ConstantAddress CodeGenModule::GetAddrOfConstantCString(
-    const std::string &Str, const char *GlobalName) {
+    const std::string &Str, const char *GlobalName, LangAS AS) {
   StringRef StrWithNull(Str.c_str(), Str.size() + 1);
   CharUnits Alignment =
     getContext().getAlignOfGlobalVarInChars(getContext().CharTy);
@@ -4376,7 +4404,7 @@
     GlobalName = ".str";
   // Create a global variable for this.
   auto GV = GenerateStringLiteral(C, llvm::GlobalValue::PrivateLinkage, *this,
-                                  GlobalName, Alignment);
+                                  GlobalName, Alignment, AS);
   if (Entry)
     *Entry = GV;
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CodeGenModule.h llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CodeGenModule.h
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/CodeGenModule.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/CodeGenModule.h	2019-05-19 11:21:50.975903000 +0000
@@ -803,6 +803,7 @@
   /// Return the address of the given function. If Ty is non-null, then this
   /// function will use the specified type if it has to create it.
   llvm::Constant *GetAddrOfFunction(GlobalDecl GD, llvm::Type *Ty = nullptr,
+                                    bool ForCall = false,
                                     bool ForVTable = false,
                                     bool DontDefer = false,
                                     ForDefinition_t IsForDefinition
@@ -897,9 +898,11 @@
   ///
   /// \param GlobalName If provided, the name to use for the global (if one is
   /// created).
+  /// \param AS If provided, the address space in which to place the string.
   ConstantAddress
   GetAddrOfConstantCString(const std::string &Str,
-                           const char *GlobalName = nullptr);
+                           const char *GlobalName = nullptr,
+                           LangAS AS = LangAS::Default);
 
   /// Returns a pointer to a constant global variable for the given file-scope
   /// compound literal expression.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/CodeGen/TargetInfo.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/TargetInfo.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/CodeGen/TargetInfo.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/CodeGen/TargetInfo.cpp	2019-05-19 11:21:50.975903000 +0000
@@ -95,6 +95,11 @@
   return Address::invalid();
 }
 
+Address ABIInfo::EmitVAArg32(CodeGenFunction &CGF, Address VAListAddr,
+                             QualType Ty) const {
+  return Address::invalid();
+}
+
 ABIInfo::~ABIInfo() {}
 
 /// Does the given lowering require more than the given number of
@@ -285,17 +290,22 @@
 ///   leaving one or more empty slots behind as padding.  If this
 ///   is false, the returned address might be less-aligned than
 ///   DirectAlign.
+/// \param ElemTy - The type to cast the pointer to. If not given,
+///   defaults to \c CGF.Int8PtrTy.
 static Address emitVoidPtrDirectVAArg(CodeGenFunction &CGF,
                                       Address VAListAddr,
                                       llvm::Type *DirectTy,
                                       CharUnits DirectSize,
                                       CharUnits DirectAlign,
                                       CharUnits SlotSize,
-                                      bool AllowHigherAlign) {
+                                      bool AllowHigherAlign,
+                                      llvm::Type *ElemTy = nullptr) {
   // Cast the element type to i8* if necessary.  Some platforms define
   // va_list as a struct containing an i8* instead of just an i8*.
-  if (VAListAddr.getElementType() != CGF.Int8PtrTy)
-    VAListAddr = CGF.Builder.CreateElementBitCast(VAListAddr, CGF.Int8PtrTy);
+  if (ElemTy == nullptr)
+    ElemTy = CGF.Int8PtrTy;
+  if (VAListAddr.getElementType() != ElemTy)
+    VAListAddr = CGF.Builder.CreateElementBitCast(VAListAddr, ElemTy);
 
   llvm::Value *Ptr = CGF.Builder.CreateLoad(VAListAddr, "argp.cur");
 
@@ -339,11 +349,14 @@
 ///   an argument type with an alignment greater than the slot size
 ///   will be emitted on a higher-alignment address, potentially
 ///   leaving one or more empty slots behind as padding.
+/// \param ElemTy - The type to cast the pointer to. If not given,
+///   defaults to \c CGF.Int8PtrTy.
 static Address emitVoidPtrVAArg(CodeGenFunction &CGF, Address VAListAddr,
                                 QualType ValueTy, bool IsIndirect,
                                 std::pair<CharUnits, CharUnits> ValueInfo,
                                 CharUnits SlotSizeAndAlign,
-                                bool AllowHigherAlign) {
+                                bool AllowHigherAlign,
+                                llvm::Type *ElemTy = nullptr) {
   // The size and alignment of the value that was passed directly.
   CharUnits DirectSize, DirectAlign;
   if (IsIndirect) {
@@ -362,7 +375,8 @@
   Address Addr = emitVoidPtrDirectVAArg(CGF, VAListAddr, DirectTy,
                                         DirectSize, DirectAlign,
                                         SlotSizeAndAlign,
-                                        AllowHigherAlign);
+                                        AllowHigherAlign,
+                                        ElemTy);
 
   if (IsIndirect) {
     Addr = Address(CGF.Builder.CreateLoad(Addr), ValueInfo.second);
@@ -910,6 +924,13 @@
     return llvm::Type::getX86_MMXTy(CGF.getLLVMContext());
   }
 
+  if (Constraint.endswith("m") && Ty->isPointerTy()) {
+    // If we have a 32-bit pointer, expand it to a 64-bit one.
+    if (Ty->getPointerAddressSpace() == 32) {
+      return Ty->getPointerElementType()->getPointerTo();
+    }
+  }
+
   // No operation needed
   return Ty;
 }
@@ -1007,9 +1028,6 @@
 
   ABIArgInfo getIndirectReturnResult(QualType Ty, CCState &State) const;
 
-  /// Return the alignment to use for the given type on the stack.
-  unsigned getTypeStackAlignInBytes(QualType Ty, unsigned Align) const;
-
   Class classify(QualType Ty) const;
   ABIArgInfo classifyReturnType(QualType RetTy, CCState &State) const;
   ABIArgInfo classifyArgumentType(QualType RetTy, CCState &State) const;
@@ -1036,6 +1054,9 @@
 
 public:
 
+  /// Return the alignment to use for the given type on the stack.
+  unsigned getTypeStackAlignInBytes(QualType Ty, unsigned Align) const;
+
   void computeInfo(CGFunctionInfo &FI) const override;
   Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
                     QualType Ty) const override;
@@ -1919,7 +1940,8 @@
 
 bool X86_32TargetCodeGenInfo::isStructReturnInRegABI(
     const llvm::Triple &Triple, const CodeGenOptions &Opts) {
-  assert(Triple.getArch() == llvm::Triple::x86);
+  assert(Triple.getArch() == llvm::Triple::x86 ||
+         Triple.getArch() == llvm::Triple::x86_64);
 
   switch (Opts.getStructReturnConvention()) {
   case CodeGenOptions::SRCK_Default:
@@ -1957,6 +1979,10 @@
       llvm::Function *Fn = cast<llvm::Function>(GV);
       Fn->setCallingConv(llvm::CallingConv::X86_INTR);
     }
+    if (FD->hasAttr<MSHookPrologueAttr>()) {
+      llvm::Function *Fn = cast<llvm::Function>(GV);
+      Fn->addFnAttr("patchable-function", "ms-hotpatch");
+    }
   }
 }
 
@@ -2089,6 +2115,15 @@
   void classify(QualType T, uint64_t OffsetBase, Class &Lo, Class &Hi,
                 bool isNamedArg) const;
 
+  ABIArgInfo classifyWin64(QualType Ty, unsigned &FreeSSERegs,
+                           bool IsReturnType, bool IsVectorCall,
+                           bool IsRegCall) const;
+  ABIArgInfo reclassifyHvaArgType(QualType Ty, unsigned &FreeSSERegs,
+                                      const ABIArgInfo &current) const;
+  void computeVectorCallArgs(CGFunctionInfo &FI, unsigned FreeSSERegs,
+                             bool IsVectorCall, bool IsRegCall) const;
+  void computeInfoWin64(CGFunctionInfo &FI) const;
+
   llvm::Type *GetByteVectorType(QualType Ty) const;
   llvm::Type *GetSSETypeAtOffset(llvm::Type *IRType,
                                  unsigned IROffset, QualType SourceTy,
@@ -2152,10 +2187,30 @@
   // 64-bit hardware.
   bool Has64BitPointers;
 
+  bool IsWin64;
+  bool IsMingw64;
+  bool IsWine32;
+
+  std::unique_ptr<X86_32ABIInfo> ABI32;
+
 public:
   X86_64ABIInfo(CodeGen::CodeGenTypes &CGT, X86AVXABILevel AVXLevel) :
       SwiftABIInfo(CGT), AVXLevel(AVXLevel),
-      Has64BitPointers(CGT.getDataLayout().getPointerSize(0) == 8) {
+      Has64BitPointers(CGT.getDataLayout().getPointerSize(0) == 8),
+      IsWin64(getTarget().getTriple().isOSWindows()),
+      IsMingw64(getTarget().getTriple().isWindowsGNUEnvironment()),
+      IsWine32(getTarget().getTriple().getEnvironment()==llvm::Triple::Wine32) {
+    if (IsWine32) {
+      const auto &Triple = getTarget().getTriple();
+      ABI32 = llvm::make_unique<X86_32ABIInfo>(
+          CGT, getTarget().getTriple().isOSDarwin(),
+          X86_32TargetCodeGenInfo::isStructReturnInRegABI(
+              Triple, CGT.getCodeGenOpts()),
+          Triple.isOSWindows() && Triple.isOSBinFormatCOFF() &&
+          !Triple.isOSCygMing(),
+          CGT.getCodeGenOpts().NumRegisterParameters,
+          CGT.getCodeGenOpts().FloatABI == "soft");
+    }
   }
 
   bool isPassedUsingAVXType(QualType type) const {
@@ -2177,32 +2232,13 @@
                     QualType Ty) const override;
   Address EmitMSVAArg(CodeGenFunction &CGF, Address VAListAddr,
                       QualType Ty) const override;
+  Address EmitVAArg32(CodeGenFunction &CGF, Address VAListAddr,
+                      QualType Ty) const override;
 
   bool has64BitPointers() const {
     return Has64BitPointers;
   }
 
-  bool shouldPassIndirectlyForSwift(ArrayRef<llvm::Type*> scalars,
-                                    bool asReturnValue) const override {
-    return occupiesMoreThan(CGT, scalars, /*total*/ 4);
-  }
-  bool isSwiftErrorInRegister() const override {
-    return true;
-  }
-};
-
-/// WinX86_64ABIInfo - The Windows X86_64 ABI information.
-class WinX86_64ABIInfo : public SwiftABIInfo {
-public:
-  WinX86_64ABIInfo(CodeGen::CodeGenTypes &CGT)
-      : SwiftABIInfo(CGT),
-        IsMingw64(getTarget().getTriple().isWindowsGNUEnvironment()) {}
-
-  void computeInfo(CGFunctionInfo &FI) const override;
-
-  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
-                    QualType Ty) const override;
-
   bool isHomogeneousAggregateBaseType(QualType Ty) const override {
     // FIXME: Assumes vectorcall is in use.
     return isX86VectorTypeForVectorCall(getContext(), Ty);
@@ -2223,15 +2259,7 @@
     return true;
   }
 
-private:
-  ABIArgInfo classify(QualType Ty, unsigned &FreeSSERegs, bool IsReturnType,
-                      bool IsVectorCall, bool IsRegCall) const;
-  ABIArgInfo reclassifyHvaArgType(QualType Ty, unsigned &FreeSSERegs,
-                                      const ABIArgInfo &current) const;
-  void computeVectorCallArgs(CGFunctionInfo &FI, unsigned FreeSSERegs,
-                             bool IsVectorCall, bool IsRegCall) const;
-
-    bool IsMingw64;
+  bool isWine32Target() const { return IsWine32; }
 };
 
 class X86_64TargetCodeGenInfo : public TargetCodeGenInfo {
@@ -2288,6 +2316,12 @@
     return TargetCodeGenInfo::isNoProtoCallVariadic(args, fnType);
   }
 
+  LangAS getASTAllocaAddressSpace() const override {
+    if (getABIInfo().isWine32Target())
+      return LangAS::ptr32;
+    return LangAS::Default;
+  }
+
   llvm::Constant *
   getUBSanFunctionSignature(CodeGen::CodeGenModule &CGM) const override {
     unsigned Sig = (0xeb << 0) | // jmp rel8
@@ -2310,6 +2344,10 @@
         llvm::Function *Fn = cast<llvm::Function>(GV);
         Fn->setCallingConv(llvm::CallingConv::X86_INTR);
       }
+      if (FD->hasAttr<MSHookPrologueAttr>()) {
+        llvm::Function *Fn = cast<llvm::Function>(GV);
+        Fn->addFnAttr("patchable-function", "ms-hotpatch");
+      }
     }
   }
 };
@@ -2391,7 +2429,7 @@
 public:
   WinX86_64TargetCodeGenInfo(CodeGen::CodeGenTypes &CGT,
                              X86AVXABILevel AVXLevel)
-      : TargetCodeGenInfo(new WinX86_64ABIInfo(CGT)) {}
+      : TargetCodeGenInfo(new X86_64ABIInfo(CGT, AVXLevel)) {}
 
   void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
                            CodeGen::CodeGenModule &CGM) const override;
@@ -3537,15 +3575,33 @@
   return classifyRegCallStructTypeImpl(Ty, NeededInt, NeededSSE);
 }
 
+static bool isWin64CC(CGFunctionInfo &FI, bool IsWin64Target) {
+  return FI.getCallingConvention() == llvm::CallingConv::X86_VectorCall ||
+    FI.getCallingConvention() == llvm::CallingConv::Win64 ||
+    (IsWin64Target &&
+     FI.getCallingConvention() != llvm::CallingConv::X86_64_SysV);
+}
+
+static bool is32BitInteropCC(CGFunctionInfo &FI, bool IsWine32Target) {
+  return FI.getCallingConvention() == llvm::CallingConv::X86_64_C32 ||
+    (IsWine32Target &&
+     (FI.getCallingConvention() == llvm::CallingConv::X86_StdCall ||
+      FI.getCallingConvention() == llvm::CallingConv::X86_FastCall ||
+      FI.getCallingConvention() == llvm::CallingConv::X86_ThisCall));
+}
+
 void X86_64ABIInfo::computeInfo(CGFunctionInfo &FI) const {
 
   const unsigned CallingConv = FI.getCallingConvention();
-  // It is possible to force Win64 calling convention on any x86_64 target by
-  // using __attribute__((ms_abi)). In such case to correctly emit Win64
-  // compatible code delegate this call to WinX86_64ABIInfo::computeInfo.
-  if (CallingConv == llvm::CallingConv::Win64) {
-    WinX86_64ABIInfo Win64ABIInfo(CGT);
-    Win64ABIInfo.computeInfo(FI);
+
+  if (isWin64CC(FI, IsWin64)) {
+    computeInfoWin64(FI);
+    return;
+  }
+
+  if (is32BitInteropCC(FI, IsWine32)) {
+    assert(ABI32 != nullptr && "Need 32-bit ABI Info!");
+    ABI32->computeInfo(FI);
     return;
   }
 
@@ -3655,6 +3711,9 @@
 
 Address X86_64ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
                                  QualType Ty) const {
+  if (IsWin64)
+    return EmitMSVAArg(CGF, VAListAddr, Ty);
+
   // Assume that va_list type is correct; should be pointer to LLVM type:
   // struct {
   //   i32 gp_offset;
@@ -3851,14 +3910,40 @@
 
 Address X86_64ABIInfo::EmitMSVAArg(CodeGenFunction &CGF, Address VAListAddr,
                                    QualType Ty) const {
-  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, /*indirect*/ false,
+
+  // MS x64 ABI requirement: "Any argument that doesn't fit in 8 bytes, or is
+  // not 1, 2, 4, or 8 bytes, must be passed by reference."
+  uint64_t Width = getContext().getTypeSize(Ty);
+  bool IsIndirect = Width > 64 || !llvm::isPowerOf2_64(Width);
+
+  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, IsIndirect,
                           CGF.getContext().getTypeInfoInChars(Ty),
                           CharUnits::fromQuantity(8),
                           /*allowHigherAlign*/ false);
 }
 
+Address X86_64ABIInfo::EmitVAArg32(CodeGenFunction &CGF, Address VAListAddr,
+                                   QualType Ty) const {
+  if (!IsWine32)
+    return Address::invalid();
+
+  auto TypeInfo = getContext().getTypeInfoInChars(Ty);
+
+  // x86-32 changes the alignment of certain arguments on the stack.
+  //
+  // Just messing with TypeInfo like this works because we never pass
+  // anything indirectly.
+  TypeInfo.second = CharUnits::fromQuantity(
+      ABI32->getTypeStackAlignInBytes(Ty, TypeInfo.second.getQuantity()));
+
+  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, /*Indirect*/ false,
+                          TypeInfo, CharUnits::fromQuantity(4),
+                          /*AllowHigherAlign*/ true,
+                          llvm::PointerType::get(CGF.Int8Ty, 32));
+}
+
 ABIArgInfo
-WinX86_64ABIInfo::reclassifyHvaArgType(QualType Ty, unsigned &FreeSSERegs,
+X86_64ABIInfo::reclassifyHvaArgType(QualType Ty, unsigned &FreeSSERegs,
                                     const ABIArgInfo &current) const {
   // Assumes vectorCall calling convention.
   const Type *Base = nullptr;
@@ -3872,9 +3957,9 @@
   return current;
 }
 
-ABIArgInfo WinX86_64ABIInfo::classify(QualType Ty, unsigned &FreeSSERegs,
-                                      bool IsReturnType, bool IsVectorCall,
-                                      bool IsRegCall) const {
+ABIArgInfo X86_64ABIInfo::classifyWin64(QualType Ty, unsigned &FreeSSERegs,
+                                        bool IsReturnType, bool IsVectorCall,
+                                        bool IsRegCall) const {
 
   if (Ty->isVoidType())
     return ABIArgInfo::getIgnore();
@@ -3934,13 +4019,13 @@
       return ABIArgInfo::getDirect();
   }
 
-  if (RT || Ty->isAnyComplexType() || Ty->isMemberPointerType()) {
-    // MS x64 ABI requirement: "Any argument that doesn't fit in 8 bytes, or is
-    // not 1, 2, 4, or 8 bytes, must be passed by reference."
-    if (Width > 64 || !llvm::isPowerOf2_64(Width))
-      return getNaturalAlignIndirect(Ty, /*ByVal=*/false);
+  // MS x64 ABI requirement: "Any argument that doesn't fit in 8 bytes, or is
+  // not 1, 2, 4, or 8 bytes, must be passed by reference."
+  if (Width > 64 || !llvm::isPowerOf2_64(Width))
+    return getNaturalAlignIndirect(Ty, /*ByVal=*/false);
 
-    // Otherwise, coerce it to a small integer.
+  if (RT || Ty->isAnyComplexType() || Ty->isMemberPointerType()) {
+    // At this point we know it fits in a GPR; coerce it to a small integer.
     return ABIArgInfo::getDirect(llvm::IntegerType::get(getVMContext(), Width));
   }
 
@@ -3961,22 +4046,23 @@
   return ABIArgInfo::getDirect();
 }
 
-void WinX86_64ABIInfo::computeVectorCallArgs(CGFunctionInfo &FI,
-                                             unsigned FreeSSERegs,
-                                             bool IsVectorCall,
-                                             bool IsRegCall) const {
+void X86_64ABIInfo::computeVectorCallArgs(CGFunctionInfo &FI,
+                                          unsigned FreeSSERegs,
+                                          bool IsVectorCall,
+                                          bool IsRegCall) const {
   unsigned Count = 0;
   for (auto &I : FI.arguments()) {
     // Vectorcall in x64 only permits the first 6 arguments to be passed
     // as XMM/YMM registers.
     if (Count < VectorcallMaxParamNumAsReg)
-      I.info = classify(I.type, FreeSSERegs, false, IsVectorCall, IsRegCall);
+      I.info = classifyWin64(I.type, FreeSSERegs, false, IsVectorCall,
+                             IsRegCall);
     else {
       // Since these cannot be passed in registers, pretend no registers
       // are left.
       unsigned ZeroSSERegsAvail = 0;
-      I.info = classify(I.type, /*FreeSSERegs=*/ZeroSSERegsAvail, false,
-                        IsVectorCall, IsRegCall);
+      I.info = classifyWin64(I.type, /*FreeSSERegs=*/ZeroSSERegsAvail, false,
+                             IsVectorCall, IsRegCall);
     }
     ++Count;
   }
@@ -3986,7 +4072,7 @@
   }
 }
 
-void WinX86_64ABIInfo::computeInfo(CGFunctionInfo &FI) const {
+void X86_64ABIInfo::computeInfoWin64(CGFunctionInfo &FI) const {
   bool IsVectorCall =
       FI.getCallingConvention() == llvm::CallingConv::X86_VectorCall;
   bool IsRegCall = FI.getCallingConvention() == llvm::CallingConv::X86_RegCall;
@@ -4001,8 +4087,8 @@
   }
 
   if (!getCXXABI().classifyReturnType(FI))
-    FI.getReturnInfo() = classify(FI.getReturnType(), FreeSSERegs, true,
-                                  IsVectorCall, IsRegCall);
+    FI.getReturnInfo() = classifyWin64(FI.getReturnType(), FreeSSERegs, true,
+                                       IsVectorCall, IsRegCall);
 
   if (IsVectorCall) {
     // We can use up to 6 SSE register parameters with vectorcall.
@@ -4016,29 +4102,12 @@
     computeVectorCallArgs(FI, FreeSSERegs, IsVectorCall, IsRegCall);
   } else {
     for (auto &I : FI.arguments())
-      I.info = classify(I.type, FreeSSERegs, false, IsVectorCall, IsRegCall);
+      I.info = classifyWin64(I.type, FreeSSERegs, false, IsVectorCall,
+                             IsRegCall);
   }
 
 }
 
-Address WinX86_64ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
-                                    QualType Ty) const {
-
-  bool IsIndirect = false;
-
-  // MS x64 ABI requirement: "Any argument that doesn't fit in 8 bytes, or is
-  // not 1, 2, 4, or 8 bytes, must be passed by reference."
-  if (isAggregateTypeForABI(Ty) || Ty->isMemberPointerType()) {
-    uint64_t Width = getContext().getTypeSize(Ty);
-    IsIndirect = Width > 64 || !llvm::isPowerOf2_64(Width);
-  }
-
-  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, IsIndirect,
-                          CGF.getContext().getTypeInfoInChars(Ty),
-                          CharUnits::fromQuantity(8),
-                          /*allowHigherAlign*/ false);
-}
-
 // PowerPC-32
 namespace {
 /// PPC32_SVR4_ABIInfo - The 32-bit PowerPC ELF (SVR4) ABI information.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Driver/Driver.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Driver/Driver.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Driver/Driver.cpp	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Driver/Driver.cpp	2019-05-19 11:21:50.975903000 +0000
@@ -413,6 +413,9 @@
     // If an explicit Darwin arch name is given, that trumps all.
     if (!DarwinArchName.empty()) {
       tools::darwin::setTripleTypeForMachOArchName(Target, DarwinArchName);
+      if (Args.hasArg(options::OPT_mwine32) &&
+          Target.getArch() == llvm::Triple::x86_64)
+        Target.setEnvironment(llvm::Triple::Wine32);
       return Target;
     }
 
@@ -443,9 +446,10 @@
       Target.getOS() == llvm::Triple::Minix)
     return Target;
 
-  // Handle pseudo-target flags '-m64', '-mx32', '-m32' and '-m16'.
-  Arg *A = Args.getLastArg(options::OPT_m64, options::OPT_mx32,
-                           options::OPT_m32, options::OPT_m16);
+  // Handle pseudo-target flags '-m64', '-mwine32', '-mx32', '-m32' and '-m16'.
+  Arg *A = Args.getLastArg(options::OPT_m64, options::OPT_mwine32,
+                           options::OPT_mx32, options::OPT_m32,
+                           options::OPT_m16);
   if (A) {
     llvm::Triple::ArchType AT = llvm::Triple::UnknownArch;
 
@@ -453,6 +457,10 @@
       AT = Target.get64BitArchVariant().getArch();
       if (Target.getEnvironment() == llvm::Triple::GNUX32)
         Target.setEnvironment(llvm::Triple::GNU);
+    } else if (A->getOption().matches(options::OPT_mwine32) &&
+               Target.get64BitArchVariant().getArch() == llvm::Triple::x86_64) {
+      AT = llvm::Triple::x86_64;
+      Target.setEnvironment(llvm::Triple::Wine32);
     } else if (A->getOption().matches(options::OPT_mx32) &&
                Target.get64BitArchVariant().getArch() == llvm::Triple::x86_64) {
       AT = llvm::Triple::x86_64;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Driver/ToolChains/Clang.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Driver/ToolChains/Clang.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Driver/ToolChains/Clang.cpp	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Driver/ToolChains/Clang.cpp	2019-05-19 11:21:50.975903000 +0000
@@ -3610,6 +3610,41 @@
     CmdArgs.push_back(Args.MakeArgString(CPU));
   }
 
+  Args.AddLastArg(CmdArgs, options::OPT_mdefault_address_space_EQ);
+  Args.AddLastArg(CmdArgs, options::OPT_mstorage_address_space_EQ);
+  // On Wine32, default to the __ptr32 address space for data.
+  if (!Args.hasArg(options::OPT_mstorage_address_space_EQ) &&
+      Triple.getEnvironment() == llvm::Triple::Wine32)
+    CmdArgs.push_back("-mstorage-address-space=ptr32");
+
+  Args.AddLastArg(CmdArgs, options::OPT_msystem_address_space_EQ);
+
+  // Set parameters for 64/32-bit interop.
+  if (Arg *A = Args.getLastArg(options::OPT_minterop64_32_thunk_prefix_EQ)) {
+    if (Triple.getEnvironment() != llvm::Triple::Wine32) {
+      D.Diag(clang::diag::err_drv_argument_only_allowed_with)
+          << A->getBaseArg().getAsString(Args)
+          << "-mwine32";
+    }
+    Args.AddLastArg(CmdArgs, options::OPT_minterop64_32_thunk_prefix_EQ);
+  }
+  if (Arg *A = Args.getLastArg(options::OPT_minterop64_32_cs32_name_EQ)) {
+    if (Triple.getEnvironment() != llvm::Triple::Wine32) {
+      D.Diag(clang::diag::err_drv_argument_only_allowed_with)
+          << A->getBaseArg().getAsString(Args)
+          << "-mwine32";
+    }
+    Args.AddLastArg(CmdArgs, options::OPT_minterop64_32_cs32_name_EQ);
+  }
+  if (Arg *A = Args.getLastArg(options::OPT_minterop64_32_cs64_name_EQ)) {
+    if (Triple.getEnvironment() != llvm::Triple::Wine32) {
+      D.Diag(clang::diag::err_drv_argument_only_allowed_with)
+          << A->getBaseArg().getAsString(Args)
+          << "-mwine32";
+    }
+    Args.AddLastArg(CmdArgs, options::OPT_minterop64_32_cs64_name_EQ);
+  }
+
   RenderTargetOptions(Triple, Args, KernelOrKext, CmdArgs);
 
   // These two are potentially updated by AddClangCLArgs.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Frontend/CompilerInvocation.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Frontend/CompilerInvocation.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Frontend/CompilerInvocation.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Frontend/CompilerInvocation.cpp	2019-05-19 11:21:50.975903000 +0000
@@ -2784,6 +2784,10 @@
 
   Opts.CompleteMemberPointers = Args.hasArg(OPT_fcomplete_member_pointers);
   Opts.BuildingPCHWithObjectFile = Args.hasArg(OPT_building_pch_with_obj);
+
+  Opts.Interop6432 = Args.hasFlag(
+      OPT_m64_32_interop, OPT_mno_64_32_interop,
+      T.getEnvironment() == llvm::Triple::Wine32);
 }
 
 static bool isStrictlyPreprocessorAction(frontend::ActionKind Action) {
@@ -2971,6 +2975,46 @@
   Opts.ForceEnableInt128 = Args.hasArg(OPT_fforce_enable_int128);
   Opts.NVPTXUseShortPointers = Args.hasFlag(
       options::OPT_fcuda_short_ptr, options::OPT_fno_cuda_short_ptr, false);
+  if (Arg *A = Args.getLastArg(OPT_mdefault_address_space_EQ)) {
+    StringRef Value = A->getValue();
+    auto AS = llvm::StringSwitch<LangAS>(Value)
+                                 .Case("default", LangAS::Default)
+                                 .Case("ptr32", LangAS::ptr32)
+                                 .Default(LangAS(-1));
+    if (AS == LangAS(-1))
+      Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args)
+                                                << Value;
+    else
+      Opts.DefaultAddrSpace = AS;
+  }
+  if (Arg *A = Args.getLastArg(OPT_mstorage_address_space_EQ)) {
+    StringRef Value = A->getValue();
+    auto AS = llvm::StringSwitch<LangAS>(Value)
+                                 .Case("default", LangAS::Default)
+                                 .Case("ptr32", LangAS::ptr32)
+                                 .Default(LangAS(-1));
+    if (AS == LangAS(-1))
+      Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args)
+                                                << Value;
+    else
+      Opts.StorageAddrSpace = AS;
+  }
+  if (Arg *A = Args.getLastArg(OPT_msystem_address_space_EQ)) {
+    StringRef Value = A->getValue();
+    auto AS = llvm::StringSwitch<LangAS>(Value)
+                                 .Case("default", LangAS::Default)
+                                 .Case("ptr32", LangAS::ptr32)
+                                 .Default(LangAS(-1));
+    if (AS == LangAS(-1))
+      Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args)
+                                                << Value;
+    else
+      Opts.SystemAddrSpace = AS;
+  }
+  Opts.Ptr32ThunkPrefix =
+      Args.getLastArgValue(OPT_minterop64_32_thunk_prefix_EQ);
+  Opts.Ptr32CS32Name = Args.getLastArgValue(OPT_minterop64_32_cs32_name_EQ);
+  Opts.Ptr32CS64Name = Args.getLastArgValue(OPT_minterop64_32_cs64_name_EQ);
 }
 
 bool CompilerInvocation::CreateFromArgs(CompilerInvocation &Res,
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Parse/ParsePragma.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Parse/ParsePragma.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Parse/ParsePragma.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Parse/ParsePragma.cpp	2019-05-19 11:21:50.975903000 +0000
@@ -247,6 +247,17 @@
   ParsedAttributes AttributesForPragmaAttribute;
 };
 
+/// "\#pragma clang default_addr_space(...)"
+struct PragmaDefaultASHandler : public PragmaHandler {
+  PragmaDefaultASHandler(bool Storage)
+      : PragmaHandler(Storage ? "storage_addr_space" : "default_addr_space"),
+        ForStorage(Storage) {}
+  void HandlePragma(Preprocessor &PP, PragmaIntroducerKind Introducer,
+                    Token &FirstToken) override;
+
+  bool ForStorage;
+};
+
 }  // end namespace
 
 void Parser::initializePragmaHandlers() {
@@ -357,6 +368,21 @@
 
   AttributePragmaHandler.reset(new PragmaAttributeHandler(AttrFactory));
   PP.AddPragmaHandler("clang", AttributePragmaHandler.get());
+
+  DefaultASHandler.reset(new PragmaDefaultASHandler(false));
+  PP.AddPragmaHandler("clang", DefaultASHandler.get());
+
+  StorageASHandler.reset(new PragmaDefaultASHandler(true));
+  PP.AddPragmaHandler("clang", StorageASHandler.get());
+
+  if (getLangOpts().Interop6432) {
+    Ptr32ThunkPrefixHandler.reset(new PragmaMSPragma("ptr32_thunk_prefix"));
+    PP.AddPragmaHandler("clang", Ptr32ThunkPrefixHandler.get());
+    Ptr32CS32NameHandler.reset(new PragmaMSPragma("ptr32_cs32_name"));
+    PP.AddPragmaHandler("clang", Ptr32CS32NameHandler.get());
+    Ptr32CS64NameHandler.reset(new PragmaMSPragma("ptr32_cs64_name"));
+    PP.AddPragmaHandler("clang", Ptr32CS64NameHandler.get());
+  }
 }
 
 void Parser::resetPragmaHandlers() {
@@ -456,6 +482,21 @@
 
   PP.RemovePragmaHandler("clang", AttributePragmaHandler.get());
   AttributePragmaHandler.reset();
+
+  PP.RemovePragmaHandler("clang", DefaultASHandler.get());
+  DefaultASHandler.reset();
+
+  PP.RemovePragmaHandler("clang", StorageASHandler.get());
+  StorageASHandler.reset();
+
+  if (getLangOpts().Interop6432) {
+    PP.RemovePragmaHandler("clang", Ptr32ThunkPrefixHandler.get());
+    Ptr32ThunkPrefixHandler.reset();
+    PP.RemovePragmaHandler("clang", Ptr32CS32NameHandler.get());
+    Ptr32CS32NameHandler.reset();
+    PP.RemovePragmaHandler("clang", Ptr32CS64NameHandler.get());
+    Ptr32CS64NameHandler.reset();
+  }
 }
 
 /// Handle the annotation token produced for #pragma unused(...)
@@ -705,7 +746,10 @@
     .Case("const_seg", &Parser::HandlePragmaMSSegment)
     .Case("code_seg", &Parser::HandlePragmaMSSegment)
     .Case("section", &Parser::HandlePragmaMSSection)
-    .Case("init_seg", &Parser::HandlePragmaMSInitSeg);
+    .Case("init_seg", &Parser::HandlePragmaMSInitSeg)
+    .Case("ptr32_thunk_prefix", &Parser::HandlePragmaPtr32ThunkPrefix)
+    .Case("ptr32_cs32_name", &Parser::HandlePragmaPtr32CS32Name)
+    .Case("ptr32_cs64_name", &Parser::HandlePragmaPtr32CS64Name);
 
   if (!(this->*Handler)(PragmaName, PragmaLocation)) {
     // Pragma handling failed, and has been diagnosed.  Slurp up the tokens
@@ -1489,6 +1533,122 @@
                                    std::move(SubjectMatchRules));
 }
 
+void Parser::HandlePragmaDefaultAS() {
+  assert(Tok.is(tok::annot_pragma_default_as) &&
+         "Expected #pragma clang default_addr_space token");
+  uintptr_t Value = reinterpret_cast<uintptr_t>(Tok.getAnnotationValue());
+  auto Action = static_cast<Sema::PragmaMsStackAction>((Value >> 24) & 0xFF);
+  auto AS = static_cast<LangAS>(Value & 0xFFFFFF);
+  SourceLocation PragmaLoc = ConsumeAnnotationToken();
+  Actions.ActOnPragmaDefaultAS(PragmaLoc, Action, AS);
+}
+
+void Parser::HandlePragmaStorageAS() {
+  assert(Tok.is(tok::annot_pragma_storage_as) &&
+         "Expected #pragma clang storage_addr_space token");
+  uintptr_t Value = reinterpret_cast<uintptr_t>(Tok.getAnnotationValue());
+  auto Action = static_cast<Sema::PragmaMsStackAction>((Value >> 24) & 0xFF);
+  auto AS = static_cast<LangAS>(Value & 0xFFFFFF);
+  SourceLocation PragmaLoc = ConsumeAnnotationToken();
+  Actions.ActOnPragmaStorageAS(PragmaLoc, Action, AS);
+}
+
+bool Parser::HandlePragmaPtr32ThunkPrefix(StringRef PragmaName,
+                                          SourceLocation PragmaLocation) {
+  if (ExpectAndConsume(tok::l_paren, diag::warn_pragma_expected_lparen,
+                       PragmaName))
+    return false;
+
+  StringLiteral *Prefix = nullptr;
+  if (!Tok.is(tok::string_literal)) {
+    PP.Diag(PragmaLocation, diag::warn_pragma_expected_string) << PragmaName;
+    return false;
+  }
+
+  ExprResult StringResult = ParseStringLiteralExpression();
+  if (StringResult.isInvalid())
+    return false;
+  Prefix = cast<StringLiteral>(StringResult.get());
+  if (Prefix->getCharByteWidth() != 1) {
+    PP.Diag(PragmaLocation, diag::warn_pragma_expected_non_wide_string)
+        << PragmaName;
+    return false;
+  }
+
+  if (ExpectAndConsume(tok::r_paren, diag::warn_pragma_expected_rparen,
+                       PragmaName) ||
+      ExpectAndConsume(tok::eof, diag::warn_pragma_extra_tokens_at_eol,
+                       PragmaName))
+    return false;
+
+  Actions.ActOnPragmaPtr32ThunkPrefix(PragmaLocation, Prefix);
+  return true;
+}
+
+bool Parser::HandlePragmaPtr32CS32Name(StringRef PragmaName,
+                                       SourceLocation PragmaLocation) {
+  if (ExpectAndConsume(tok::l_paren, diag::warn_pragma_expected_lparen,
+                       PragmaName))
+    return false;
+
+  StringLiteral *SymName = nullptr;
+  if (!Tok.is(tok::string_literal)) {
+    PP.Diag(PragmaLocation, diag::warn_pragma_expected_string) << PragmaName;
+    return false;
+  }
+
+  ExprResult StringResult = ParseStringLiteralExpression();
+  if (StringResult.isInvalid())
+    return false;
+  SymName = cast<StringLiteral>(StringResult.get());
+  if (SymName->getCharByteWidth() != 1) {
+    PP.Diag(PragmaLocation, diag::warn_pragma_expected_non_wide_string)
+        << PragmaName;
+    return false;
+  }
+
+  if (ExpectAndConsume(tok::r_paren, diag::warn_pragma_expected_rparen,
+                       PragmaName) ||
+      ExpectAndConsume(tok::eof, diag::warn_pragma_extra_tokens_at_eol,
+                       PragmaName))
+    return false;
+
+  Actions.ActOnPragmaPtr32CS32Name(PragmaLocation, SymName);
+  return true;
+}
+
+bool Parser::HandlePragmaPtr32CS64Name(StringRef PragmaName,
+                                       SourceLocation PragmaLocation) {
+  if (ExpectAndConsume(tok::l_paren, diag::warn_pragma_expected_lparen,
+                       PragmaName))
+    return false;
+
+  StringLiteral *SymName = nullptr;
+  if (!Tok.is(tok::string_literal)) {
+    PP.Diag(PragmaLocation, diag::warn_pragma_expected_string) << PragmaName;
+    return false;
+  }
+
+  ExprResult StringResult = ParseStringLiteralExpression();
+  if (StringResult.isInvalid())
+    return false;
+  SymName = cast<StringLiteral>(StringResult.get());
+  if (SymName->getCharByteWidth() != 1) {
+    PP.Diag(PragmaLocation, diag::warn_pragma_expected_non_wide_string)
+        << PragmaName;
+    return false;
+  }
+
+  if (ExpectAndConsume(tok::r_paren, diag::warn_pragma_expected_rparen,
+                       PragmaName) ||
+      ExpectAndConsume(tok::eof, diag::warn_pragma_extra_tokens_at_eol,
+                       PragmaName))
+    return false;
+
+  Actions.ActOnPragmaPtr32CS64Name(PragmaLocation, SymName);
+  return true;
+}
+
 // #pragma GCC visibility comes in two variants:
 //   'push' '(' [visibility] ')'
 //   'pop'
@@ -3137,3 +3297,107 @@
   PP.EnterTokenStream(std::move(TokenArray), 1,
                       /*DisableMacroExpansion=*/false);
 }
+
+void PragmaDefaultASHandler::HandlePragma(Preprocessor &PP,
+                                          PragmaIntroducerKind Introducer,
+                                          Token &Tok) {
+  SourceLocation PragmaLoc = Tok.getLocation();
+
+  PP.Lex(Tok);
+
+  if (Tok.isNot(tok::l_paren)) {
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_lparen)
+        << ("clang " + getName()).str();
+    return;
+  }
+  PP.Lex(Tok);
+
+  Sema::PragmaMsStackAction Action = Sema::PSK_Set;
+  const IdentifierInfo *II = Tok.getIdentifierInfo();
+  if (II) {
+    if (II->isStr("push")) {
+      // #pragma clang default_addr_space(push, as)
+      PP.Lex(Tok);
+      if (Tok.isNot(tok::comma)) {
+        PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_punc)
+            << ("clang " + getName()).str();
+        return;
+      }
+      PP.Lex(Tok);
+      Action = Sema::PSK_Push_Set;
+    } else if (II->isStr("pop")) {
+      // #pragma clang default_addr_space(pop)
+      PP.Lex(Tok);
+      Action = Sema::PSK_Pop;
+    }
+  } else if (Tok.is(tok::r_paren)) {
+    // #pragma clang default_addr_space()
+    Action = Sema::PSK_Reset;
+  }
+
+  LangAS AS = LangAS::Default;
+  if (Action & Sema::PSK_Push || Action & Sema::PSK_Set) {
+    uint64_t Value;
+    if (Tok.is(tok::kw_default)) {
+      AS = LangAS::Default;
+      PP.Lex(Tok);
+    } else if (Tok.is(tok::identifier)) {
+      if (PP.getLangOpts().Interop6432) {
+#define CASE(AS) Case(#AS, LangAS::AS)
+        AS = llvm::StringSwitch<LangAS>(Tok.getIdentifierInfo()->getName())
+          .CASE(ptr32)
+          .Default(LangAS::Default);
+#undef CASE
+      } else
+        AS = LangAS::Default;
+      if (AS == LangAS::Default) {
+        PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_addr_space)
+            << SourceRange(Tok.getLocation(), Tok.getEndLoc()) << getName();
+        return;
+      }
+      PP.Lex(Tok);
+    } else if (Tok.is(tok::numeric_constant) &&
+               PP.parseSimpleIntegerLiteral(Tok, Value)) {
+      static const constexpr uint32_t MaxAS =
+          Qualifiers::MaxAddressSpace -
+          static_cast<int>(LangAS::FirstTargetAddressSpace);
+      if (Value > MaxAS) {
+        PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_integer)
+            << 0 << MaxAS << ("clang " + getName()).str();
+        return;
+      }
+      AS = getLangASFromTargetAS(static_cast<uint32_t>(Value));
+    } else {
+      PP.Diag(Tok.getLocation(),
+              diag::warn_pragma_expected_identifier_or_integer)
+          << ("clang " + getName()).str();
+      return;
+    }
+  }
+
+  if (Tok.isNot(tok::r_paren)) {
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_rparen)
+        << ("clang " + getName()).str();
+    return;
+  }
+  SourceLocation EndLoc = Tok.getLocation();
+  PP.Lex(Tok);
+
+  if (Tok.isNot(tok::eod)) {
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_extra_tokens_at_eol)
+        << ("clang " + getName()).str();
+    return;
+  }
+
+  // Generate the annotated pragma token.
+  Token AnnotTok;
+  AnnotTok.startToken();
+  AnnotTok.setKind(ForStorage ? tok::annot_pragma_storage_as
+                              : tok::annot_pragma_default_as);
+  AnnotTok.setLocation(PragmaLoc);
+  AnnotTok.setAnnotationEndLoc(EndLoc);
+  AnnotTok.setAnnotationValue(
+      reinterpret_cast<void *>((static_cast<uintptr_t>(AS) & 0xFFFFFF) |
+                               (static_cast<uintptr_t>(Action) << 24)));
+  PP.EnterToken(AnnotTok);
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Parse/ParseStmt.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Parse/ParseStmt.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Parse/ParseStmt.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Parse/ParseStmt.cpp	2019-05-19 11:21:50.975903000 +0000
@@ -387,6 +387,14 @@
   case tok::annot_pragma_attribute:
     HandlePragmaAttribute();
     return StmtEmpty();
+
+  case tok::annot_pragma_default_as:
+    HandlePragmaDefaultAS();
+    return StmtEmpty();
+
+  case tok::annot_pragma_storage_as:
+    HandlePragmaStorageAS();
+    return StmtEmpty();
   }
 
   // If we reached this code, the statement must end in a semicolon.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Parse/Parser.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Parse/Parser.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Parse/Parser.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Parse/Parser.cpp	2019-05-19 11:21:50.985903000 +0000
@@ -588,6 +588,14 @@
     HandlePragmaAttribute();
     return false;
 
+  case tok::annot_pragma_default_as:
+    HandlePragmaDefaultAS();
+    return false;
+
+  case tok::annot_pragma_storage_as:
+    HandlePragmaStorageAS();
+    return false;
+
   case tok::eof:
     // Late template parsing can begin.
     if (getLangOpts().DelayedTemplateParsing)
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/Sema.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/Sema.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/Sema.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/Sema.cpp	2019-05-19 11:21:50.985903000 +0000
@@ -77,6 +77,7 @@
 class SemaPPCallbacks : public PPCallbacks {
   Sema *S = nullptr;
   llvm::SmallVector<SourceLocation, 8> IncludeStack;
+  unsigned SysCount = 0;  // Number of times we entered a system context.
 
 public:
   void set(Sema &S) { this->S = &S; }
@@ -97,13 +98,71 @@
         S->DiagnoseNonDefaultPragmaPack(
             Sema::PragmaPackDiagnoseKind::NonDefaultStateAtInclude, IncludeLoc);
       }
-      break;
     }
+      LLVM_FALLTHROUGH;
+    case RenameFile:
+      if (S->LangOpts.Interop6432 && SrcMgr::isSystem(FileType)) {
+        // When a system context is entered, it's as though this:
+        //   #pragma clang default_addr_space(push, default)
+        //   #pragma clang storage_addr_space(push, default)
+        // were executed. Instead of pushing multiple times onto the stack,
+        // though, we just keep track of the number of times we entered a
+        // system file, and don't pop until we leave the last one.
+        if (SysCount++ == 0) {
+          // Simply manipulating the stack directly causes ordering problems
+          // when including a file just after executing a real
+          // default_addr_space pragma. Instead, add an annotation token as the
+          // pragma does. Then the pushes will happen in the correct order.
+          Token AnnotTok;
+          AnnotTok.startToken();
+          AnnotTok.setKind(tok::annot_pragma_default_as);
+          AnnotTok.setLocation(Loc);
+          AnnotTok.setAnnotationEndLoc(Loc);
+          AnnotTok.setAnnotationValue(reinterpret_cast<void *>(
+              static_cast<uintptr_t>(
+                  S->Context.getTargetInfo().getTargetOpts().SystemAddrSpace) |
+              static_cast<uintptr_t>(Sema::PSK_Push_Set) << 24));
+          S->getPreprocessor().EnterToken(AnnotTok);
+          AnnotTok.startToken();
+          AnnotTok.setKind(tok::annot_pragma_storage_as);
+          AnnotTok.setLocation(Loc);
+          AnnotTok.setAnnotationEndLoc(Loc);
+          AnnotTok.setAnnotationValue(reinterpret_cast<void *>(
+              static_cast<uintptr_t>(
+                  S->Context.getTargetInfo().getTargetOpts().SystemAddrSpace) |
+              static_cast<uintptr_t>(Sema::PSK_Push_Set) << 24));
+          S->getPreprocessor().EnterToken(AnnotTok);
+        }
+      }
+      break;
     case ExitFile:
       if (!IncludeStack.empty())
         S->DiagnoseNonDefaultPragmaPack(
             Sema::PragmaPackDiagnoseKind::ChangedStateAtExit,
             IncludeStack.pop_back_val());
+      if (S->LangOpts.Interop6432 && SysCount > 0) {
+        // Conversely, when it is left, it is as though:
+        //   #pragma clang storage_addr_space(pop)
+        //   #pragma clang default_addr_space(pop)
+        // were executed.
+        if (--SysCount == 0) {
+          Token AnnotTok;
+          AnnotTok.startToken();
+          AnnotTok.setKind(tok::annot_pragma_storage_as);
+          AnnotTok.setLocation(Loc);
+          AnnotTok.setAnnotationEndLoc(Loc);
+          AnnotTok.setAnnotationValue(reinterpret_cast<void *>(
+              static_cast<uintptr_t>(Sema::PSK_Pop) << 24));
+          S->getPreprocessor().EnterToken(AnnotTok);
+          AnnotTok.startToken();
+          AnnotTok.setKind(tok::annot_pragma_default_as);
+          AnnotTok.setLocation(Loc);
+          AnnotTok.setAnnotationEndLoc(Loc);
+          AnnotTok.setAnnotationValue(reinterpret_cast<void *>(
+              static_cast<uintptr_t>(Sema::PSK_Pop) << 24));
+          S->getPreprocessor().EnterToken(AnnotTok);
+        }
+      }
       break;
     default:
       break;
@@ -126,7 +185,12 @@
           LangOpts.getMSPointerToMemberRepresentationMethod()),
       VtorDispStack(MSVtorDispAttr::Mode(LangOpts.VtorDispMode)), PackStack(0),
       DataSegStack(nullptr), BSSSegStack(nullptr), ConstSegStack(nullptr),
-      CodeSegStack(nullptr), CurInitSeg(nullptr), VisContext(nullptr),
+      CodeSegStack(nullptr),
+      AddrSpaceStack(Context.getTargetInfo().getTargetOpts().DefaultAddrSpace),
+      StgAddrSpaceStack(
+          Context.getTargetInfo().getTargetOpts().StorageAddrSpace),
+      CurInitSeg(nullptr), CurPtr32ThunkPrefix(nullptr),
+      CurPtr32CS32Name(nullptr), CurPtr32CS64Name(nullptr), VisContext(nullptr),
       PragmaAttributeCurrentTargetDecl(nullptr),
       IsBuildingRecoveryCallExpr(false), Cleanup{}, LateTemplateParser(nullptr),
       LateTemplateParserCleanup(nullptr), OpaqueParser(nullptr), IdResolver(pp),
@@ -175,6 +239,34 @@
   SemaPPCallbackHandler = Callbacks.get();
   PP.addPPCallbacks(std::move(Callbacks));
   SemaPPCallbackHandler->set(*this);
+  Context.DefaultAddrSpace = AddrSpaceStack.CurrentValue;
+  Context.StorageAddrSpace = StgAddrSpaceStack.CurrentValue;
+
+  const TargetOptions &TargetOpts = Context.getTargetInfo().getTargetOpts();
+  if (!TargetOpts.Ptr32ThunkPrefix.empty())
+    CurPtr32ThunkPrefix = StringLiteral::Create(
+        Context, TargetOpts.Ptr32ThunkPrefix, StringLiteral::Ascii,
+        /*Pascal=*/false,
+        Context.getConstantArrayType(
+            Context.CharTy, llvm::APInt(32, TargetOpts.Ptr32ThunkPrefix.size()),
+            ArrayType::Normal, 0),
+        SourceLocation());
+  if (!TargetOpts.Ptr32CS32Name.empty())
+    CurPtr32CS32Name = StringLiteral::Create(
+        Context, TargetOpts.Ptr32CS32Name, StringLiteral::Ascii,
+        /*Pascal=*/false,
+        Context.getConstantArrayType(
+            Context.CharTy, llvm::APInt(32, TargetOpts.Ptr32CS32Name.size()),
+            ArrayType::Normal, 0),
+        SourceLocation());
+  if (!TargetOpts.Ptr32CS64Name.empty())
+    CurPtr32CS64Name = StringLiteral::Create(
+        Context, TargetOpts.Ptr32CS64Name, StringLiteral::Ascii,
+        /*Pascal=*/false,
+        Context.getConstantArrayType(
+            Context.CharTy, llvm::APInt(32, TargetOpts.Ptr32CS64Name.size()),
+            ArrayType::Normal, 0),
+        SourceLocation());
 }
 
 void Sema::addImplicitTypedef(StringRef Name, QualType T) {
@@ -328,6 +420,12 @@
       PushOnScopeChains(Context.getBuiltinMSVaListDecl(), TUScope);
   }
 
+  if (Context.getTargetInfo().hasBuiltinVaList32()) {
+    DeclarationName VaList32 = &Context.Idents.get("__builtin_va_list32");
+    if (IdResolver.begin(VaList32) == IdResolver.end())
+      PushOnScopeChains(Context.getBuiltinVaList32Decl(), TUScope);
+  }
+
   DeclarationName BuiltinVaList = &Context.Idents.get("__builtin_va_list");
   if (IdResolver.begin(BuiltinVaList) == IdResolver.end())
     PushOnScopeChains(Context.getBuiltinVaListDecl(), TUScope);
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaAttr.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaAttr.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaAttr.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaAttr.cpp	2019-05-19 11:21:50.985903000 +0000
@@ -773,6 +773,42 @@
   }
 }
 
+void Sema::ActOnPragmaDefaultAS(SourceLocation Loc, PragmaMsStackAction Action,
+                                LangAS AS) {
+  if (Action & PSK_Pop && AddrSpaceStack.Stack.empty())
+    Diag(Loc, diag::warn_pragma_pop_failed) << "clang default_addr_space"
+                                            << "stack empty";
+  AddrSpaceStack.Act(Loc, Action, StringRef(), AS);
+  Context.DefaultAddrSpace = AddrSpaceStack.CurrentValue;
+}
+
+void Sema::ActOnPragmaStorageAS(SourceLocation Loc, PragmaMsStackAction Action,
+                                LangAS AS) {
+  if (Action & PSK_Pop && StgAddrSpaceStack.Stack.empty())
+    Diag(Loc, diag::warn_pragma_pop_failed) << "clang storage_addr_space"
+                                            << "stack empty";
+  StgAddrSpaceStack.Act(Loc, Action, StringRef(), AS);
+  Context.StorageAddrSpace = StgAddrSpaceStack.CurrentValue;
+}
+
+void Sema::ActOnPragmaPtr32ThunkPrefix(SourceLocation PragmaLocation,
+                                       StringLiteral *Prefix) {
+  CurPtr32ThunkPrefix = Prefix;
+  CurPtr32ThunkPrefixLoc = PragmaLocation;
+}
+
+void Sema::ActOnPragmaPtr32CS32Name(SourceLocation PragmaLocation,
+                                    StringLiteral *Name) {
+  CurPtr32CS32Name = Name;
+  CurPtr32CS32NameLoc = PragmaLocation;
+}
+
+void Sema::ActOnPragmaPtr32CS64Name(SourceLocation PragmaLocation,
+                                    StringLiteral *Name) {
+  CurPtr32CS64Name = Name;
+  CurPtr32CS64NameLoc = PragmaLocation;
+}
+
 void Sema::PushNamespaceVisibilityAttr(const VisibilityAttr *Attr,
                                        SourceLocation Loc) {
   // Visibility calculations will consider the namespace's visibility.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaChecking.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaChecking.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaChecking.cpp	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaChecking.cpp	2019-05-19 11:21:50.985903000 +0000
@@ -3392,6 +3392,9 @@
   if (BuiltinID == X86::BI__builtin_cpu_is)
     return SemaBuiltinCpuIs(*this, TheCall);
 
+  if (BuiltinID == X86::BI__builtin_va_start32)
+    return SemaBuiltinVAStart(BuiltinID, TheCall);
+
   // Check for 32-bit only builtins on a 64-bit target.
   const llvm::Triple &TT = Context.getTargetInfo().getTriple();
   if (TT.getArch() != llvm::Triple::x86 && isX86_32Builtin(BuiltinID))
@@ -5119,6 +5122,11 @@
   return Result;
 }
 
+static bool is32BitABICallConv(CallingConv CC) {
+  return CC == CC_X86C32 || CC == CC_X86StdCall32 || CC == CC_X86FastCall32 ||
+    CC == CC_X86ThisCall32;
+}
+
 /// Check that the user is calling the appropriate va_start builtin for the
 /// target and calling convention.
 static bool checkVAStartABI(Sema &S, unsigned BuiltinID, Expr *Fn) {
@@ -5126,32 +5134,45 @@
   bool IsX64 = TT.getArch() == llvm::Triple::x86_64;
   bool IsAArch64 = TT.getArch() == llvm::Triple::aarch64;
   bool IsWindows = TT.isOSWindows();
+  bool IsWine32 = TT.getEnvironment() == llvm::Triple::Wine32;
   bool IsMSVAStart = BuiltinID == Builtin::BI__builtin_ms_va_start;
+  bool IsVAStart32 = BuiltinID == X86::BI__builtin_va_start32;
   if (IsX64 || IsAArch64) {
     CallingConv CC = CC_C;
     if (const FunctionDecl *FD = S.getCurFunctionDecl())
       CC = FD->getType()->getAs<FunctionType>()->getCallConv();
     if (IsMSVAStart) {
-      // Don't allow this in System V ABI functions.
-      if (CC == CC_X86_64SysV || (!IsWindows && CC != CC_Win64))
+      // Don't allow this in System V or 32-bit ABI functions.
+      if (CC == CC_X86_64SysV || (!IsWindows && CC != CC_Win64) ||
+          is32BitABICallConv(CC))
+        return S.Diag(Fn->getBeginLoc(),
+                      diag::err_ms_va_start_used_in_wrong_abi_function)
+               << is32BitABICallConv(CC);
+    } else if (IsVAStart32) {
+      // Don't allow this in 64-bit ABI functions.
+      if (!is32BitABICallConv(CC))
         return S.Diag(Fn->getLocStart(),
-                      diag::err_ms_va_start_used_in_sysv_function);
+                      diag::err_va_start32_used_in_wrong_abi_function)
+               << ((IsWindows && CC == CC_C) || CC == CC_Win64);
     } else {
       // On x86-64/AArch64 Unix, don't allow this in Win64 ABI functions.
       // On x64 Windows, don't allow this in System V ABI functions.
       // (Yes, that means there's no corresponding way to support variadic
       // System V ABI functions on Windows.)
+      // Don't ever allow this in a 32-bit ABI function on a 64-bit target.
       if ((IsWindows && CC == CC_X86_64SysV) ||
-          (!IsWindows && CC == CC_Win64))
+          (!IsWindows && CC == CC_Win64) || is32BitABICallConv(CC))
         return S.Diag(Fn->getLocStart(),
                       diag::err_va_start_used_in_wrong_abi_function)
-               << !IsWindows;
+               << (is32BitABICallConv(CC) ? 2 : (!IsWindows ? 1 : 0));
     }
     return false;
   }
 
   if (IsMSVAStart)
     return S.Diag(Fn->getLocStart(), diag::err_builtin_x64_aarch64_only);
+  if (IsVAStart32 && !IsWine32)
+    return S.Diag(Fn->getBeginLoc(), diag::err_x86_builtin_only_on_wine32);
   return false;
 }
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaCoroutine.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaCoroutine.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaCoroutine.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaCoroutine.cpp	2019-05-19 11:21:50.985903000 +0000
@@ -87,8 +87,9 @@
       QualType T =
           MD->getThisType(S.Context)->getAs<PointerType>()->getPointeeType();
       T = FnType->getRefQualifier() == RQ_RValue
-              ? S.Context.getRValueReferenceType(T)
-              : S.Context.getLValueReferenceType(T, /*SpelledAsLValue*/ true);
+              ? S.Context.getRValueReferenceType(T, /*HonorASPragma*/ true)
+              : S.Context.getLValueReferenceType(T, /*SpelledAsLValue*/ true,
+                                                 /*HonorASPragma*/ true);
       AddArg(T);
     }
   }
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaDecl.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaDecl.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaDecl.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaDecl.cpp	2019-05-19 11:21:50.985903000 +0000
@@ -7337,7 +7337,8 @@
   // automatic variables that point to other address spaces.
   // ISO/IEC TR 18037 S5.1.2
   if (!getLangOpts().OpenCL && NewVD->hasLocalStorage() &&
-      T.getAddressSpace() != LangAS::Default) {
+      T.getAddressSpace() != Context.getTargetInfo().getStackAddressSpace(
+          getLangOpts())) {
     Diag(NewVD->getLocation(), diag::err_as_qualified_auto_decl) << 0;
     NewVD->setInvalidDecl();
     return;
@@ -8824,6 +8825,17 @@
     }
   }
 
+  // Apply implicit 64/32 interop parameters if active.
+  if (CurPtr32ThunkPrefix)
+    NewFD->addAttr(Ptr32ThunkPrefixAttr::CreateImplicit(
+        Context, CurPtr32ThunkPrefix->getString(), CurPtr32ThunkPrefixLoc));
+  if (CurPtr32CS32Name)
+    NewFD->addAttr(Ptr32CS32NameAttr::CreateImplicit(
+        Context, CurPtr32CS32Name->getString(), CurPtr32CS32NameLoc));
+  if (CurPtr32CS64Name)
+    NewFD->addAttr(Ptr32CS64NameAttr::CreateImplicit(
+        Context, CurPtr32CS64Name->getString(), CurPtr32CS64NameLoc));
+
   // Handle attributes.
   ProcessDeclAttributes(S, NewFD, D);
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaDeclAttr.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaDeclAttr.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaDeclAttr.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaDeclAttr.cpp	2019-05-19 11:21:50.985903000 +0000
@@ -1906,8 +1906,8 @@
 }
 
 static void handleNakedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
-  if (checkAttrMutualExclusion<DisableTailCallsAttr>(S, D, AL.getRange(),
-                                                     AL.getName()))
+  if (checkAttrMutualExclusion<DisableTailCallsAttr>(S, D, AL.getRange(), AL.getName()) ||
+      checkAttrMutualExclusion<MSHookPrologueAttr>(S, D, AL.getRange(), AL.getName()))
     return;
 
   if (AL.isDeclspecAttribute()) {
@@ -3082,7 +3082,7 @@
 
   // We're currently more strict than GCC about what function types we accept.
   // If this ever proves to be a problem it should be easy to fix.
-  QualType Ty = S.Context.getPointerType(cast<VarDecl>(D)->getType());
+  QualType Ty = S.Context.getPointerType(cast<VarDecl>(D)->getType(), true);
   QualType ParamTy = FD->getParamDecl(0)->getType();
   if (S.CheckAssignmentConstraints(FD->getParamDecl(0)->getLocation(),
                                    ParamTy, Ty) != Sema::Compatible) {
@@ -4039,8 +4039,8 @@
 }
 
 static void handleAlwaysInlineAttr(Sema &S, Decl *D, const ParsedAttr &AL) {
-  if (checkAttrMutualExclusion<NotTailCalledAttr>(S, D, AL.getRange(),
-                                                  AL.getName()))
+  if (checkAttrMutualExclusion<NotTailCalledAttr>(S, D, AL.getRange(), AL.getName()) ||
+      checkAttrMutualExclusion<MSHookPrologueAttr>(S, D, AL.getRange(), AL.getName()))
     return;
 
   if (AlwaysInlineAttr *Inline = S.mergeAlwaysInlineAttr(
@@ -4235,6 +4235,22 @@
     D->addAttr(::new (S.Context) PreserveAllAttr(
         AL.getRange(), S.Context, AL.getAttributeSpellingListIndex()));
     return;
+  case ParsedAttr::AT_FastCall32:
+    D->addAttr(::new (S.Context) FastCall32Attr(
+        AL.getRange(), S.Context, AL.getAttributeSpellingListIndex()));
+    return;
+  case ParsedAttr::AT_StdCall32:
+    D->addAttr(::new (S.Context) StdCall32Attr(
+        AL.getRange(), S.Context, AL.getAttributeSpellingListIndex()));
+    return;
+  case ParsedAttr::AT_ThisCall32:
+    D->addAttr(::new (S.Context) ThisCall32Attr(
+        AL.getRange(), S.Context, AL.getAttributeSpellingListIndex()));
+    return;
+  case ParsedAttr::AT_CDecl32:
+    D->addAttr(::new (S.Context) CDecl32Attr(
+        AL.getRange(), S.Context, AL.getAttributeSpellingListIndex()));
+    return;
   default:
     llvm_unreachable("unexpected attribute kind");
   }
@@ -4337,6 +4353,18 @@
   case ParsedAttr::AT_PreserveAll:
     CC = CC_PreserveAll;
     break;
+  case ParsedAttr::AT_CDecl32:
+    CC = CC_X86C32;
+    break;
+  case ParsedAttr::AT_FastCall32:
+    CC = CC_X86FastCall32;
+    break;
+  case ParsedAttr::AT_StdCall32:
+    CC = CC_X86StdCall32;
+    break;
+  case ParsedAttr::AT_ThisCall32:
+    CC = CC_X86ThisCall32;
+    break;
   default: llvm_unreachable("unexpected attribute kind");
   }
 
@@ -6423,6 +6451,10 @@
   case ParsedAttr::AT_IntelOclBicc:
   case ParsedAttr::AT_PreserveMost:
   case ParsedAttr::AT_PreserveAll:
+  case ParsedAttr::AT_StdCall32:
+  case ParsedAttr::AT_CDecl32:
+  case ParsedAttr::AT_FastCall32:
+  case ParsedAttr::AT_ThisCall32:
     handleCallConvAttr(S, D, AL);
     break;
   case ParsedAttr::AT_Suppress:
@@ -6459,6 +6491,9 @@
     break;
   case ParsedAttr::AT_LayoutVersion:
     handleLayoutVersion(S, D, AL);
+  case ParsedAttr::AT_MSHookPrologue:
+    handleSimpleAttributeWithExclusions<MSHookPrologueAttr, NakedAttr,
+      AlwaysInlineAttr>(S, D, AL);
     break;
   case ParsedAttr::AT_TrivialABI:
     handleSimpleAttribute<TrivialABIAttr>(S, D, AL);
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaDeclCXX.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaDeclCXX.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaDeclCXX.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaDeclCXX.cpp	2019-05-19 11:21:50.995903000 +0000
@@ -6479,7 +6479,7 @@
     // Check for return type matching.
     ReturnType = Type->getReturnType();
     QualType ExpectedReturnType =
-        Context.getLValueReferenceType(Context.getTypeDeclType(RD));
+        Context.getLValueReferenceType(Context.getTypeDeclType(RD), true, true);
     if (!Context.hasSameType(ReturnType, ExpectedReturnType)) {
       Diag(MD->getLocation(), diag::err_defaulted_special_member_return_type)
         << (CSM == CXXMoveAssignment) << ExpectedReturnType;
@@ -11656,11 +11656,11 @@
     return nullptr;
 
   QualType ArgType = Context.getTypeDeclType(ClassDecl);
-  QualType RetType = Context.getLValueReferenceType(ArgType);
+  QualType RetType = Context.getLValueReferenceType(ArgType, true, true);
   bool Const = ClassDecl->implicitCopyAssignmentHasConstParam();
   if (Const)
     ArgType = ArgType.withConst();
-  ArgType = Context.getLValueReferenceType(ArgType);
+  ArgType = Context.getLValueReferenceType(ArgType, true, true);
 
   bool Constexpr = defaultedSpecialMemberIsConstexpr(*this, ClassDecl,
                                                      CXXCopyAssignment,
@@ -11980,8 +11980,8 @@
   // constructor rules.
 
   QualType ArgType = Context.getTypeDeclType(ClassDecl);
-  QualType RetType = Context.getLValueReferenceType(ArgType);
-  ArgType = Context.getRValueReferenceType(ArgType);
+  QualType RetType = Context.getLValueReferenceType(ArgType, true, true);
+  ArgType = Context.getRValueReferenceType(ArgType, true);
 
   bool Constexpr = defaultedSpecialMemberIsConstexpr(*this, ClassDecl,
                                                      CXXMoveAssignment,
@@ -12356,7 +12356,7 @@
   bool Const = ClassDecl->implicitCopyConstructorHasConstParam();
   if (Const)
     ArgType = ArgType.withConst();
-  ArgType = Context.getLValueReferenceType(ArgType);
+  ArgType = Context.getLValueReferenceType(ArgType, true, true);
 
   bool Constexpr = defaultedSpecialMemberIsConstexpr(*this, ClassDecl,
                                                      CXXCopyConstructor,
@@ -12485,7 +12485,7 @@
     return nullptr;
 
   QualType ClassType = Context.getTypeDeclType(ClassDecl);
-  QualType ArgType = Context.getRValueReferenceType(ClassType);
+  QualType ArgType = Context.getRValueReferenceType(ClassType, true);
 
   bool Constexpr = defaultedSpecialMemberIsConstexpr(*this, ClassDecl,
                                                      CXXMoveConstructor,
@@ -13109,7 +13109,7 @@
   CanQualType ExpectedFirstParamType =
       MD && MD->isDestroyingOperatorDelete()
           ? SemaRef.Context.getCanonicalType(SemaRef.Context.getPointerType(
-                SemaRef.Context.getRecordType(MD->getParent())))
+                SemaRef.Context.getRecordType(MD->getParent()), true))
           : SemaRef.Context.VoidPtrTy;
 
   // C++ [basic.stc.dynamic.deallocation]p2:
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaDeclObjC.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaDeclObjC.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaDeclObjC.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaDeclObjC.cpp	2019-05-19 11:21:50.995903000 +0000
@@ -4633,6 +4633,17 @@
   ObjCMethod->setObjCDeclQualifier(
     CvtQTToAstBitMask(ReturnQT.getObjCDeclQualifier()));
 
+  // Apply implicit 64/32 interop parameters if active.
+  if (CurPtr32ThunkPrefix)
+    ObjCMethod->addAttr(Ptr32ThunkPrefixAttr::CreateImplicit(
+        Context, CurPtr32ThunkPrefix->getString(), CurPtr32ThunkPrefixLoc));
+  if (CurPtr32CS32Name)
+    ObjCMethod->addAttr(Ptr32CS32NameAttr::CreateImplicit(
+        Context, CurPtr32CS32Name->getString(), CurPtr32CS32NameLoc));
+  if (CurPtr32CS64Name)
+    ObjCMethod->addAttr(Ptr32CS64NameAttr::CreateImplicit(
+        Context, CurPtr32CS64Name->getString(), CurPtr32CS64NameLoc));
+
   ProcessDeclAttributeList(TUScope, ObjCMethod, AttrList);
   AddPragmaAttributes(TUScope, ObjCMethod);
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaExpr.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaExpr.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaExpr.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaExpr.cpp	2019-05-19 11:21:50.995903000 +0000
@@ -7505,6 +7505,17 @@
   if (!S.getLangOpts().CPlusPlus &&
       S.IsFunctionConversion(ltrans, rtrans, ltrans))
     return Sema::IncompatiblePointer;
+  if (S.getLangOpts().Interop6432) {
+    // Special case: If the types in question are function types, the target
+    // address space is ptr32, and the particular types in question have
+    // 32-bit calling conventions, then this is allowed.
+    if (ConvTy == Sema::IncompatiblePointerDiscardsQualifiers &&
+        lhptee->isFunctionType() && rhptee->isFunctionType() &&
+        lhq.getAddressSpace() == LangAS::ptr32 &&
+        rhq.getAddressSpace() == LangAS::Default &&
+        is32BitInteropCC(lhptee->castAs<FunctionType>()->getCallConv()))
+      return Sema::Compatible;
+  }
   return ConvTy;
 }
 
@@ -13276,6 +13287,17 @@
   // cleanups from the enclosing full-expression.
   PushExpressionEvaluationContext(
       ExpressionEvaluationContext::PotentiallyEvaluated);
+
+  // Apply implicit 64/32 interop parameters if active.
+  if (CurPtr32ThunkPrefix)
+    Block->addAttr(Ptr32ThunkPrefixAttr::CreateImplicit(
+        Context, CurPtr32ThunkPrefix->getString(), CurPtr32ThunkPrefixLoc));
+  if (CurPtr32CS32Name)
+    Block->addAttr(Ptr32CS32NameAttr::CreateImplicit(
+        Context, CurPtr32CS32Name->getString(), CurPtr32CS32NameLoc));
+  if (CurPtr32CS64Name)
+    Block->addAttr(Ptr32CS64NameAttr::CreateImplicit(
+        Context, CurPtr32CS64Name->getString(), CurPtr32CS64NameLoc));
 }
 
 void Sema::ActOnBlockArguments(SourceLocation CaretLoc, Declarator &ParamInfo,
@@ -13537,7 +13559,7 @@
                                 Expr *E, TypeSourceInfo *TInfo,
                                 SourceLocation RPLoc) {
   Expr *OrigExpr = E;
-  bool IsMS = false;
+  bool IsMS = false, Is32 = false;
 
   // CUDA device code does not support varargs.
   if (getLangOpts().CUDA && getLangOpts().CUDAIsDevice) {
@@ -13548,13 +13570,25 @@
     }
   }
 
+  // It might be a __builtin_va_list32. This is always and everywhere
+  // semantically distinct from both __builtin_va_list and __builtin_ms_va_list.
+  if (!E->isTypeDependent() && Context.getTargetInfo().hasBuiltinVaList32()) {
+    QualType VaList32Type = Context.getBuiltinVaList32Type();
+    if (Context.hasSameUnqualifiedType(VaList32Type, E->getType())) {
+      if (CheckForModifiableLvalue(E, BuiltinLoc, *this))
+        return ExprError();
+      Is32 = true;
+    }
+  }
   // It might be a __builtin_ms_va_list. (But don't ever mark a va_arg()
   // as Microsoft ABI on an actual Microsoft platform, where
   // __builtin_ms_va_list and __builtin_va_list are the same.)
-  if (!E->isTypeDependent() && Context.getTargetInfo().hasBuiltinMSVaList() &&
-      Context.getTargetInfo().getBuiltinVaListKind() != TargetInfo::CharPtrBuiltinVaList) {
+  if (!Is32 && !E->isTypeDependent() &&
+      Context.getTargetInfo().hasBuiltinMSVaList() &&
+      Context.getTargetInfo().getBuiltinVaListKind() !=
+          TargetInfo::CharPtrBuiltinVaList) {
     QualType MSVaListType = Context.getBuiltinMSVaListType();
-    if (Context.hasSameType(MSVaListType, E->getType())) {
+    if (Context.hasSameUnqualifiedType(MSVaListType, E->getType())) {
       if (CheckForModifiableLvalue(E, BuiltinLoc, *this))
         return ExprError();
       IsMS = true;
@@ -13562,8 +13596,10 @@
   }
 
   // Get the va_list type
-  QualType VaListType = Context.getBuiltinVaListType();
-  if (!IsMS) {
+  QualType VaListType = Context.getAddrSpaceQualType(
+        Context.getBuiltinVaListType(),
+        Context.getTargetInfo().getStackAddressSpace(getLangOpts()));
+  if (!IsMS && !Is32) {
     if (VaListType->isArrayType()) {
       // Deal with implicit array decay; for example, on x86-64,
       // va_list is an array, but it's supposed to decay to
@@ -13592,11 +13628,25 @@
     }
   }
 
-  if (!IsMS && !E->isTypeDependent() &&
-      !Context.hasSameType(VaListType, E->getType()))
-    return ExprError(Diag(E->getLocStart(),
-                         diag::err_first_argument_to_va_arg_not_of_type_va_list)
-      << OrigExpr->getType() << E->getSourceRange());
+  if (!IsMS && !Is32 && !E->isTypeDependent() &&
+      !Context.hasSameType(VaListType, E->getType())) {
+    // Also allow struct __va_list_tag * __ptr64 on Wine32, or otherwise
+    // we won't be able to pass va_lists around to functions.
+    // XXX This is a dumb kludge.
+    if (!Context.getTargetInfo().hasBuiltinVaList32())
+      return ExprError(
+          Diag(E->getLocStart(),
+               diag::err_first_argument_to_va_arg_not_of_type_va_list)
+          << OrigExpr->getType() << E->getSourceRange());
+    VaListType = Context.getBuiltinVaListType();
+    if (VaListType->isArrayType())
+      VaListType = Context.getArrayDecayedType(VaListType);
+    if (!Context.hasSameType(VaListType, E->getType()))
+      return ExprError(
+          Diag(E->getLocStart(),
+               diag::err_first_argument_to_va_arg_not_of_type_va_list)
+          << OrigExpr->getType() << E->getSourceRange());
+  }
 
   if (!TInfo->getType()->isDependentType()) {
     if (RequireCompleteType(TInfo->getTypeLoc().getBeginLoc(), TInfo->getType(),
@@ -13638,7 +13688,12 @@
   }
 
   QualType T = TInfo->getType().getNonLValueExprType(Context);
-  return new (Context) VAArgExpr(BuiltinLoc, E, TInfo, RPLoc, T, IsMS);
+  VAArgExpr::Kind K = VAArgExpr::Default;
+  if (IsMS)
+    K = VAArgExpr::MSABI;
+  if (Is32)
+    K = VAArgExpr::ABI32;
+  return new (Context) VAArgExpr(BuiltinLoc, E, TInfo, RPLoc, T, K);
 }
 
 ExprResult Sema::ActOnGNUNullExpr(SourceLocation TokenLoc) {
@@ -15884,7 +15939,7 @@
 
       Expr *SubExpr = SubResult.get();
       E->setSubExpr(SubExpr);
-      E->setType(S.Context.getPointerType(SubExpr->getType()));
+      E->setType(S.Context.getPointerType(SubExpr->getType(), true));
       assert(E->getValueKind() == VK_RValue);
       assert(E->getObjectKind() == OK_Ordinary);
       return E;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaExprCXX.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaExprCXX.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaExprCXX.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaExprCXX.cpp	2019-05-19 11:21:50.995903000 +0000
@@ -1878,7 +1878,7 @@
                                     AllocType->getObjCARCImplicitLifetime());
   }
 
-  QualType ResultType = Context.getPointerType(AllocType);
+  QualType ResultType = Context.getPointerType(AllocType, true);
 
   if (ArraySize && ArraySize->getType()->isNonOverloadPlaceholderType()) {
     ExprResult result = CheckPlaceholderExpr(ArraySize);
@@ -2705,7 +2705,7 @@
 
   GlobalNewDeleteDeclared = true;
 
-  QualType VoidPtr = Context.getPointerType(Context.VoidTy);
+  QualType VoidPtr = Context.getPointerType(Context.VoidTy, true);
   QualType SizeT = Context.getSizeType();
 
   auto DeclareGlobalAllocationFunctions = [&](OverloadedOperatorKind Kind,
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaFixItUtils.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaFixItUtils.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaFixItUtils.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaFixItUtils.cpp	2019-05-19 11:21:50.995903000 +0000
@@ -133,7 +133,7 @@
     if (!Expr->isLValue() || Expr->getObjectKind() != OK_Ordinary)
       return false;
 
-    CanConvert = CompareTypes(S.Context.getPointerType(FromQTy), ToQTy,
+    CanConvert = CompareTypes(S.Context.getPointerType(FromQTy, true), ToQTy,
                               S, Begin, VK_RValue);
     if (CanConvert) {
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaInit.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaInit.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaInit.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaInit.cpp	2019-05-19 11:21:50.995903000 +0000
@@ -5122,7 +5122,7 @@
   if (const ArrayType *ArgArrayType = S.Context.getAsArrayType(ArgType)) {
     ArrayDecay = true;
     ArgPointee = ArgArrayType->getElementType();
-    ArgType = S.Context.getPointerType(ArgPointee);
+    ArgType = S.Context.getPointerType(ArgPointee, true);
   }
 
   // Handle write-back conversion.
@@ -5146,7 +5146,7 @@
     QualType ResultType;
     if (ArrayDecay) {
       ICS.Standard.First = ICK_Array_To_Pointer;
-      ResultType = S.Context.getPointerType(ArgPointee);
+      ResultType = S.Context.getPointerType(ArgPointee, true);
     } else {
       ICS.Standard.First = ICK_Lvalue_To_Rvalue;
       ResultType = Initializer->getType().getNonLValueExprType(S.Context);
@@ -7619,7 +7619,7 @@
       if (ResultType &&
           ResultType->getNonReferenceType()->isIncompleteArrayType()) {
         if ((*ResultType)->isRValueReferenceType())
-          Ty = S.Context.getRValueReferenceType(Ty);
+          Ty = S.Context.getRValueReferenceType(Ty, true);
         else if ((*ResultType)->isLValueReferenceType())
           Ty = S.Context.getLValueReferenceType(Ty,
             (*ResultType)->getAs<LValueReferenceType>()->isSpelledAsLValue());
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaLambda.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaLambda.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaLambda.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaLambda.cpp	2019-05-19 11:21:50.995903000 +0000
@@ -1760,6 +1760,17 @@
 
   Block->setIsConversionFromLambda(true);
 
+  // Apply implicit 64/32 interop parameters if active.
+  if (CurPtr32ThunkPrefix)
+    Block->addAttr(Ptr32ThunkPrefixAttr::CreateImplicit(
+        Context, CurPtr32ThunkPrefix->getString(), CurPtr32ThunkPrefixLoc));
+  if (CurPtr32CS32Name)
+    Block->addAttr(Ptr32CS32NameAttr::CreateImplicit(
+        Context, CurPtr32CS32Name->getString(), CurPtr32CS32NameLoc));
+  if (CurPtr32CS64Name)
+    Block->addAttr(Ptr32CS64NameAttr::CreateImplicit(
+        Context, CurPtr32CS64Name->getString(), CurPtr32CS64NameLoc));
+
   // Add capture. The capture uses a fake variable, which doesn't correspond
   // to any actual memory location. However, the initializer copy-initializes
   // the lambda object.
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaOverload.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaOverload.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaOverload.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaOverload.cpp	2019-05-19 11:21:51.005903000 +0000
@@ -2198,7 +2198,7 @@
     // already.
     if (isa<ObjCObjectPointerType>(ToType))
       return Context.getObjCObjectPointerType(ToPointee);
-    return Context.getPointerType(ToPointee);
+    return Context.getPointerType(ToPointee, true);
   }
 
   // Just build a canonical type that has the right qualifiers.
@@ -2207,7 +2207,7 @@
 
   if (isa<ObjCObjectPointerType>(ToType))
     return Context.getObjCObjectPointerType(QualifiedCanonToPointee);
-  return Context.getPointerType(QualifiedCanonToPointee);
+  return Context.getPointerType(QualifiedCanonToPointee, true);
 }
 
 static bool isNullPointerConstantForConversion(Expr *Expr,
@@ -2481,7 +2481,7 @@
                               IncompatibleObjC)) {
     // We always complain about this conversion.
     IncompatibleObjC = true;
-    ConvertedType = Context.getPointerType(ConvertedType);
+    ConvertedType = Context.getPointerType(ConvertedType, true);
     ConvertedType = AdoptQualifiers(Context, ConvertedType, FromQualifiers);
     return true;
   }
@@ -2492,7 +2492,7 @@
       isObjCPointerConversion(FromPointeeType, ToPointeeType, ConvertedType,
                               IncompatibleObjC)) {
 
-    ConvertedType = Context.getPointerType(ConvertedType);
+    ConvertedType = Context.getPointerType(ConvertedType, true);
     ConvertedType = AdoptQualifiers(Context, ConvertedType, FromQualifiers);
     return true;
   }
@@ -7467,7 +7467,7 @@
     // Build qualified pointer type.
     QualType QPointerTy;
     if (!buildObjCPtr)
-      QPointerTy = Context.getPointerType(QPointeeTy);
+      QPointerTy = Context.getPointerType(QPointeeTy, true);
     else
       QPointerTy = Context.getObjCObjectPointerType(QPointeeTy);
 
@@ -7612,7 +7612,7 @@
   QualType ParamTypes[2];
 
   // T& operator=(T&, T)
-  ParamTypes[0] = S.Context.getLValueReferenceType(T);
+  ParamTypes[0] = S.Context.getLValueReferenceType(T, true, true);
   ParamTypes[1] = T;
   S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                         /*IsAssignmentOperator=*/true);
@@ -7620,7 +7620,8 @@
   if (!S.Context.getCanonicalType(T).isVolatileQualified()) {
     // volatile T& operator=(volatile T&, T)
     ParamTypes[0]
-      = S.Context.getLValueReferenceType(S.Context.getVolatileType(T));
+      = S.Context.getLValueReferenceType(S.Context.getVolatileType(T),
+                                         true, true);
     ParamTypes[1] = T;
     S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                           /*IsAssignmentOperator=*/true);
@@ -7759,7 +7760,7 @@
                                            bool HasVolatile,
                                            bool HasRestrict) {
     QualType ParamTypes[2] = {
-      S.Context.getLValueReferenceType(CandidateTy),
+      S.Context.getLValueReferenceType(CandidateTy, true, true),
       S.Context.IntTy
     };
 
@@ -7769,9 +7770,8 @@
     // Use a heuristic to reduce number of builtin candidates in the set:
     // add volatile version only if there are conversions to a volatile type.
     if (HasVolatile) {
-      ParamTypes[0] =
-        S.Context.getLValueReferenceType(
-          S.Context.getVolatileType(CandidateTy));
+      ParamTypes[0] = S.Context.getLValueReferenceType(
+          S.Context.getVolatileType(CandidateTy), true, true);
       S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
     }
 
@@ -7781,7 +7781,8 @@
         !CandidateTy.isRestrictQualified()) {
       ParamTypes[0]
         = S.Context.getLValueReferenceType(
-            S.Context.getCVRQualifiedType(CandidateTy, Qualifiers::Restrict));
+            S.Context.getCVRQualifiedType(CandidateTy, Qualifiers::Restrict),
+            /*SpelledAsLValue=*/true);
       S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
 
       if (HasVolatile) {
@@ -7789,7 +7790,8 @@
           = S.Context.getLValueReferenceType(
               S.Context.getCVRQualifiedType(CandidateTy,
                                             (Qualifiers::Volatile |
-                                             Qualifiers::Restrict)));
+                                             Qualifiers::Restrict)),
+              /*SpelledAsLValue=*/true);
         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
       }
     }
@@ -8338,7 +8340,7 @@
 
       // non-volatile version
       QualType ParamTypes[2] = {
-        S.Context.getLValueReferenceType(*Ptr),
+        S.Context.getLValueReferenceType(*Ptr, true, true),
         isEqualOp ? *Ptr : S.Context.getPointerDiffType(),
       };
       S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
@@ -8348,8 +8350,8 @@
                           VisibleTypeConversionsQuals.hasVolatile();
       if (NeedVolatile) {
         // volatile version
-        ParamTypes[0] =
-          S.Context.getLValueReferenceType(S.Context.getVolatileType(*Ptr));
+        ParamTypes[0] = S.Context.getLValueReferenceType(
+            S.Context.getVolatileType(*Ptr), true, true);
         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                               /*IsAssigmentOperator=*/isEqualOp);
       }
@@ -8357,8 +8359,8 @@
       if (!(*Ptr).isRestrictQualified() &&
           VisibleTypeConversionsQuals.hasRestrict()) {
         // restrict version
-        ParamTypes[0]
-          = S.Context.getLValueReferenceType(S.Context.getRestrictType(*Ptr));
+        ParamTypes[0] = S.Context.getLValueReferenceType(
+            S.Context.getRestrictType(*Ptr), true, true);
         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                               /*IsAssigmentOperator=*/isEqualOp);
 
@@ -8368,7 +8370,8 @@
             = S.Context.getLValueReferenceType(
                 S.Context.getCVRQualifiedType(*Ptr,
                                               (Qualifiers::Volatile |
-                                               Qualifiers::Restrict)));
+                                               Qualifiers::Restrict)),
+                /*SpelledAsLValue=*/true);
           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                                 /*IsAssigmentOperator=*/isEqualOp);
         }
@@ -8385,7 +8388,7 @@
           continue;
 
         QualType ParamTypes[2] = {
-          S.Context.getLValueReferenceType(*Ptr),
+          S.Context.getLValueReferenceType(*Ptr, true, true),
           *Ptr,
         };
 
@@ -8397,8 +8400,8 @@
                            VisibleTypeConversionsQuals.hasVolatile();
         if (NeedVolatile) {
           // volatile version
-          ParamTypes[0] =
-            S.Context.getLValueReferenceType(S.Context.getVolatileType(*Ptr));
+          ParamTypes[0] = S.Context.getLValueReferenceType(
+              S.Context.getVolatileType(*Ptr), true, true);
           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                                 /*IsAssigmentOperator=*/true);
         }
@@ -8406,8 +8409,8 @@
         if (!(*Ptr).isRestrictQualified() &&
             VisibleTypeConversionsQuals.hasRestrict()) {
           // restrict version
-          ParamTypes[0]
-            = S.Context.getLValueReferenceType(S.Context.getRestrictType(*Ptr));
+          ParamTypes[0] = S.Context.getLValueReferenceType(
+              S.Context.getRestrictType(*Ptr), true, true);
           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                                 /*IsAssigmentOperator=*/true);
 
@@ -8417,7 +8420,8 @@
               = S.Context.getLValueReferenceType(
                   S.Context.getCVRQualifiedType(*Ptr,
                                                 (Qualifiers::Volatile |
-                                                 Qualifiers::Restrict)));
+                                                 Qualifiers::Restrict)),
+                  /*SpelledAsLValue=*/true);
             S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                                   /*IsAssigmentOperator=*/true);
           }
@@ -8450,7 +8454,7 @@
 
         // Add this built-in operator as a candidate (VQ is empty).
         ParamTypes[0] =
-          S.Context.getLValueReferenceType(ArithmeticTypes[Left]);
+          S.Context.getLValueReferenceType(ArithmeticTypes[Left], true, true);
         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                               /*IsAssigmentOperator=*/isEqualOp);
 
@@ -8458,7 +8462,8 @@
         if (VisibleTypeConversionsQuals.hasVolatile()) {
           ParamTypes[0] =
             S.Context.getVolatileType(ArithmeticTypes[Left]);
-          ParamTypes[0] = S.Context.getLValueReferenceType(ParamTypes[0]);
+          ParamTypes[0] = S.Context.getLValueReferenceType(
+              ParamTypes[0], true, true);
           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                                 /*IsAssigmentOperator=*/isEqualOp);
         }
@@ -8477,14 +8482,15 @@
         QualType ParamTypes[2];
         ParamTypes[1] = *Vec2;
         // Add this built-in operator as a candidate (VQ is empty).
-        ParamTypes[0] = S.Context.getLValueReferenceType(*Vec1);
+        ParamTypes[0] = S.Context.getLValueReferenceType(*Vec1, true, true);
         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                               /*IsAssigmentOperator=*/isEqualOp);
 
         // Add this built-in operator as a candidate (VQ is 'volatile').
         if (VisibleTypeConversionsQuals.hasVolatile()) {
           ParamTypes[0] = S.Context.getVolatileType(*Vec1);
-          ParamTypes[0] = S.Context.getLValueReferenceType(ParamTypes[0]);
+          ParamTypes[0] = S.Context.getLValueReferenceType(
+              ParamTypes[0], true, true);
           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,
                                 /*IsAssigmentOperator=*/isEqualOp);
         }
@@ -8516,13 +8522,14 @@
 
         // Add this built-in operator as a candidate (VQ is empty).
         ParamTypes[0] =
-          S.Context.getLValueReferenceType(ArithmeticTypes[Left]);
+          S.Context.getLValueReferenceType(ArithmeticTypes[Left], true, true);
         S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
         if (VisibleTypeConversionsQuals.hasVolatile()) {
           // Add this built-in operator as a candidate (VQ is 'volatile').
           ParamTypes[0] = ArithmeticTypes[Left];
           ParamTypes[0] = S.Context.getVolatileType(ParamTypes[0]);
-          ParamTypes[0] = S.Context.getLValueReferenceType(ParamTypes[0]);
+          ParamTypes[0] = S.Context.getLValueReferenceType(
+              ParamTypes[0], true, true);
           S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);
         }
       }
@@ -13715,10 +13722,9 @@
     if (SubExpr == UnOp->getSubExpr())
       return UnOp;
 
-    return new (Context) UnaryOperator(SubExpr, UO_AddrOf,
-                                     Context.getPointerType(SubExpr->getType()),
-                                       VK_RValue, OK_Ordinary,
-                                       UnOp->getOperatorLoc(), false);
+    return new (Context) UnaryOperator(
+        SubExpr, UO_AddrOf, Context.getPointerType(SubExpr->getType(), true),
+        VK_RValue, OK_Ordinary, UnOp->getOperatorLoc(), false);
   }
 
   // C++ [except.spec]p17:
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaTemplate.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaTemplate.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaTemplate.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaTemplate.cpp	2019-05-19 11:21:51.005903000 +0000
@@ -5959,7 +5959,7 @@
         // If the template parameter has pointer type but the address of
         // this object was not taken, complain and (possibly) recover by
         // taking the address of the entity.
-        ArgType = S.Context.getPointerType(Var->getType());
+        ArgType = S.Context.getPointerType(Var->getType(), true);
         if (!S.Context.hasSameUnqualifiedType(ArgType, ParamType)) {
           S.Diag(Arg->getLocStart(), diag::err_template_arg_not_address_of)
             << ParamType;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaTemplateDeduction.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaTemplateDeduction.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaTemplateDeduction.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaTemplateDeduction.cpp	2019-05-19 11:21:51.005903000 +0000
@@ -4621,7 +4621,7 @@
     QualType RetType = getLambdaConversionFunctionResultType(
         CallOp->getType()->castAs<FunctionProtoType>());
     if (FD->getReturnType()->getAs<PointerType>())
-      RetType = Context.getPointerType(RetType);
+      RetType = Context.getPointerType(RetType, true);
     else {
       assert(FD->getReturnType()->getAs<BlockPointerType>());
       RetType = Context.getBlockPointerType(RetType);
@@ -4658,9 +4658,9 @@
   ArgTy = Context.getQualifiedType(ArgTy,
                         Qualifiers::fromCVRMask(Method->getTypeQualifiers()));
   if (Method->getRefQualifier() == RQ_RValue)
-    ArgTy = Context.getRValueReferenceType(ArgTy);
+    ArgTy = Context.getRValueReferenceType(ArgTy, true);
   else
-    ArgTy = Context.getLValueReferenceType(ArgTy);
+    ArgTy = Context.getLValueReferenceType(ArgTy, true, true);
   ArgTypes.push_back(ArgTy);
 }
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaType.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaType.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Sema/SemaType.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Sema/SemaType.cpp	2019-05-19 11:21:51.005903000 +0000
@@ -121,7 +121,11 @@
   case ParsedAttr::AT_Pcs:                                                     \
   case ParsedAttr::AT_IntelOclBicc:                                            \
   case ParsedAttr::AT_PreserveMost:                                            \
-  case ParsedAttr::AT_PreserveAll
+  case ParsedAttr::AT_PreserveAll:                                             \
+  case ParsedAttr::AT_CDecl32:                                                 \
+  case ParsedAttr::AT_StdCall32:                                               \
+  case ParsedAttr::AT_FastCall32:                                              \
+  case ParsedAttr::AT_ThisCall32
 
 // Function type attributes.
 #define FUNCTION_TYPE_ATTRS_CASELIST                                           \
@@ -1907,7 +1911,7 @@
     T = inferARCLifetimeForPointee(*this, T, Loc, /*reference*/ false);
 
   // Build the pointer type.
-  return Context.getPointerType(T);
+  return Context.getPointerType(T, /*HonorASPragma*/ true);
 }
 
 /// Build a reference type.
@@ -1968,8 +1972,9 @@
 
   // Handle restrict on references.
   if (LValueRef)
-    return Context.getLValueReferenceType(T, SpelledAsLValue);
-  return Context.getRValueReferenceType(T);
+    return Context.getLValueReferenceType(T, SpelledAsLValue,
+                                          /*HonorASPragma*/ true);
+  return Context.getRValueReferenceType(T, /*HonorASPragma*/ true);
 }
 
 /// Build a Read-only Pipe type.
@@ -5215,6 +5220,14 @@
     return ParsedAttr::AT_PreserveMost;
   case AttributedType::attr_preserve_all:
     return ParsedAttr::AT_PreserveAll;
+  case AttributedType::attr_cdecl32:
+    return ParsedAttr::AT_CDecl32;
+  case AttributedType::attr_stdcall32:
+    return ParsedAttr::AT_StdCall32;
+  case AttributedType::attr_fastcall32:
+    return ParsedAttr::AT_FastCall32;
+  case AttributedType::attr_thiscall32:
+    return ParsedAttr::AT_ThisCall32;
   case AttributedType::attr_ptr32:
     return ParsedAttr::AT_Ptr32;
   case AttributedType::attr_ptr64:
@@ -6757,7 +6770,7 @@
     // Diagnose regparm with fastcall.
     const FunctionType *fn = unwrapped.get();
     CallingConv CC = fn->getCallConv();
-    if (CC == CC_X86FastCall) {
+    if (CC == CC_X86FastCall || CC == CC_X86FastCall32) {
       S.Diag(attr.getLoc(), diag::err_attributes_are_not_compatible)
         << FunctionType::getNameForCallConv(CC)
         << "regparm";
@@ -6811,21 +6824,26 @@
       // stdcall and fastcall are ignored with a warning for GCC and MS
       // compatibility.
       bool IsInvalid = true;
-      if (CC == CC_X86StdCall || CC == CC_X86FastCall) {
+      if (CC == CC_X86StdCall || CC == CC_X86FastCall ||
+          CC == CC_X86StdCall32 || CC == CC_X86FastCall32) {
         DiagID = diag::warn_cconv_varargs;
         IsInvalid = false;
       }
 
       S.Diag(attr.getLoc(), DiagID) << FunctionType::getNameForCallConv(CC);
       if (IsInvalid) attr.setInvalid();
-      return true;
+      // For the 32-bit compatible conventions, use the 32-bit C convention.
+      if (CC == CC_X86StdCall32 || CC == CC_X86FastCall32)
+        CC = CC_X86C32;
+      else
+        return true;
     }
   }
 
   // Also diagnose fastcall with regparm.
-  if (CC == CC_X86FastCall && fn->getHasRegParm()) {
+  if ((CC == CC_X86FastCall || CC == CC_X86FastCall32) && fn->getHasRegParm()) {
     S.Diag(attr.getLoc(), diag::err_attributes_are_not_compatible)
-        << "regparm" << FunctionType::getNameForCallConv(CC_X86FastCall);
+        << "regparm" << FunctionType::getNameForCallConv(CC);
     attr.setInvalid();
     return true;
   }
@@ -6872,7 +6890,7 @@
   if (Context.getTargetInfo().getCXXABI().isMicrosoft() && IsCtorOrDtor) {
     // Issue a warning on ignored calling convention -- except of __stdcall.
     // Again, this is what MS compiler does.
-    if (CurCC != CC_X86StdCall)
+    if (CurCC != CC_X86StdCall && CurCC != CC_X86StdCall32)
       Diag(Loc, diag::warn_cconv_structors)
           << FunctionType::getNameForCallConv(CurCC);
   // Default adjustment.
@@ -8008,7 +8026,7 @@
         if (VarDecl *Var = dyn_cast<VarDecl>(DRE->getDecl())) {
           QualType T = S.getCapturedDeclRefType(Var, DRE->getLocation());
           if (!T.isNull())
-            return S.Context.getLValueReferenceType(T);
+            return S.Context.getLValueReferenceType(T, /*HonorASPragma*/ true);
         }
       }
     }
@@ -8021,10 +8039,10 @@
   switch (E->getValueKind()) {
   //     - otherwise, if e is an xvalue, decltype(e) is T&&, where T is the
   //       type of e;
-  case VK_XValue: T = S.Context.getRValueReferenceType(T); break;
+  case VK_XValue: T = S.Context.getRValueReferenceType(T, true); break;
   //     - otherwise, if e is an lvalue, decltype(e) is T&, where T is the
   //       type of e;
-  case VK_LValue: T = S.Context.getLValueReferenceType(T); break;
+  case VK_LValue: T = S.Context.getLValueReferenceType(T, true); break;
   //  - otherwise, decltype(e) is the type of e.
   case VK_RValue: break;
   }
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Serialization/ASTReader.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Serialization/ASTReader.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Serialization/ASTReader.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Serialization/ASTReader.cpp	2019-05-19 11:21:51.005903000 +0000
@@ -7322,6 +7322,9 @@
 
   case PREDEF_DECL_TYPE_PACK_ELEMENT_ID:
     return Context.getTypePackElementDecl();
+
+  case PREDEF_DECL_BUILTIN_VA_LIST32_ID:
+    return Context.getBuiltinVaList32Decl();
   }
   llvm_unreachable("PredefinedDeclIDs unknown enum value");
 }
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Serialization/ASTReaderStmt.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Serialization/ASTReaderStmt.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Serialization/ASTReaderStmt.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Serialization/ASTReaderStmt.cpp	2019-05-19 11:21:51.005903000 +0000
@@ -910,7 +910,7 @@
   E->setWrittenTypeInfo(GetTypeSourceInfo());
   E->setBuiltinLoc(ReadSourceLocation());
   E->setRParenLoc(ReadSourceLocation());
-  E->setIsMicrosoftABI(Record.readInt());
+  E->setABIKind(static_cast<VAArgExpr::Kind>(Record.readInt()));
 }
 
 void ASTStmtReader::VisitAddrLabelExpr(AddrLabelExpr *E) {
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Serialization/ASTWriter.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Serialization/ASTWriter.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Serialization/ASTWriter.cpp	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Serialization/ASTWriter.cpp	2019-05-19 11:21:51.005903000 +0000
@@ -4699,6 +4699,8 @@
                      PREDEF_DECL_CF_CONSTANT_STRING_TAG_ID);
   RegisterPredefDecl(Context.TypePackElementDecl,
                      PREDEF_DECL_TYPE_PACK_ELEMENT_ID);
+  RegisterPredefDecl(Context.BuiltinVaList32Decl,
+                     PREDEF_DECL_BUILTIN_VA_LIST32_ID);
 
   // Build a record containing all of the tentative definitions in this file, in
   // TentativeDefinitions order.  Generally, this record will be empty for
diff -rN --unified llvm-toolchain-7-7.0.1/clang/lib/Serialization/ASTWriterStmt.cpp llvm-toolchain-7-7.0.1.patched/clang/lib/Serialization/ASTWriterStmt.cpp
--- llvm-toolchain-7-7.0.1/clang/lib/Serialization/ASTWriterStmt.cpp	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/lib/Serialization/ASTWriterStmt.cpp	2019-05-19 11:21:51.015903000 +0000
@@ -848,7 +848,7 @@
   Record.AddTypeSourceInfo(E->getWrittenTypeInfo());
   Record.AddSourceLocation(E->getBuiltinLoc());
   Record.AddSourceLocation(E->getRParenLoc());
-  Record.push_back(E->isMicrosoftABI());
+  Record.push_back(E->getABIKind());
   Code = serialization::EXPR_VA_ARG;
 }
 
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/debug-info-cc.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/debug-info-cc.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/debug-info-cc.c	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/debug-info-cc.c	2019-05-19 11:21:51.015903000 +0000
@@ -1,4 +1,5 @@
 // RUN: %clang_cc1 -triple x86_64-pc-linux-gnu -o - -emit-llvm -debug-info-kind=limited %s | FileCheck %s --check-prefix=LINUX
+// RUN: %clang_cc1 -triple x86_64-pc-linux-wine32 -o - -emit-llvm -debug-info-kind=limited %s | FileCheck %s --check-prefix=WINE32
 // RUN: %clang_cc1 -triple x86_64-unknown-windows-msvc -o - -emit-llvm -debug-info-kind=limited %s | FileCheck %s --check-prefix=WINDOWS
 // RUN: %clang_cc1 -triple i386-pc-linux-gnu -o - -emit-llvm -debug-info-kind=limited %s | FileCheck %s --check-prefix=LINUX32
 // RUN: %clang_cc1 -triple armv7--linux-gnueabihf -o - -emit-llvm -debug-info-kind=limited %s | FileCheck %s --check-prefix=ARM
@@ -21,6 +22,10 @@
 //    CC_Swift,        // __attribute__((swiftcall))
 //    CC_PreserveMost, // __attribute__((preserve_most))
 //    CC_PreserveAll,  // __attribute__((preserve_all))
+//    CC_X86C32,       // __attribute__((cdecl32))
+//    CC_X86StdCall32, // __attribute__((stdcall32))
+//    CC_X86FastCall32, // __attribute__((fastcall32))
+//    CC_X86ThisCall32, // __attribute__((thiscall32))
 //  };
 
 #ifdef __x86_64__
@@ -61,6 +66,33 @@
 __attribute__((intel_ocl_bicc)) int add_inteloclbicc(int a, int b) {
   return a+b;
 }
+
+#ifdef __i386_on_x86_64__
+// WINE32: !DISubprogram({{.*}}"add_cdecl32", {{.*}}type: ![[FTY:[0-9]+]]
+// WINE32: ![[FTY]] = !DISubroutineType({{.*}}cc: DW_CC_LLVM_C32,
+__attribute__((cdecl32)) int add_cdecl32(int a, int b) {
+  return a+b;
+}
+
+// WINE32: !DISubprogram({{.*}}"add_stdcall32", {{.*}}type: ![[FTY:[0-9]+]]
+// WINE32: ![[FTY]] = !DISubroutineType({{.*}}cc: DW_CC_BORLAND_stdcall,
+__attribute__((stdcall32)) int add_stdcall32(int a, int b) {
+  return a+b;
+}
+
+// WINE32: !DISubprogram({{.*}}"add_fastcall32", {{.*}}type: ![[FTY:[0-9]+]]
+// WINE32: ![[FTY]] = !DISubroutineType({{.*}}cc: DW_CC_BORLAND_msfastcall,
+__attribute__((fastcall32)) int add_fastcall32(int a, int b) {
+  return a+b;
+}
+
+// WINE32: !DISubprogram({{.*}}"add_thiscall32", {{.*}}type: ![[FTY:[0-9]+]]
+// WINE32: ![[FTY]] = !DISubroutineType({{.*}}cc: DW_CC_BORLAND_thiscall,
+__attribute__((thiscall32)) int add_thiscall32(int a, int b) {
+  return a+b;
+}
+#endif
+
 #endif
 
 #ifdef _WIN64
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/function-attributes.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/function-attributes.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/function-attributes.c	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/function-attributes.c	2019-05-19 11:21:51.015903000 +0000
@@ -109,11 +109,18 @@
   _setjmp(0);
 }
 
+// CHECK-LABEL: define void @f21
+// CHECK: [[HOTPATCH:#[0-9]+]]
+// CHECK: {
+void __attribute__((ms_hook_prologue)) f21(void) {
+}
+
 // CHECK: attributes [[NUW]] = { nounwind optsize{{.*}} }
 // CHECK: attributes [[AI]] = { alwaysinline nounwind optsize{{.*}} }
 // CHECK: attributes [[NUW_OS_RN]] = { nounwind optsize readnone{{.*}} }
 // CHECK: attributes [[SR]] = { nounwind optsize{{.*}} "stackrealign"{{.*}} }
 // CHECK: attributes [[RT]] = { nounwind optsize returns_twice{{.*}} }
+// CHECK: attributes [[HOTPATCH]] = { nounwind optsize{{.*}}"patchable-function"="ms-hotpatch"{{.*}} }
 // CHECK: attributes [[NR]] = { noreturn optsize }
 // CHECK: attributes [[NUW_RN]] = { nounwind optsize readnone }
 // CHECK: attributes [[RT_CALL]] = { optsize returns_twice }
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/mingw-long-double.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/mingw-long-double.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/mingw-long-double.c	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/mingw-long-double.c	2019-05-19 11:21:51.015903000 +0000
@@ -45,3 +45,21 @@
 // GNU32: declare dso_local void @__mulxc3
 // GNU64: declare dso_local void @__mulxc3
 // MSC64: declare dso_local void @__muldc3
+
+long double TestLDVA(long double x, ...) {
+  __builtin_va_list ap;
+  __builtin_va_start(ap, x);
+  long double y = __builtin_va_arg(ap, long double);
+  __builtin_va_end(ap);
+  return x * y;
+}
+// GNU32-LABEL: define dso_local x86_fp80 @TestLDVA(x86_fp80 %x, ...)
+// GNU64-LABEL: define dso_local void @TestLDVA(x86_fp80* noalias sret %agg.result, x86_fp80*, ...)
+// GNU64: %[[AP:.*]] = alloca i8*
+// GNU64: call void @llvm.va_start
+// GNU64: %[[AP_CUR:.*]] = load i8*, i8** %[[AP]]
+// GNU64-NEXT: %[[AP_NEXT:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR]], i64 8
+// GNU64-NEXT: store i8* %[[AP_NEXT]], i8** %[[AP]]
+// GNU64-NEXT: %[[CUR:.*]] = bitcast i8* %[[AP_CUR]] to x86_fp80**
+// GNU64-NEXT: load x86_fp80*, x86_fp80** %[[CUR]]
+// MSC64-LABEL: define dso_local double @TestLDVA(double %x, ...)
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/ms_abi.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ms_abi.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/ms_abi.c	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ms_abi.c	2019-05-19 11:21:51.015903000 +0000
@@ -45,12 +45,12 @@
   // WIN64-NEXT: %[[AP_NEXT:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR]], i64 8
   // WIN64-NEXT: store i8* %[[AP_NEXT]], i8** %[[AP]]
   // WIN64-NEXT: bitcast i8* %[[AP_CUR]] to i32*
-  // FIXME: These are different now. We probably need __builtin_ms_va_arg.
   double _Complex c = __builtin_va_arg(ap, double _Complex);
   // FREEBSD: %[[AP_CUR2:.*]] = load i8*, i8** %[[AP]]
-  // FREEBSD-NEXT: %[[AP_NEXT2:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR2]], i64 16
+  // FREEBSD-NEXT: %[[AP_NEXT2:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR2]], i64 8
   // FREEBSD-NEXT: store i8* %[[AP_NEXT2]], i8** %[[AP]]
-  // FREEBSD-NEXT: bitcast i8* %[[AP_CUR2]] to { double, double }*
+  // FREEBSD-NEXT: %[[CUR2:.*]] = bitcast i8* %[[AP_CUR2]] to { double, double }**
+  // FREEBSD-NEXT: load { double, double }*, { double, double }** %[[CUR2]]
   // WIN64: %[[AP_CUR2:.*]] = load i8*, i8** %[[AP]]
   // WIN64-NEXT: %[[AP_NEXT2:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR2]], i64 8
   // WIN64-NEXT: store i8* %[[AP_NEXT2]], i8** %[[AP]]
@@ -58,14 +58,26 @@
   // WIN64-NEXT: load { double, double }*, { double, double }** %[[CUR2]]
   struct foo d = __builtin_va_arg(ap, struct foo);
   // FREEBSD: %[[AP_CUR3:.*]] = load i8*, i8** %[[AP]]
-  // FREEBSD-NEXT: %[[AP_NEXT3:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR3]], i64 16
+  // FREEBSD-NEXT: %[[AP_NEXT3:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR3]], i64 8
   // FREEBSD-NEXT: store i8* %[[AP_NEXT3]], i8** %[[AP]]
-  // FREEBSD-NEXT: bitcast i8* %[[AP_CUR3]] to %[[STRUCT_FOO]]*
+  // FREEBSD-NEXT: %[[CUR3:.*]] = bitcast i8* %[[AP_CUR3]] to %[[STRUCT_FOO]]**
+  // FREEBSD-NEXT: load %[[STRUCT_FOO]]*, %[[STRUCT_FOO]]** %[[CUR3]]
   // WIN64: %[[AP_CUR3:.*]] = load i8*, i8** %[[AP]]
   // WIN64-NEXT: %[[AP_NEXT3:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR3]], i64 8
   // WIN64-NEXT: store i8* %[[AP_NEXT3]], i8** %[[AP]]
-  // WIN64-NEXT: %[[CUR3:.*]] = bitcast i8* %[[AP_CUR3]] to %[[STRUCT_FOO]]*
+  // WIN64-NEXT: %[[CUR3:.*]] = bitcast i8* %[[AP_CUR3]] to %[[STRUCT_FOO]]**
   // WIN64-NEXT: load %[[STRUCT_FOO]]*, %[[STRUCT_FOO]]** %[[CUR3]]
+  __int128 e = __builtin_va_arg(ap, __int128);
+  // FREEBSD: %[[AP_CUR4:.*]] = load i8*, i8** %[[AP]]
+  // FREEBSD-NEXT: %[[AP_NEXT4:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR4]], i64 8
+  // FREEBSD-NEXT: store i8* %[[AP_NEXT4]], i8** %[[AP]]
+  // FREEBSD-NEXT: %[[CUR4:.*]] = bitcast i8* %[[AP_CUR4]] to i128**
+  // FREEBSD-NEXT: load i128*, i128** %[[CUR4]]
+  // WIN64: %[[AP_CUR4:.*]] = load i8*, i8** %[[AP]]
+  // WIN64-NEXT: %[[AP_NEXT4:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR4]], i64 8
+  // WIN64-NEXT: store i8* %[[AP_NEXT4]], i8** %[[AP]]
+  // WIN64-NEXT: %[[CUR4:.*]] = bitcast i8* %[[AP_CUR4]] to i128**
+  // WIN64-NEXT: load i128*, i128** %[[CUR4]]
   __builtin_ms_va_list ap2;
   __builtin_ms_va_copy(ap2, ap);
   // FREEBSD: %[[AP_VAL:.*]] = load i8*, i8** %[[AP]]
@@ -99,6 +111,12 @@
   // WIN64-NEXT: %[[AP_NEXT3:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR3]], i64 8
   // WIN64-NEXT: store i8* %[[AP_NEXT3]], i8** %[[AP]]
   // WIN64-NEXT: bitcast i8* %[[AP_CUR3]] to %[[STRUCT_FOO]]*
+  __int128 e = __builtin_va_arg(ap, __int128);
+  // WIN64: %[[AP_CUR4:.*]] = load i8*, i8** %[[AP]]
+  // WIN64-NEXT: %[[AP_NEXT4:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR4]], i64 8
+  // WIN64-NEXT: store i8* %[[AP_NEXT4]], i8** %[[AP]]
+  // WIN64-NEXT: %[[CUR4:.*]] = bitcast i8* %[[AP_CUR4]] to i128**
+  // WIN64-NEXT: load i128*, i128** %[[CUR4]]
   __builtin_va_list ap2;
   __builtin_va_copy(ap2, ap);
   // WIN64: call void @llvm.va_copy
@@ -123,7 +141,7 @@
   // WIN64-NEXT: bitcast i8* %[[AP_CUR]] to i32*
   double _Complex c = __builtin_va_arg(ap, double _Complex);
   // FREEBSD: %[[AP_CUR2:.*]] = load i8*, i8** %[[AP]]
-  // FREEBSD-NEXT: %[[AP_NEXT2:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR2]], i64 16
+  // FREEBSD-NEXT: %[[AP_NEXT2:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR2]], i64 8
   // FREEBSD-NEXT: store i8* %[[AP_NEXT2]], i8** %[[AP]]
   // FREEBSD-NEXT: bitcast i8* %[[AP_CUR2]] to { double, double }*
   // WIN64: %[[AP_CUR2:.*]] = load i8*, i8** %[[AP]]
@@ -132,13 +150,24 @@
   // WIN64-NEXT: bitcast i8* %[[AP_CUR2]] to { double, double }*
   struct foo d = __builtin_va_arg(ap, struct foo);
   // FREEBSD: %[[AP_CUR3:.*]] = load i8*, i8** %[[AP]]
-  // FREEBSD-NEXT: %[[AP_NEXT3:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR3]], i64 16
+  // FREEBSD-NEXT: %[[AP_NEXT3:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR3]], i64 8
   // FREEBSD-NEXT: store i8* %[[AP_NEXT3]], i8** %[[AP]]
   // FREEBSD-NEXT: bitcast i8* %[[AP_CUR3]] to %[[STRUCT_FOO]]*
   // WIN64: %[[AP_CUR3:.*]] = load i8*, i8** %[[AP]]
   // WIN64-NEXT: %[[AP_NEXT3:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR3]], i64 8
   // WIN64-NEXT: store i8* %[[AP_NEXT3]], i8** %[[AP]]
   // WIN64-NEXT: bitcast i8* %[[AP_CUR3]] to %[[STRUCT_FOO]]*
+  __int128 e = __builtin_va_arg(ap, __int128);
+  // FREEBSD: %[[AP_CUR4:.*]] = load i8*, i8** %[[AP]]
+  // FREEBSD-NEXT: %[[AP_NEXT4:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR4]], i64 8
+  // FREEBSD-NEXT: store i8* %[[AP_NEXT4]], i8** %[[AP]]
+  // FREEBSD-NEXT: %[[CUR4:.*]] = bitcast i8* %[[AP_CUR4]] to i128**
+  // FREEBSD-NEXT: load i128*, i128** %[[CUR4]]
+  // WIN64: %[[AP_CUR4:.*]] = load i8*, i8** %[[AP]]
+  // WIN64-NEXT: %[[AP_NEXT4:.*]] = getelementptr inbounds i8, i8* %[[AP_CUR4]], i64 8
+  // WIN64-NEXT: store i8* %[[AP_NEXT4]], i8** %[[AP]]
+  // WIN64-NEXT: %[[CUR4:.*]] = bitcast i8* %[[AP_CUR4]] to i128**
+  // WIN64-NEXT: load i128*, i128** %[[CUR4]]
   __builtin_ms_va_list ap2;
   __builtin_ms_va_copy(ap2, ap);
   // FREEBSD: %[[AP_VAL:.*]] = load i8*, i8** %[[AP]]
@@ -159,3 +188,11 @@
   // FREEBSD: define win64cc void @f7(%struct.i128* noalias sret %agg.result, %struct.i128* %a)
   return a;
 }
+
+__int128 __attribute__((ms_abi)) f8(__int128 a) {
+  // FREEBSD-LABEL: define win64cc void @f8
+  // FREEBSD-SAME: (i128* noalias sret %agg.result, i128*
+  // WIN64-LABEL: define dso_local void @f8
+  // WIN64-SAME: (i128* noalias sret %agg.result, i128*
+  return a;
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-block-var.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-block-var.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-block-var.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-block-var.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,19 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -fblocks -emit-llvm -o - %s | FileCheck %s
+
+int foo() {
+  __block int bar;
+  return ^{
+    return bar;
+  }();
+
+  // CHECK: %[[BAR:.*]] = addrspacecast %struct.__block_byref_bar addrspace(32)* %{{.*}} to %struct.__block_byref_bar*
+  // CHECK: store %struct.__block_byref_bar* %[[BAR]], %struct.__block_byref_bar* addrspace(32)* %{{.*}}, align 8
+
+  // CHECK: %[[BAR:.*]] = addrspacecast %struct.__block_byref_bar addrspace(32)* %{{.*}} to %struct.__block_byref_bar*
+  // CHECK: %[[CAPTURED:.*]] = bitcast %struct.__block_byref_bar* %[[BAR]] to i8*
+  // CHECK: store i8* %[[CAPTURED]], i8* addrspace(32)* %{{.*}}, align 8
+
+  // CHECK: %[[BAR:.*]] = addrspacecast %struct.__block_byref_bar addrspace(32)* %{{.*}} to %struct.__block_byref_bar*
+  // CHECK: %[[DISPOSED:.*]] = bitcast %struct.__block_byref_bar* %[[BAR]] to i8*
+  // CHECK: call void @_Block_object_dispose(i8* %[[DISPOSED]], i32 8)
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-compound-literal.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-compound-literal.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-compound-literal.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-compound-literal.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,13 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -emit-llvm -o - %s | FileCheck %s
+
+extern int foo(unsigned short* a);
+
+int bar(void) {
+  return foo((unsigned short[]){'f', 'o', 'o', 0});
+}
+
+// CHECK-LABEL: define i32 @bar()
+// CHECK: %[[LITERAL:.*]] = alloca [4 x i16], align 2, addrspace(32)
+// CHECK: %[[DECAY_AS:.*]] = addrspacecast [4 x i16] addrspace(32)* %[[LITERAL]] to [4 x i16]*
+// CHECK: %[[DECAY:.*]] = getelementptr inbounds [4 x i16], [4 x i16]* %[[DECAY_AS]], i32 0, i32 0
+// CHECK: %[[CALL:.*]] = call i32 @foo(i16* %[[DECAY]])
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-default-as.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-default-as.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-default-as.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-default-as.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,13 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -O2 -emit-llvm -o - %s | FileCheck %s
+
+#pragma clang default_addr_space(ptr32)
+#pragma clang storage_addr_space(ptr32)
+
+int x;
+
+void foo(int *a, void (*b)(int, const char *, int *)) {
+  b(*a, "Hello, world!", &x);
+  // CHECK-LABEL: @foo(i32 addrspace(32)*{{.*}} %a, void (i32, i8 addrspace(32)*, i32 addrspace(32)*) addrspace(32)*{{.*}} %b)
+  // CHECK: %[[VAL:[0-9a-zA-Z_]*]] = load i32, i32 addrspace(32)* %a
+  // CHECK: call addrspace(32) void %b(i32 %[[VAL]], i8 addrspace(32)* {{.*}}, i32 addrspace(32)* @x){{.*}}
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-indirect-arg.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-indirect-arg.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-indirect-arg.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-indirect-arg.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,23 @@
+// RUN: %clang_cc1 -triple x86_64-linux-wine32 -emit-llvm -o - %s | FileCheck %s
+
+struct foo {
+  int a;
+};
+
+struct bar {
+  int b;
+  int c;
+  long d;
+  long e;
+};
+
+int __attribute__((thiscall32)) baz(struct foo * __ptr32 f, struct bar b) {
+  return f->a * b.b + b.c - (int)(b.d / b.e);
+  // CHECK-LABEL: define x86_thiscallcc i32 @baz(
+  // CHECK-SAME:, %struct.foo addrspace(32)* %[[F:.*]], %struct.bar addrspace(32)* byval align 4)
+  // CHECK: %[[COERCE:.*]] = alloca %struct.bar, align 8, addrspace(32)
+  // CHECK: %[[DEST:.*]] = bitcast %struct.bar addrspace(32)* %[[COERCE]] to i8 addrspace(32)*
+  // CHECK: %[[SRC:.*]] = bitcast %struct.bar addrspace(32)* %0 to i8 addrspace(32)*
+  // CHECK: call void @llvm.memcpy.p32i8.p32i8.i64(i8 addrspace(32)* align 8 %[[DEST]], i8 addrspace(32)* align 4 %[[SRC]],
+}
+
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-inline-asm.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-inline-asm.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-inline-asm.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-inline-asm.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,14 @@
+// RUN: %clang_cc1 -triple x86_64-unknown-linux-wine32 -emit-llvm -o - %s | FileCheck %s
+
+void foo(void) {
+  unsigned short cw;
+  asm volatile("fnstcw %0" : "=m" (cw));
+  cw = (cw & ~0xf3f) | 0x3f;
+  asm volatile("fldcw %0" : : "m" (cw));
+}
+
+// CHECK-LABEL: define void @foo(
+// CHECK: %[[CAST0:.*]] = addrspacecast i16 addrspace(32)* %[[CW:.*]] to i16*
+// CHECK: call void asm sideeffect "fnstcw $0", "=*m{{.*}}"(i16* %[[CAST0]])
+// CHECK: %[[CAST1:.*]] = addrspacecast i16 addrspace(32)* %[[CW]] to i16*
+// CHECK: call void asm sideeffect "fldcw $0", "*m{{.*}}"(i16* %[[CAST1]])
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-memory-builtins.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-memory-builtins.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-memory-builtins.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-memory-builtins.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,38 @@
+// RUN: %clang_cc1 -triple x86_64-linux-wine32 -emit-llvm -o - %s | FileCheck %s
+
+void *memcpy(void *dest, const void *src, __SIZE_TYPE__ len);
+void *memmove(void *dest, const void *src, __SIZE_TYPE__ len);
+void *memset(void *dest, int v, __SIZE_TYPE__ len);
+
+void foo(const char *src) {
+  char dest[16];
+  char *p;
+  // CHECK: %{{.*}} = alloca i8*, align 8, addrspace(32)
+  // CHECK: %[[P:.*]] = alloca i8*, align 8, addrspace(32)
+
+  p = memcpy(dest, src, 16);
+  // CHECK: call void @llvm.memcpy.p32i8.p0i8.i64(i8 addrspace(32)* align 16 %[[DEST:[^,]*]],
+  // CHECK: %[[TMP:[0-9]+]] = addrspacecast i8 addrspace(32)* %[[DEST]] to i8*
+  // CHECK: store i8* %[[TMP]], i8* addrspace(32)* %[[P]]
+  p = memmove(dest, src, 16);
+  // CHECK: call void @llvm.memmove.p32i8.p0i8.i64(i8 addrspace(32)* align 16 %[[DEST:[^,]*]],
+  // CHECK: %[[TMP:[0-9]+]] = addrspacecast i8 addrspace(32)* %[[DEST]] to i8*
+  // CHECK: store i8* %[[TMP]], i8* addrspace(32)* %[[P]]
+  p = memset(dest, 0xcc, 16);
+  // CHECK: call void @llvm.memset.p32i8.i64(i8 addrspace(32)* align 16 %[[DEST:[^,]*]],
+  // CHECK: %[[TMP:[0-9]+]] = addrspacecast i8 addrspace(32)* %[[DEST]] to i8*
+  // CHECK: store i8* %[[TMP]], i8* addrspace(32)* %[[P]]
+
+  p = __builtin___memcpy_chk(dest, src, 16, __builtin_object_size(dest, 0));
+  // CHECK: call void @llvm.memcpy.p32i8.p0i8.i64(i8 addrspace(32)* align 16 %[[DEST:[^,]*]],
+  // CHECK: %[[TMP:[0-9]+]] = addrspacecast i8 addrspace(32)* %[[DEST]] to i8*
+  // CHECK: store i8* %[[TMP]], i8* addrspace(32)* %[[P]]
+  p = __builtin___memmove_chk(dest, src, 16, __builtin_object_size(dest, 0));
+  // CHECK: call void @llvm.memmove.p32i8.p0i8.i64(i8 addrspace(32)* align 16 %[[DEST:[^,]*]],
+  // CHECK: %[[TMP:[0-9]+]] = addrspacecast i8 addrspace(32)* %[[DEST]] to i8*
+  // CHECK: store i8* %[[TMP]], i8* addrspace(32)* %[[P]]
+  p = __builtin___memset_chk(dest, 0xcc, 16, __builtin_object_size(dest, 0));
+  // CHECK: call void @llvm.memset.p32i8.i64(i8 addrspace(32)* align 16 %[[DEST:[^,]*]],
+  // CHECK: %[[TMP:[0-9]+]] = addrspacecast i8 addrspace(32)* %[[DEST]] to i8*
+  // CHECK: store i8* %[[TMP]], i8* addrspace(32)* %[[P]]
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-ptr64-interop.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-ptr64-interop.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-ptr64-interop.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-ptr64-interop.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,25 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -O2 -emit-llvm -o - %s | FileCheck %s
+
+void foo(int * __ptr32 a, void (* __ptr32 b)(int, int * __ptr32, int *)) {
+  int c;
+  b(*a, &c, &c);
+  // CHECK-LABEL: @foo(i32 addrspace(32)*{{.*}} %a, void (i32, i32 addrspace(32)*, i32*) addrspace(32)*{{.*}} %b)
+  // CHECK: %[[VAL:[0-9a-zA-Z_]*]] = load i32, i32 addrspace(32)* %a
+  // CHECK: call addrspace(32) void %b(i32 %[[VAL]], i32 addrspace(32)* {{.*}}, i32* {{.*}}){{.*}}
+}
+
+void (__attribute__((stdcall32)) * __ptr32 pbar)(int, int * __ptr32);
+void (__attribute__((stdcall32)) * __ptr32 pbaz)(int, int * __ptr32);
+
+extern void __attribute__((stdcall32)) bar(int, int * __ptr32);
+
+#pragma clang ptr32_thunk_prefix("__wine32_")
+extern void __attribute__((stdcall32)) baz(int, int * __ptr32);
+
+void quux(void) {
+  pbar = bar;
+  pbaz = baz;
+  // CHECK-LABEL: @quux()
+  // CHECK: @__i386_on_x86_64_thunk32_bar
+  // CHECK: @__wine32_thunk32_baz
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-struct-ret.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-struct-ret.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/ptr32-struct-ret.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/ptr32-struct-ret.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,20 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -emit-llvm -o - %s | FileCheck %s
+
+struct rect {
+  int left, top, right, bottom;
+};
+
+struct rect __attribute__((ms_abi)) foo(void) {
+  static struct rect rc = { 0, 0, 800, 600 };
+  return rc;
+}
+
+struct rect bar(void) {
+  return foo();
+}
+
+// CHECK-LABEL: define { i64, i64 } @bar()
+// CHECK: %[[RETVAL:.*]] = alloca %struct.rect, align 4, addrspace(32)
+// CHECK: %[[CAST:.*]] = addrspacecast %struct.rect addrspace(32)* %[[RETVAL]] to %struct.rect*
+// CHECK: call win64cc void @foo(%struct.rect* sret %[[CAST]])
+
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/stdcall32-fastcall32.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/stdcall32-fastcall32.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/stdcall32-fastcall32.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/stdcall32-fastcall32.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,163 @@
+// RUN: %clang_cc1 -triple x86_64-unknown-unknown-wine32 -emit-llvm < %s | FileCheck %s
+
+void __attribute__((fastcall32)) f1(void);
+void __attribute__((stdcall32)) f2(void);
+void __attribute__((thiscall32)) f3(void);
+void __attribute__((cdecl32)) f4(void);
+void __attribute__((fastcall32)) f5(void) {
+// CHECK-LABEL: define x86_fastcallcc void @f5({ [6 x i64] } addrspace(32)* noalias thunkdata %thunk.data)
+// CHECK: %thunk.storage = alloca { [6 x i64] }, align 8, addrspace(32)
+  f1();
+// CHECK: call x86_fastcallcc void @f1({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+}
+void __attribute__((stdcall32)) f6(void) {
+// CHECK-LABEL: define x86_stdcallcc void @f6({ [6 x i64] } addrspace(32)* noalias thunkdata %thunk.data)
+// CHECK: %thunk.storage = alloca { [6 x i64] }, align 8, addrspace(32)
+  f2();
+// CHECK: call x86_stdcallcc void @f2({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+}
+void __attribute__((thiscall32)) f7(void) {
+// CHECK-LABEL: define x86_thiscallcc void @f7({ [6 x i64] } addrspace(32)* noalias thunkdata %thunk.data)
+// CHECK: %thunk.storage = alloca { [6 x i64] }, align 8, addrspace(32)
+  f3();
+// CHECK: call x86_thiscallcc void @f3({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+}
+void __attribute__((cdecl32)) f8(void) {
+// CHECK-LABEL: define x86_64_c32cc void @f8({ [6 x i64] } addrspace(32)* noalias thunkdata %thunk.data)
+// CHECK: %thunk.storage = alloca { [6 x i64] }, align 8, addrspace(32)
+  f4();
+// CHECK: call x86_64_c32cc void @f4({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+}
+
+// PR5280
+void (__attribute__((fastcall32)) *pf1)(void) = f1;
+void (__attribute__((stdcall32)) *pf2)(void) = f2;
+void (__attribute__((thiscall32)) *pf3)(void) = f3;
+void (__attribute__((cdecl32)) *pf4)(void) = f4;
+void (__attribute__((fastcall32)) *pf5)(void) = f5;
+void (__attribute__((stdcall32)) *pf6)(void) = f6;
+void (__attribute__((thiscall32)) *pf7)(void) = f7;
+void (__attribute__((cdecl32)) *pf8)(void) = f8;
+
+int main(void) {
+    // CHECK: %thunk.storage = alloca { [6 x i64] }, align 8, addrspace(32)
+    // CHECK-NOT: %thunk.storage = alloca { [6 x i64] }, align 8, addrspace(32)
+    f5(); f6(); f7(); f8();
+    // CHECK: call x86_fastcallcc void @f5({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    // CHECK: call x86_stdcallcc void @f6({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    // CHECK: call x86_thiscallcc void @f7({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    // CHECK: call x86_64_c32cc void @f8({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    pf1(); pf2(); pf3(); pf4(); pf5(); pf6(); pf7(); pf8();
+    // CHECK: call x86_fastcallcc void %{{.*}}({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    // CHECK: call x86_stdcallcc void %{{.*}}({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    // CHECK: call x86_thiscallcc void %{{.*}}({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    // CHECK: call x86_64_c32cc void %{{.*}}({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    // CHECK: call x86_fastcallcc void %{{.*}}({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    // CHECK: call x86_stdcallcc void %{{.*}}({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    // CHECK: call x86_thiscallcc void %{{.*}}({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    // CHECK: call x86_64_c32cc void %{{.*}}({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage)
+    return 0;
+}
+
+// PR7117
+void __attribute((stdcall32)) f9(foo) int foo; {}
+void f10(void) {
+  f9(0);
+  // CHECK: call x86_stdcallcc void @f9({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, i32 0)
+}
+
+void __attribute__((fastcall32)) foo1(int y);
+void bar1(int y) {
+  // CHECK-LABEL: define void @bar1
+  // CHECK: call x86_fastcallcc void @foo1({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, i32 inreg %
+  foo1(y);
+}
+
+struct S1 {
+  int x;
+};
+void __attribute__((fastcall32)) foo2(struct S1 y);
+void bar2(struct S1 y) {
+  // CHECK-LABEL: define void @bar2
+  // CHECK: call x86_fastcallcc void @foo2({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, i32 inreg undef, i32 %
+  foo2(y);
+}
+
+void __attribute__((fastcall32)) foo3(int * __ptr32 y);
+void bar3(int * __ptr32 y) {
+  // CHECK-LABEL: define void @bar3
+  // CHECK: call x86_fastcallcc void @foo3({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, i32 addrspace(32)* inreg %
+  foo3(y);
+}
+
+enum Enum {Eval};
+void __attribute__((fastcall32)) foo4(enum Enum y);
+void bar4(enum Enum y) {
+  // CHECK-LABEL: define void @bar4
+  // CHECK: call x86_fastcallcc void @foo4({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, i32 inreg %
+  foo4(y);
+}
+
+struct S2 {
+  int x1;
+  double x2;
+  double x3;
+};
+void __attribute__((fastcall32)) foo5(struct S2 y);
+void bar5(struct S2 y) {
+  // CHECK-LABEL: define void @bar5
+  // CHECK: call x86_fastcallcc void @foo5({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, %struct.S2 addrspace(32)* byval align 4 %
+  foo5(y);
+}
+
+void __attribute__((fastcall32)) foo6(long long y);
+void bar6(long long y) {
+  // CHECK-LABEL: define void @bar6
+  // CHECK: call x86_fastcallcc void @foo6({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, i64 %
+  foo6(y);
+}
+
+void __attribute__((fastcall32)) foo7(int a, struct S1 b, int c);
+void bar7(int a, struct S1 b, int c) {
+  // CHECK-LABEL: define void @bar7
+  // CHECK: call x86_fastcallcc void @foo7({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, i32 inreg %{{.*}}, i32 %{{.*}}, i32 %{{.*}}
+  foo7(a, b, c);
+}
+
+void __attribute__((fastcall32)) foo8(struct S1 a, int b);
+void bar8(struct S1 a, int b) {
+  // CHECK-LABEL: define void @bar8
+  // CHECK: call x86_fastcallcc void @foo8({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, i32 inreg undef, i32 %{{.*}}, i32 inreg %
+  foo8(a, b);
+}
+
+void __attribute__((fastcall32)) foo9(struct S2 a, int b);
+void bar9(struct S2 a, int b) {
+  // CHECK-LABEL: define void @bar9
+  // CHECK: call x86_fastcallcc void @foo9({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, %struct.S2 addrspace(32)* byval align 4 %{{.*}}, i32 %
+  foo9(a, b);
+}
+
+void __attribute__((fastcall32)) foo10(float y, int x);
+void bar10(float y, int x) {
+  // CHECK-LABEL: define void @bar10
+  // CHECK: call x86_fastcallcc void @foo10({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, float %{{.*}}, i32 inreg %
+  foo10(y, x);
+}
+
+void __attribute__((fastcall32)) foo11(double y, int x);
+void bar11(double y, int x) {
+  // CHECK-LABEL: define void @bar11
+  // CHECK: call x86_fastcallcc void @foo11({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, double %{{.*}}, i32 inreg %
+  foo11(y, x);
+}
+
+struct S3 {
+  float x;
+};
+void __attribute__((fastcall32)) foo12(struct S3 y, int x);
+void bar12(struct S3 y, int x) {
+  // CHECK-LABEL: define void @bar12
+  // CHECK: call x86_fastcallcc void @foo12({ [6 x i64] } addrspace(32)* thunkdata %thunk.storage, float %{{.*}}, i32 inreg %
+  foo12(y, x);
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGen/varargs-64-32-interop.c llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/varargs-64-32-interop.c
--- llvm-toolchain-7-7.0.1/clang/test/CodeGen/varargs-64-32-interop.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGen/varargs-64-32-interop.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,43 @@
+// RUN: %clang_cc1 -triple x86_64-apple-darwin17-wine32 -emit-llvm < %s | FileCheck %s
+
+struct foo {
+  int x;
+  float y;
+  char z;
+};
+// CHECK-DAG: %[[STRUCT_FOO:.*]] = type { i32, float, i8 }
+// CHECK-DAG: %[[VA_LIST:.*]] = type { i8 }
+
+void __attribute__((cdecl32)) foo(int a, ...) {
+  // CHECK-LABEL: define x86_64_c32cc void @foo
+  __builtin_va_list32 ap;
+  __builtin_va_start32(ap, a);
+  // CHECK: %[[AP0:.*]] = alloca %[[VA_LIST]] addrspace(32)*
+  // CHECK: %[[AP0_0:.*]] = addrspacecast %[[VA_LIST]] addrspace(32)* addrspace(32)* %[[AP0]]
+  // CHECK: call void @llvm.va_start
+  int b = __builtin_va_arg(ap, int);
+  // CHECK: %[[AP:.*]] = bitcast %[[VA_LIST]] addrspace(32)* addrspace(32)* %[[AP0]] to i8 addrspace(32)* addrspace(32)*
+  // CHECK-NEXT: %[[AP_CUR:.*]] = load i8 addrspace(32)*, i8 addrspace(32)* addrspace(32)* %[[AP]]
+  // CHECK-NEXT: %[[AP_NEXT:.*]] = getelementptr inbounds i8, i8 addrspace(32)* %[[AP_CUR]], i64 4
+  // CHECK-NEXT: store i8 addrspace(32)* %[[AP_NEXT]], i8 addrspace(32)* addrspace(32)* %[[AP]]
+  // CHECK-NEXT: bitcast i8 addrspace(32)* %[[AP_CUR]] to i32 addrspace(32)*
+  double _Complex c = __builtin_va_arg(ap, double _Complex);
+  // CHECK: %[[AP:.*]] = bitcast %[[VA_LIST]] addrspace(32)* addrspace(32)* %[[AP0]] to i8 addrspace(32)* addrspace(32)*
+  // CHECK-NEXT: %[[AP_CUR:.*]] = load i8 addrspace(32)*, i8 addrspace(32)* addrspace(32)* %[[AP]]
+  // CHECK-NEXT: %[[AP_NEXT:.*]] = getelementptr inbounds i8, i8 addrspace(32)* %[[AP_CUR]], i64 16
+  // CHECK-NEXT: store i8 addrspace(32)* %[[AP_NEXT]], i8 addrspace(32)* addrspace(32)* %[[AP]]
+  // CHECK-NEXT: bitcast i8 addrspace(32)* %[[AP_CUR]] to { double, double } addrspace(32)*
+  struct foo d = __builtin_va_arg(ap, struct foo);
+  // CHECK: %[[AP:.*]] = bitcast %[[VA_LIST]] addrspace(32)* addrspace(32)* %[[AP0]] to i8 addrspace(32)* addrspace(32)*
+  // CHECK-NEXT: %[[AP_CUR:.*]] = load i8 addrspace(32)*, i8 addrspace(32)* addrspace(32)* %[[AP]]
+  // CHECK-NEXT: %[[AP_NEXT:.*]] = getelementptr inbounds i8, i8 addrspace(32)* %[[AP_CUR]], i64 12
+  // CHECK-NEXT: store i8 addrspace(32)* %[[AP_NEXT]], i8 addrspace(32)* addrspace(32)* %[[AP]]
+  // CHECK-NEXT: bitcast i8 addrspace(32)* %[[AP_CUR]] to %[[STRUCT_FOO]] addrspace(32)*
+  __builtin_va_list32 ap2;
+  __builtin_va_copy32(ap2, ap);
+  // CHECK: %[[AP:.*]] = bitcast %[[VA_LIST]] addrspace(32)* addrspace(32)* %[[AP0]] to i8 addrspace(32)* addrspace(32)*
+  // CHECK: %[[AP_VAL:.*]] = load i8 addrspace(32)*, i8 addrspace(32)* addrspace(32)* %[[AP]]
+  // CHECK-NEXT: store i8 addrspace(32)* %[[AP_VAL]], i8 addrspace(32)* addrspace(32)* %[[AP2:.*]]
+  __builtin_va_end32(ap);
+  // CHECK: call void @llvm.va_end
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGenObjC/pragma-ptr32-thunk-prefix-cmdline.m llvm-toolchain-7-7.0.1.patched/clang/test/CodeGenObjC/pragma-ptr32-thunk-prefix-cmdline.m
--- llvm-toolchain-7-7.0.1/clang/test/CodeGenObjC/pragma-ptr32-thunk-prefix-cmdline.m	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGenObjC/pragma-ptr32-thunk-prefix-cmdline.m	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,28 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -emit-llvm -fblocks -minterop64-32-thunk-prefix=__wine32_ -minterop64-32-cs32-name=__wine32_cs32 -minterop64-32-cs64-name=__wine32_cs64 -o - %s | FileCheck %s
+
+#define nil ((id)0)
+
+@interface Foo
++ (instancetype)new;
+- bar: (id (^)())block;
+@end
+
+@implementation Foo
++ (instancetype)new {
+  // CHECK: define internal i8* @"\01+[Foo new]"({{.*}}) #[[ATTR:[0-9]+]]
+  return nil;
+}
+
+- bar: (id (^)())block {
+  // CHECK: define internal i8* @"\01-[Foo bar:]"({{.*}}) #[[ATTR]]
+  return block();
+}
+@end
+
+id baz() {
+  // CHECK: define i8* @baz({{.*}}) #[[ATTR]]
+  // CHECK: define internal i8* @__baz_block_invoke({{.*}}) #[[ATTR]]
+  return [[Foo new] bar: ^{ return nil; }];
+}
+
+// CHECK: attributes #[[ATTR]] = { {{.*}} "thunk-cs32-name"="__wine32_cs32" "thunk-cs64-name"="__wine32_cs64" "thunk-prefix"="__wine32_" {{.*}} }
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGenObjC/pragma-ptr32-thunk-prefix.m llvm-toolchain-7-7.0.1.patched/clang/test/CodeGenObjC/pragma-ptr32-thunk-prefix.m
--- llvm-toolchain-7-7.0.1/clang/test/CodeGenObjC/pragma-ptr32-thunk-prefix.m	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGenObjC/pragma-ptr32-thunk-prefix.m	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,32 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -emit-llvm -fblocks -o - %s | FileCheck %s
+
+#define nil ((id)0)
+
+#pragma clang ptr32_thunk_prefix("__wine32_")
+#pragma clang ptr32_cs32_name("__wine32_cs32")
+#pragma clang ptr32_cs64_name("__wine32_cs64")
+
+@interface Foo
++ (instancetype)new;
+- bar: (id (^)())block;
+@end
+
+@implementation Foo
++ (instancetype)new {
+  // CHECK: define internal i8* @"\01+[Foo new]"({{.*}}) #[[ATTR:[0-9]+]]
+  return nil;
+}
+
+- bar: (id (^)())block {
+  // CHECK: define internal i8* @"\01-[Foo bar:]"({{.*}}) #[[ATTR]]
+  return block();
+}
+@end
+
+id baz() {
+  // CHECK: define i8* @baz({{.*}}) #[[ATTR]]
+  // CHECK: define internal i8* @__baz_block_invoke({{.*}}) #[[ATTR]]
+  return [[Foo new] bar: ^{ return nil; }];
+}
+
+// CHECK: attributes #[[ATTR]] = { {{.*}} "thunk-cs32-name"="__wine32_cs32" "thunk-cs64-name"="__wine32_cs64" "thunk-prefix"="__wine32_" {{.*}} }
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGenObjC/ptr32-fast-enum.m llvm-toolchain-7-7.0.1.patched/clang/test/CodeGenObjC/ptr32-fast-enum.m
--- llvm-toolchain-7-7.0.1/clang/test/CodeGenObjC/ptr32-fast-enum.m	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGenObjC/ptr32-fast-enum.m	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,12 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -emit-llvm -o - %s | FileCheck %s
+
+@class NSArray;
+
+void foo(NSArray* a) {
+  for (id obj in a) {
+    [obj release];
+  }
+  // CHECK: %[[STATE_PTR:.*]] = addrspacecast %struct.__objcFastEnumerationState addrspace(32)* %{{.*}} to %struct.__objcFastEnumerationState*
+  // CHECK: %[[ITEMS_PTR:.*]] = addrspacecast [16 x i8*] addrspace(32)* %{{.*}} to [16 x i8*]*
+  // CHECK: %call = call i64 bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i64 (i8*, i8*, %struct.__objcFastEnumerationState*, [16 x i8*]*, i64)*)(i8* %{{.*}}, i8* %{{.*}}, %struct.__objcFastEnumerationState* %[[STATE_PTR]], [16 x i8*]* %[[ITEMS_PTR]], i64 16)
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGenObjC/ptr32-properties.m llvm-toolchain-7-7.0.1.patched/clang/test/CodeGenObjC/ptr32-properties.m
--- llvm-toolchain-7-7.0.1/clang/test/CodeGenObjC/ptr32-properties.m	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGenObjC/ptr32-properties.m	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,49 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -emit-llvm -o - %s | FileCheck %s
+
+struct Point {
+  double x;
+  double y;
+};
+
+struct Size {
+  double width;
+  double height;
+};
+
+struct Rect {
+  struct Point origin;
+  struct Size size;
+};
+
+@interface Foo {
+  signed char _bar;
+  struct Rect _baz;
+}
+
+@property(readonly) signed char bar;
+@property(readonly) struct Rect baz;
+
+@end
+
+@implementation Foo
+
+@synthesize bar = _bar;
+// CHECK: %[[IVAR:.*]] = load i64, i64* @"OBJC_IVAR_$_Foo._bar", align 8
+// CHECK: %[[IVAR_PTR:.*]] = getelementptr inbounds i8, i8* %{{.*}}, i64 %[[IVAR]]
+// CHECK: %[[VAL:.*]] = load atomic i8, i8* %[[IVAR_PTR]] unordered, align 1
+// CHECK: ret i8 %[[VAL]]
+
+@synthesize baz = _baz;
+
+@end
+
+double quux(Foo *f) {
+  struct Rect baz = [f baz];
+  return baz.size.height;
+  // CHECK: msgSend.call:
+  // CHECK:   %[[SRET:.*]] = addrspacecast %struct.Rect addrspace(32)* %{{.*}} to %struct.Rect*
+  // CHECK:   call void bitcast (void (i8*, i8*, ...)* @objc_msgSend_stret to void (%struct.Rect*, i8*, i8*)*)(%struct.Rect* sret %[[SRET]]
+  // CHECK: msgSend.null-receiver:
+  // CHECK:   %[[DEST:.*]] = bitcast %struct.Rect addrspace(32)* %{{.*}} to i8 addrspace(32)*
+  // CHECK:   call void @llvm.memset.p32i8.i64(i8 addrspace(32)* align 8 %[[DEST]], i8 0, i64 32, i1 false)
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/CodeGenObjC/ptr32-super-call.m llvm-toolchain-7-7.0.1.patched/clang/test/CodeGenObjC/ptr32-super-call.m
--- llvm-toolchain-7-7.0.1/clang/test/CodeGenObjC/ptr32-super-call.m	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/CodeGenObjC/ptr32-super-call.m	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,24 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -emit-llvm -o - %s | FileCheck %s
+
+@interface Foo
+
+- bar;
+
+@end
+
+@interface Baz : Foo
+
+- bar;
+
+@end
+
+@implementation Baz
+
+- bar {
+  return [super bar];
+  // CHECK: %[[SUPER:.*]] = addrspacecast %struct._objc_super addrspace(32)* %{{.*}} to %struct._objc_super
+  // CHECK: %{{.*}} = call i8* bitcast (i8* (%struct._objc_super*, i8*, ...)* @objc_msgSendSuper2 to i8* (%struct._objc_super*, i8*)*)(%struct._objc_super* %[[SUPER]]
+}
+
+@end
+
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Driver/mwine32.c llvm-toolchain-7-7.0.1.patched/clang/test/Driver/mwine32.c
--- llvm-toolchain-7-7.0.1/clang/test/Driver/mwine32.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Driver/mwine32.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,16 @@
+// RUN: %clang -### -target x86_64-apple-darwin17 -mwine32 -c %s 2>&1 | FileCheck %s
+// RUN: %clang -### -target i386-apple-darwin17 -mwine32 -c %s 2>&1 | FileCheck %s
+// RUN: %clang -### -target x86_64-apple-darwin17 -mwine32 -mdefault-address-space=ptr32 -mstorage-address-space=default -msystem-address-space=ptr32 -minterop64-32-thunk-prefix=__wine32_ -minterop64-32-cs32-name=__wine32_cs32 -minterop64-32-cs64-name=__wine32_cs64 -c %s 2>&1 | FileCheck -check-prefix=CHECK-OVER %s
+
+// CHECK: Target: x86_64-apple-darwin17-wine32
+// CHECK: "-triple" "x86_64-apple-macosx10.13.0-wine32"
+// CHECK-SAME: "-mstorage-address-space=ptr32"
+
+// CHECK-OVER: Target: x86_64-apple-darwin17-wine32
+// CHECK-OVER: "-triple" "x86_64-apple-macosx10.13.0-wine32"
+// CHECK-OVER-SAME: "-mdefault-address-space=ptr32"
+// CHECK-OVER-SAME: "-mstorage-address-space=default"
+// CHECK-OVER-SAME: "-msystem-address-space=ptr32"
+// CHECK-OVER-SAME: "-minterop64-32-thunk-prefix=__wine32_"
+// CHECK-OVER-SAME: "-minterop64-32-cs32-name=__wine32_cs32"
+// CHECK-OVER-SAME: "-minterop64-32-cs64-name=__wine32_cs64"
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/PCH/Inputs/va_arg.h llvm-toolchain-7-7.0.1.patched/clang/test/PCH/Inputs/va_arg.h
--- llvm-toolchain-7-7.0.1/clang/test/PCH/Inputs/va_arg.h	2018-12-16 12:04:50.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/PCH/Inputs/va_arg.h	2019-05-19 11:21:51.015903000 +0000
@@ -3,3 +3,9 @@
 typedef __builtin_ms_va_list __ms_va_list;
 #define __ms_va_start(ap, a) __builtin_ms_va_start(ap, a)
 #define __ms_va_end(ap) __builtin_ms_va_end(ap)
+
+#ifdef __i386_on_x86_64__
+typedef __builtin_va_list32 __va_list32;
+#define __va_start32(ap, a) __builtin_va_start32(ap, a)
+#define __va_end32(ap, a) __builtin_va_end32(ap)
+#endif
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/PCH/va_arg32.c llvm-toolchain-7-7.0.1.patched/clang/test/PCH/va_arg32.c
--- llvm-toolchain-7-7.0.1/clang/test/PCH/va_arg32.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/PCH/va_arg32.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,25 @@
+// Test this without pch.
+// RUN: %clang_cc1 -triple=x86_64-unknown-freebsd7.0-wine32 -include %S/va_arg32.h %s -emit-llvm-only
+// REQUIRES: x86-registered-target
+
+// Test with pch.
+// RUN: %clang_cc1 -triple=x86_64-unknown-freebsd7.0-wine32 -emit-pch -o %t %S/va_arg32.h
+// RUN: %clang_cc1 -triple=x86_64-unknown-freebsd7.0-wine32 -include-pch %t %s -emit-llvm-only
+
+char *g0(char** argv, int argc) { return argv[argc]; }
+
+char *g(char **argv) {
+  f(g0, argv, 1, 2, 3);
+}
+
+char *i0(char **argv, int argc) { return argv[argc]; }
+
+char *i(char **argv) {
+  h(i0, argv, 1, 2, 3);
+}
+
+char *k0(char **argv, int argc) { return argv[argc]; }
+
+char *k(char **argv) {
+  j(k0, argv, 1, 2, 3);
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/PCH/va_arg32.cpp llvm-toolchain-7-7.0.1.patched/clang/test/PCH/va_arg32.cpp
--- llvm-toolchain-7-7.0.1/clang/test/PCH/va_arg32.cpp	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/PCH/va_arg32.cpp	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,27 @@
+// Test this without pch.
+// RUN: %clang_cc1 -triple=x86_64-unknown-freebsd7.0-wine32 -include %S/Inputs/va_arg.h %s -emit-llvm-only
+// REQUIRES: x86-registered-target
+
+// Test with pch.
+// RUN: %clang_cc1 -triple=x86_64-unknown-freebsd7.0-wine32 -emit-pch -x c++-header -o %t %S/Inputs/va_arg.h
+// RUN: %clang_cc1 -triple=x86_64-unknown-freebsd7.0-wine32 -include-pch %t %s -emit-llvm-only
+
+typedef __SIZE_TYPE__ size_t;
+
+extern "C" {
+int vsnprintf(char * , size_t, const char * , va_list) ;
+int __attribute__((ms_abi)) wvsprintfA(char *, const char *, __ms_va_list);
+int __attribute__((cdecl32)) wvsprintfA32(char *, const char *, __va_list32);
+}
+
+void f(char *buffer, unsigned count, const char* format, va_list argptr) {
+  vsnprintf(buffer, count, format, argptr);
+}
+
+void g(char *buffer, const char *format, __ms_va_list argptr) {
+  wvsprintfA(buffer, format, argptr);
+}
+
+void h(char *buffer, const char *format, __va_list32 argptr) {
+  wvsprintfA32(buffer, format, argptr);
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/PCH/va_arg32.h llvm-toolchain-7-7.0.1.patched/clang/test/PCH/va_arg32.h
--- llvm-toolchain-7-7.0.1/clang/test/PCH/va_arg32.h	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/PCH/va_arg32.h	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,22 @@
+// Header for PCH test va_arg32.c
+
+typedef __builtin_va_list va_list;
+char *f (char * (*g) (char **, int), char **p, ...) {
+    char *s;
+    va_list v;
+    s = g (p, __builtin_va_arg(v, int));
+}
+
+typedef __builtin_ms_va_list __ms_va_list;
+char *__attribute__((ms_abi)) h(char *(*i)(char **, int), char **p, ...) {
+  char *s;
+  __ms_va_list v;
+  s = i(p, __builtin_va_arg(v, int));
+}
+
+typedef __builtin_va_list32 __va_list32;
+char *__attribute__((cdecl32)) j(char *(*k)(char **, int), char **p, ...) {
+  char *s;
+  __va_list32 v;
+  s = k(p, __builtin_va_arg(v, int));
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Parser/pragma-default-addr-space.cpp llvm-toolchain-7-7.0.1.patched/clang/test/Parser/pragma-default-addr-space.cpp
--- llvm-toolchain-7-7.0.1/clang/test/Parser/pragma-default-addr-space.cpp	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Parser/pragma-default-addr-space.cpp	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,34 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -std=c++11 -fsyntax-only -verify %s
+
+#pragma clang default_addr_space(ptr32)
+#pragma clang default_addr_space(default)
+
+#pragma clang default_addr_space(0)
+#pragma clang default_addr_space(32)
+#pragma clang default_addr_space(0x7ffff0)
+
+#pragma clang default_addr_space(push, ptr32)
+#pragma clang default_addr_space(pop)
+#pragma clang default_addr_space()
+
+#pragma clang default_addr_space(0x800000)  // expected-warning{{expected integer between 0 and 8388597 inclusive}}
+
+// FIXME: Better diagnostics here?
+#pragma clang default_addr_space(global)  // expected-warning{{expected address space name}}
+#pragma clang default_addr_space(local)  // expected-warning{{expected address space name}}
+#pragma clang default_addr_space(constant)  // expected-warning{{expected address space name}}
+#pragma clang default_addr_space(generic)  // expected-warning{{expected address space name}}
+#pragma clang default_addr_space(device)  // expected-warning{{expected address space name}}
+#pragma clang default_addr_space(shared)  // expected-warning{{expected address space name}}
+
+#pragma clang default_addr_space(goto)  // expected-warning{{expected identifier or integer}}
+
+#pragma clang default_addr_space(push)  // expected-warning{{expected ')' or ','}}
+#pragma clang default_addr_space(pop, ptr32)  // expected-warning{{missing ')' after}}
+
+#pragma clang default_addr_space foo  // expected-warning{{missing '(' after}}
+#pragma clang default_addr_space(default  // expected-warning{{missing ')' after}}
+#pragma clang default_addr_space(pop  // expected-warning{{missing ')' after}}
+#pragma clang default_addr_space(  // expected-warning{{expected identifier or integer}}
+
+#pragma clang default_addr_space(default) foo  // expected-warning{{extra tokens at end}}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Parser/pragma-ptr32-thunk-prefix.c llvm-toolchain-7-7.0.1.patched/clang/test/Parser/pragma-ptr32-thunk-prefix.c
--- llvm-toolchain-7-7.0.1/clang/test/Parser/pragma-ptr32-thunk-prefix.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Parser/pragma-ptr32-thunk-prefix.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,40 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -std=c11 -fsyntax-only -verify %s
+
+#pragma clang ptr32_thunk_prefix("__foo")
+#pragma clang ptr32_thunk_prefix("")
+
+#pragma clang ptr32_thunk_prefix(goto)  // expected-warning{{expected string literal}}
+
+#pragma clang ptr32_thunk_prefix(foo)  // expected-warning{{expected string literal}}
+
+#pragma clang ptr32_thunk_prefix "__bar"  // expected-warning{{missing '(' after}}
+#pragma clang ptr32_thunk_prefix("__baz"  // expected-warning{{missing ')' after}}
+#pragma clang ptr32_thunk_prefix(  // expected-warning{{expected string literal}}
+
+#pragma clang ptr32_thunk_prefix("__quux") foo  // expected-warning{{extra tokens at end}}
+
+#pragma clang ptr32_cs32_name("__foo")
+#pragma clang ptr32_cs32_name("")
+
+#pragma clang ptr32_cs32_name(goto)  // expected-warning{{expected string literal}}
+
+#pragma clang ptr32_cs32_name(foo)  // expected-warning{{expected string literal}}
+
+#pragma clang ptr32_cs32_name "__bar"  // expected-warning{{missing '(' after}}
+#pragma clang ptr32_cs32_name("__baz"  // expected-warning{{missing ')' after}}
+#pragma clang ptr32_cs32_name(  // expected-warning{{expected string literal}}
+
+#pragma clang ptr32_cs32_name("__quux") foo  // expected-warning{{extra tokens at end}}
+
+#pragma clang ptr32_cs64_name("__foo")
+#pragma clang ptr32_cs64_name("")
+
+#pragma clang ptr32_cs64_name(goto)  // expected-warning{{expected string literal}}
+
+#pragma clang ptr32_cs64_name(foo)  // expected-warning{{expected string literal}}
+
+#pragma clang ptr32_cs64_name "__bar"  // expected-warning{{missing '(' after}}
+#pragma clang ptr32_cs64_name("__baz"  // expected-warning{{missing ')' after}}
+#pragma clang ptr32_cs64_name(  // expected-warning{{expected string literal}}
+
+#pragma clang ptr32_cs64_name("__quux") foo  // expected-warning{{extra tokens at end}}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Preprocessor/init.c llvm-toolchain-7-7.0.1.patched/clang/test/Preprocessor/init.c
--- llvm-toolchain-7-7.0.1/clang/test/Preprocessor/init.c	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Preprocessor/init.c	2019-05-19 11:21:51.015903000 +0000
@@ -10434,3 +10434,10 @@
 // RISCV64-LINUX: #define __unix__ 1
 // RISCV64-LINUX: #define linux 1
 // RISCV64-LINUX: #define unix 1
+//
+// RUN: %clang_cc1 -E -dM -x c < /dev/null 2>&1 \
+// RUN:     -triple x86_64-apple-macosx10.13.0-wine32 \
+// RUN:   | FileCheck -match-full-lines %s -check-prefix=WINE32
+// WINE32: #define __i386_on_x86_64__ 1
+// WINE32: #define __x86_64 1
+// WINE32: #define __x86_64__ 1
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Sema/Inputs/ptr32-system-as.h llvm-toolchain-7-7.0.1.patched/clang/test/Sema/Inputs/ptr32-system-as.h
--- llvm-toolchain-7-7.0.1/clang/test/Sema/Inputs/ptr32-system-as.h	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Sema/Inputs/ptr32-system-as.h	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,3 @@
+// This should still be eight bytes.
+typedef void *system_pointer;
+extern int quux;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Sema/attr-ms-hook-prologue-wrong-arch.c llvm-toolchain-7-7.0.1.patched/clang/test/Sema/attr-ms-hook-prologue-wrong-arch.c
--- llvm-toolchain-7-7.0.1/clang/test/Sema/attr-ms-hook-prologue-wrong-arch.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Sema/attr-ms-hook-prologue-wrong-arch.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,6 @@
+// RUN: %clang_cc1 -triple s390x-unknown-linux -fms-extensions -fsyntax-only -verify %s
+
+// expected-warning@+1{{unknown attribute 'ms_hook_prologue' ignored}}
+int __attribute__((ms_hook_prologue)) foo(int a, int b) {
+  return a+b;
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Sema/attr-ms-hook-prologue.c llvm-toolchain-7-7.0.1.patched/clang/test/Sema/attr-ms-hook-prologue.c
--- llvm-toolchain-7-7.0.1/clang/test/Sema/attr-ms-hook-prologue.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Sema/attr-ms-hook-prologue.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,22 @@
+// RUN: %clang_cc1 -triple i386-pc-linux -fms-extensions -fsyntax-only -verify %s
+
+int __attribute__((ms_hook_prologue)) foo(int a, int b) {
+  return a+b;
+}
+
+// expected-note@+2{{conflicting attribute is here}}
+// expected-error@+1{{'ms_hook_prologue' and 'naked' attributes are not compatible}}
+__declspec(naked) int __attribute__((ms_hook_prologue)) bar(int a, int b) {
+}
+
+// expected-note@+2{{conflicting attribute is here}}
+// expected-error@+1{{'ms_hook_prologue' and '__forceinline' attributes are not compatible}}
+__forceinline int __attribute__((ms_hook_prologue)) baz(int a, int b) {
+  return a-b;
+}
+
+// expected-warning@+1{{'ms_hook_prologue' attribute only applies to functions}}
+int x __attribute__((ms_hook_prologue));
+
+// expected-error@+1{{'ms_hook_prologue' attribute takes no arguments}}
+int f(int a, int b) __attribute__((ms_hook_prologue(2)));
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Sema/ptr32-default-as-cmdline.c llvm-toolchain-7-7.0.1.patched/clang/test/Sema/ptr32-default-as-cmdline.c
--- llvm-toolchain-7-7.0.1/clang/test/Sema/ptr32-default-as-cmdline.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Sema/ptr32-default-as-cmdline.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,57 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -mdefault-address-space=ptr32 -mstorage-address-space=ptr32 -isystem %S/Inputs -fsyntax-only -verify %s
+
+#include <ptr32-system-as.h>
+
+extern void * p32;
+extern void * __ptr64 p64;
+
+_Static_assert(sizeof(void *) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(_Alignof(void *) == 4, "__ptr32 should be aligned to 4 bytes!");
+_Static_assert(sizeof(void * __ptr64) == 8, "__ptr64 should be 8 bytes long!");
+_Static_assert(_Alignof(void * __ptr64) == 8, "__ptr64 should be aligned to 8 bytes!");
+_Static_assert(sizeof(p32) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(sizeof(&p32) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(sizeof(p64) == 8, "__ptr64 should be 8 bytes long!");
+_Static_assert(sizeof(&p64) == 4, "__ptr32 should be 4 bytes long!");
+
+_Static_assert(sizeof(system_pointer) == 8, "Pointer from system header should be 8 bytes long!");
+_Static_assert(_Alignof(system_pointer) == 8, "Pointer from system header should be aligned to 8 bytes!");
+_Static_assert(sizeof(&quux) == 8, "Pointer from system header should be aligned to 8 bytes!");
+
+#pragma clang default_addr_space(push, default)
+
+int bar;
+
+_Static_assert(sizeof(void *) == 8, "__ptr64 should be 8 bytes long!");
+_Static_assert(_Alignof(void *) == 8, "__ptr64 should be aligned to 8 bytes!");
+_Static_assert(sizeof(p32) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(sizeof(p64) == 8, "__ptr64 should be 8 bytes long!");
+_Static_assert(sizeof(&bar) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(sizeof(&quux) == 8, "Pointer from system header should be aligned to 8 bytes!");
+
+#pragma clang default_addr_space()
+
+_Static_assert(sizeof(void *) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(_Alignof(void *) == 4, "__ptr32 should be aligned to 4 bytes!");
+_Static_assert(sizeof(&bar) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(sizeof(&quux) == 8, "Pointer from system header should be aligned to 8 bytes!");
+
+#pragma clang storage_addr_space(push, default)
+
+int baz;
+
+_Static_assert(sizeof(void *) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(_Alignof(void *) == 4, "__ptr32 should be aligned to 4 bytes!");
+_Static_assert(sizeof(&bar) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(sizeof(&baz) == 8, "__ptr64 should be 8 bytes long!");
+_Static_assert(sizeof(&quux) == 8, "Pointer from system header should be aligned to 8 bytes!");
+
+#pragma clang storage_addr_space(pop)
+
+void foo() {
+  void *p = p64;
+  // expected-error@-1{{initializing 'void *' with an expression of type 'void * __ptr64 ' changes address space of pointer}}
+  p = p32;  // no-warning
+  p32 = p64;
+  // expected-error@-1{{assigning 'void * __ptr64 ' to 'void *' changes address space of pointer}}
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Sema/ptr32-default-as.c llvm-toolchain-7-7.0.1.patched/clang/test/Sema/ptr32-default-as.c
--- llvm-toolchain-7-7.0.1/clang/test/Sema/ptr32-default-as.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Sema/ptr32-default-as.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,33 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -isystem %S/Inputs -fsyntax-only -verify %s
+
+#pragma clang default_addr_space(push, ptr32)
+
+#include <ptr32-system-as.h>
+
+extern void * p32;
+extern void * __ptr64 p64;
+
+_Static_assert(sizeof(void *) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(_Alignof(void *) == 4, "__ptr32 should be aligned to 4 bytes!");
+_Static_assert(sizeof(void * __ptr64) == 8, "__ptr64 should be 8 bytes long!");
+_Static_assert(_Alignof(void * __ptr64) == 8, "__ptr64 should be aligned to 8 bytes!");
+
+_Static_assert(sizeof(system_pointer) == 8, "Pointer from system header should be 8 bytes long!");
+_Static_assert(_Alignof(system_pointer) == 8, "Pointer from system header should be aligned to 8 bytes!");
+_Static_assert(sizeof(system_pointer*) == 8, "Pointer from system header should be 8 bytes long!");
+_Static_assert(_Alignof(system_pointer*) == 8, "Pointer from system header should be aligned to 8 bytes!");
+
+#pragma clang default_addr_space(pop)
+
+_Static_assert(sizeof(void *) == 8, "__ptr64 should be 8 bytes long!");
+_Static_assert(_Alignof(void *) == 8, "__ptr64 should be aligned to 8 bytes!");
+_Static_assert(sizeof(p64) == 8, "__ptr64 should be 8 bytes long!");
+
+void foo() {
+  void *p = p64;  // no-warning
+  // It should be possible to convert 32->64...
+  p = p32;  // no-warning
+  // ...but not 64->32.
+  p32 = p64;
+  // expected-error@-1{{assigning 'void * __ptr64' to 'void *' changes address space of pointer}}
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Sema/ptr32-ptr64-interop.c llvm-toolchain-7-7.0.1.patched/clang/test/Sema/ptr32-ptr64-interop.c
--- llvm-toolchain-7-7.0.1/clang/test/Sema/ptr32-ptr64-interop.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Sema/ptr32-ptr64-interop.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,37 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -fsyntax-only -verify %s
+
+extern void * __ptr32 p32;
+extern void * __ptr64 p64;
+
+_Static_assert(sizeof(void * __ptr32) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(_Alignof(void * __ptr32) == 4, "__ptr32 should be aligned to 4 bytes!");
+_Static_assert(sizeof(void * __ptr64) == 8, "__ptr64 should be 8 bytes long!");
+_Static_assert(_Alignof(void * __ptr64) == 8, "__ptr64 should be aligned to 8 bytes!");
+
+extern void bar(int * __ptr32);
+extern void baz(int *);
+
+typedef void (__attribute__((stdcall32))* __ptr32 fp32)(int * __ptr32);
+fp32 pquux;
+extern void __attribute__((stdcall32)) quux(int * __ptr32);
+
+void foo() {
+  void *p = p64;  // no-warning
+  // It should be possible to convert 32->64...
+  p = p32;  // no-warning
+  // ...but not 64->32.
+  p32 = p64;
+  // expected-error@-1{{assigning 'void * __ptr64' to 'void * __ptr32' changes address space of pointer}}
+  // By default, stack variables in this environment are placed in the low
+  // 4 GB (i.e. they're __ptr32). Test that we can pass addresses of stack
+  // variables around as though they were __ptr32.
+  int x;
+  bar(&x);  // no-warning
+  baz(&x);  // no-warning
+  // It is possible to downcast 64-bit function pointers with a 32-bit
+  // convention to a 32-bit pointer.
+  if (pquux != quux)  // no-warning
+    pquux = quux;  // no-warning
+  fp32 blah = quux;  // no-warning
+  fp32 blah2 = (fp32)quux;  // no-warning
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Sema/ptr32-system-as-cmdline.c llvm-toolchain-7-7.0.1.patched/clang/test/Sema/ptr32-system-as-cmdline.c
--- llvm-toolchain-7-7.0.1/clang/test/Sema/ptr32-system-as-cmdline.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Sema/ptr32-system-as-cmdline.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,17 @@
+// RUN: %clang_cc1 -triple x86_64-apple-macosx10.13.0-wine32 -msystem-address-space=ptr32 -isystem %S/Inputs -fsyntax-only -verify %s
+// expected-no-diagnostics
+
+#include <ptr32-system-as.h>
+
+extern void * __ptr32 p32;
+extern void * p64;
+
+_Static_assert(sizeof(void * __ptr32) == 4, "__ptr32 should be 4 bytes long!");
+_Static_assert(_Alignof(void * __ptr32) == 4, "__ptr32 should be aligned to 4 bytes!");
+_Static_assert(sizeof(void *) == 8, "__ptr64 should be 8 bytes long!");
+_Static_assert(_Alignof(void *) == 8, "__ptr64 should be aligned to 8 bytes!");
+_Static_assert(sizeof(p32) == 4, "__ptr32 should be 4 bytes long!");
+
+_Static_assert(sizeof(system_pointer) == 4, "Pointer from system header should be 4 bytes long!");
+_Static_assert(_Alignof(system_pointer) == 4, "Pointer from system header should be aligned to 4 bytes!");
+
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Sema/stdcall32-fastcall32-x64.c llvm-toolchain-7-7.0.1.patched/clang/test/Sema/stdcall32-fastcall32-x64.c
--- llvm-toolchain-7-7.0.1/clang/test/Sema/stdcall32-fastcall32-x64.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Sema/stdcall32-fastcall32-x64.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,20 @@
+// RUN: %clang_cc1 -fsyntax-only -verify -m64-32-interop -triple x86_64-pc-linux-gnu %s
+
+// CC qualifier can be applied only to functions
+int __attribute__((stdcall32)) var1; // expected-warning{{'stdcall32' only applies to function types; type here is 'int'}}
+int __attribute__((fastcall32)) var2; // expected-warning{{'fastcall32' only applies to function types; type here is 'int'}}
+
+// Different CC qualifiers are not compatible
+void __attribute__((stdcall32, fastcall32)) foo3(void); // expected-warning{{calling convention 'stdcall32' ignored for this target}} expected-warning {{calling convention 'fastcall32' ignored for this target}}
+void __attribute__((stdcall32)) foo4(); // expected-warning{{calling convention 'stdcall32' ignored for this target}}
+void __attribute__((fastcall32)) foo4(void); // expected-warning {{calling convention 'fastcall32' ignored for this target}}
+
+// rdar://8876096
+void rdar8876096foo1(int i, int j) __attribute__((fastcall32, cdecl32)); // expected-warning{{calling convention 'fastcall32' ignored for this target}} expected-warning {{calling convention 'cdecl32' ignored for this target}}
+void rdar8876096foo2(int i, int j) __attribute__((fastcall32, stdcall32)); // expected-warning{{calling convention 'stdcall32' ignored for this target}} expected-warning {{calling convention 'fastcall32' ignored for this target}}
+void rdar8876096foo3(int i, int j) __attribute__((fastcall32, regparm(2))); // expected-warning {{calling convention 'fastcall32' ignored for this target}}
+void rdar8876096foo4(int i, int j) __attribute__((stdcall32, cdecl32)); // expected-warning{{calling convention 'stdcall32' ignored for this target}} expected-warning {{calling convention 'cdecl32' ignored for this target}}
+void rdar8876096foo5(int i, int j) __attribute__((stdcall32, fastcall32)); // expected-warning{{calling convention 'stdcall32' ignored for this target}} expected-warning {{calling convention 'fastcall32' ignored for this target}}
+void rdar8876096foo6(int i, int j) __attribute__((cdecl32, fastcall32)); // expected-warning {{calling convention 'cdecl32' ignored for this target}} expected-warning {{calling convention 'fastcall32' ignored for this target}}
+void rdar8876096foo7(int i, int j) __attribute__((cdecl32, stdcall32)); // expected-warning {{calling convention 'cdecl32' ignored for this target}} expected-warning{{calling convention 'stdcall32' ignored for this target}}
+void rdar8876096foo8(int i, int j) __attribute__((regparm(2), fastcall32)); // expected-warning {{calling convention 'fastcall32' ignored for this target}}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Sema/stdcall32-fastcall32.c llvm-toolchain-7-7.0.1.patched/clang/test/Sema/stdcall32-fastcall32.c
--- llvm-toolchain-7-7.0.1/clang/test/Sema/stdcall32-fastcall32.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Sema/stdcall32-fastcall32.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,20 @@
+// RUN: %clang_cc1 -fsyntax-only -verify -triple x86_64-apple-darwin10-wine32 %s
+
+// CC qualifier can be applied only to functions
+int __attribute__((stdcall32)) var1; // expected-warning{{'stdcall32' only applies to function types; type here is 'int'}}
+int __attribute__((fastcall32)) var2; // expected-warning{{'fastcall32' only applies to function types; type here is 'int'}}
+
+// Different CC qualifiers are not compatible
+void __attribute__((stdcall32, fastcall32)) foo3(void); // expected-error{{fastcall32 and stdcall32 attributes are not compatible}}
+void __attribute__((stdcall32)) foo4(); // expected-note{{previous declaration is here}} expected-error{{function with no prototype cannot use the stdcall32 calling convention}}
+void __attribute__((fastcall32)) foo4(void); // expected-error{{function declared 'fastcall32' here was previously declared 'stdcall32'}}
+
+// rdar://8876096
+void rdar8876096foo1(int i, int j) __attribute__((fastcall32, cdecl32)); // expected-error {{not compatible}}
+void rdar8876096foo2(int i, int j) __attribute__((fastcall32, stdcall32)); // expected-error {{not compatible}}
+void rdar8876096foo3(int i, int j) __attribute__((fastcall32, regparm(2))); // expected-error {{not compatible}}
+void rdar8876096foo4(int i, int j) __attribute__((stdcall32, cdecl32)); // expected-error {{not compatible}}
+void rdar8876096foo5(int i, int j) __attribute__((stdcall32, fastcall32)); // expected-error {{not compatible}}
+void rdar8876096foo6(int i, int j) __attribute__((cdecl32, fastcall32)); // expected-error {{not compatible}}
+void rdar8876096foo7(int i, int j) __attribute__((cdecl32, stdcall32)); // expected-error {{not compatible}}
+void rdar8876096foo8(int i, int j) __attribute__((regparm(2), fastcall32)); // expected-error {{not compatible}}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Sema/varargs-wine32.c llvm-toolchain-7-7.0.1.patched/clang/test/Sema/varargs-wine32.c
--- llvm-toolchain-7-7.0.1/clang/test/Sema/varargs-wine32.c	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Sema/varargs-wine32.c	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,181 @@
+// RUN: %clang_cc1 -fsyntax-only -verify %s -m64-32-interop -triple x86_64-apple-darwin9-wine32
+
+// rdar://6726818
+void f1() {
+  const __builtin_va_list args2;
+  (void)__builtin_va_arg(args2, int); // expected-error {{first argument to 'va_arg' is of type 'const __builtin_va_list' and not 'va_list'}}
+}
+
+void f2(int a, ...) {
+  __builtin_ms_va_list ap;
+  __builtin_va_list32 ap32;
+  __builtin_ms_va_start(ap, a); // expected-error {{'__builtin_ms_va_start' used in System V ABI function}}
+  __builtin_va_start32(ap, a); // expected-error {{'__builtin_va_start32' used in System V ABI function}}
+}
+
+void __attribute__((ms_abi)) g1(int a) {
+  __builtin_ms_va_list ap;
+
+  __builtin_ms_va_start(ap, a, a); // expected-error {{too many arguments to function}}
+  __builtin_ms_va_start(ap, a); // expected-error {{'va_start' used in function with fixed args}}
+}
+
+void __attribute__((ms_abi)) g2(int a, int b, ...) {
+  __builtin_ms_va_list ap;
+
+  __builtin_ms_va_start(ap, 10); // expected-warning {{second argument to 'va_start' is not the last named parameter}}
+  __builtin_ms_va_start(ap, a); // expected-warning {{second argument to 'va_start' is not the last named parameter}}
+  __builtin_ms_va_start(ap, b);
+}
+
+void __attribute__((ms_abi)) g3(float a, ...) { // expected-note 2{{parameter of type 'float' is declared here}}
+  __builtin_ms_va_list ap;
+
+  __builtin_ms_va_start(ap, a); // expected-warning {{passing an object that undergoes default argument promotion to 'va_start' has undefined behavior}}
+  __builtin_ms_va_start(ap, (a)); // expected-warning {{passing an object that undergoes default argument promotion to 'va_start' has undefined behavior}}
+}
+
+void __attribute__((ms_abi)) g5() {
+  __builtin_ms_va_list ap;
+  __builtin_ms_va_start(ap, ap); // expected-error {{'va_start' used in function with fixed args}}
+}
+
+void __attribute__((ms_abi)) g6(int a, ...) {
+  __builtin_ms_va_list ap;
+  __builtin_ms_va_start(ap); // expected-error {{too few arguments to function}}
+}
+
+void __attribute__((ms_abi))
+bar(__builtin_ms_va_list authors, ...) {
+  __builtin_ms_va_start(authors, authors);
+  (void)__builtin_va_arg(authors, int);
+  __builtin_ms_va_end(authors);
+}
+
+void __attribute__((ms_abi)) g7(int a, ...) {
+  __builtin_ms_va_list ap;
+  __builtin_ms_va_start(ap, a);
+  // FIXME: This error message is sub-par.
+  __builtin_va_arg(ap, int) = 1; // expected-error {{expression is not assignable}}
+  int *x = &__builtin_va_arg(ap, int); // expected-error {{cannot take the address of an rvalue}}
+  __builtin_ms_va_end(ap);
+}
+
+void __attribute__((ms_abi)) g8(int a, ...) {
+  __builtin_ms_va_list ap;
+  __builtin_ms_va_start(ap, a);
+  (void)__builtin_va_arg(ap, void); // expected-error {{second argument to 'va_arg' is of incomplete type 'void'}}
+  __builtin_ms_va_end(ap);
+}
+
+enum E { x = -1, y = 2, z = 10000 };
+void __attribute__((ms_abi)) g9(__builtin_ms_va_list args) {
+  (void)__builtin_va_arg(args, float); // expected-warning {{second argument to 'va_arg' is of promotable type 'float'}}
+  (void)__builtin_va_arg(args, enum E); // no-warning
+  (void)__builtin_va_arg(args, short); // expected-warning {{second argument to 'va_arg' is of promotable type 'short'}}
+  (void)__builtin_va_arg(args, char); // expected-warning {{second argument to 'va_arg' is of promotable type 'char'}}
+}
+
+void __attribute__((ms_abi)) g10(int a, ...) {
+  __builtin_va_list ap;
+  __builtin_va_list32 ap32;
+  __builtin_va_start(ap, a); // expected-error {{'va_start' used in Win64 ABI function}}
+  __builtin_va_start32(ap32, a); // expected-error {{'__builtin_va_start32' used in Win64 ABI function}}
+}
+
+void __attribute__((cdecl32)) h1(int a) {
+  __builtin_va_list32 ap;
+
+  __builtin_va_start32(ap, a, a); // expected-error {{too many arguments to function}}
+  __builtin_va_start32(ap, a); // expected-error {{'va_start' used in function with fixed args}}
+}
+
+void __attribute__((cdecl32)) h2(int a, int b, ...) {
+  __builtin_va_list32 ap;
+
+  __builtin_va_start32(ap, 10); // expected-warning {{second argument to 'va_start' is not the last named parameter}}
+  __builtin_va_start32(ap, a); // expected-warning {{second argument to 'va_start' is not the last named parameter}}
+  __builtin_va_start32(ap, b);
+}
+
+void __attribute__((cdecl32)) h3(float a, ...) { // expected-note 2{{parameter of type 'float' is declared here}}
+  __builtin_va_list32 ap;
+
+  __builtin_va_start32(ap, a); // expected-warning {{passing an object that undergoes default argument promotion to 'va_start' has undefined behavior}}
+  __builtin_va_start32(ap, (a)); // expected-warning {{passing an object that undergoes default argument promotion to 'va_start' has undefined behavior}}
+}
+
+void __attribute__((cdecl32)) h5() {
+  __builtin_va_list32 ap;
+  __builtin_va_start32(ap, ap); // expected-error {{'va_start' used in function with fixed args}}
+}
+
+void __attribute__((cdecl32)) h6(int a, ...) {
+  __builtin_va_list32 ap;
+  __builtin_va_start32(ap); // expected-error {{too few arguments to function}}
+}
+
+void __attribute__((cdecl32))
+baz(__builtin_va_list32 authors, ...) {
+  __builtin_va_start32(authors, authors);
+  (void)__builtin_va_arg(authors, int);
+  __builtin_va_end32(authors);
+}
+
+void __attribute__((cdecl32)) h7(int a, ...) {
+  __builtin_va_list32 ap;
+  __builtin_va_start32(ap, a);
+  // FIXME: This error message is sub-par.
+  __builtin_va_arg(ap, int) = 1; // expected-error {{expression is not assignable}}
+  int *x = &__builtin_va_arg(ap, int); // expected-error {{cannot take the address of an rvalue}}
+  __builtin_va_end32(ap);
+}
+
+void __attribute__((cdecl32)) h8(int a, ...) {
+  __builtin_va_list32 ap;
+  __builtin_va_start32(ap, a);
+  (void)__builtin_va_arg(ap, void); // expected-error {{second argument to 'va_arg' is of incomplete type 'void'}}
+  __builtin_va_end32(ap);
+}
+
+void __attribute__((cdecl32)) h9(__builtin_va_list32 args) {
+  (void)__builtin_va_arg(args, float); // expected-warning {{second argument to 'va_arg' is of promotable type 'float'}}
+  (void)__builtin_va_arg(args, enum E); // no-warning
+  (void)__builtin_va_arg(args, short); // expected-warning {{second argument to 'va_arg' is of promotable type 'short'}}
+  (void)__builtin_va_arg(args, char); // expected-warning {{second argument to 'va_arg' is of promotable type 'char'}}
+}
+
+void __attribute__((cdecl32)) h10(int a, ...) {
+  __builtin_va_list ap;
+  __builtin_ms_va_list mp;
+  __builtin_va_start(ap, a); // expected-error {{'va_start' used in 32-bit ABI function}}
+  __builtin_ms_va_start(mp, a); // expected-error {{'__builtin_ms_va_start' used in 32-bit ABI function}}
+}
+
+void i1(__builtin_va_list ap) {
+  (void)__builtin_va_arg(ap, int);  // no-warning
+}
+
+void i2(__builtin_ms_va_list ap) {
+  (void)__builtin_va_arg(ap, int);  // no-warning
+}
+
+void i3(__builtin_va_list32 ap) {
+  (void)__builtin_va_arg(ap, int);  // no-warning
+}
+
+struct foo {
+  __builtin_ms_va_list list;
+};
+
+void i4(struct foo *f) {
+  (void)__builtin_va_arg(f->list, int);  // no-warning
+}
+
+struct bar {
+  __builtin_va_list32 list;
+};
+
+void i5(struct bar *b) {
+  (void)__builtin_va_arg(b->list, int);  // no-warning
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/Sema/varargs-x86-32.c llvm-toolchain-7-7.0.1.patched/clang/test/Sema/varargs-x86-32.c
--- llvm-toolchain-7-7.0.1/clang/test/Sema/varargs-x86-32.c	2018-12-16 12:04:51.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/Sema/varargs-x86-32.c	2019-05-19 11:21:51.015903000 +0000
@@ -2,4 +2,5 @@
 
 void foo(int a, ...) {
   __builtin_ms_va_start((void *)0, a); // expected-error {{this builtin is only available on x86-64 and aarch64 targets}}
+  __builtin_va_start32((void *)0, a); // expected-error {{this builtin is only available on Wine32 targets}}
 }
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/SemaCXX/default-addr-space-overload.cpp llvm-toolchain-7-7.0.1.patched/clang/test/SemaCXX/default-addr-space-overload.cpp
--- llvm-toolchain-7-7.0.1/clang/test/SemaCXX/default-addr-space-overload.cpp	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/SemaCXX/default-addr-space-overload.cpp	2019-05-19 11:21:51.015903000 +0000
@@ -0,0 +1,26 @@
+// RUN: %clang_cc1 -fsyntax-only -verify %s
+// expected-no-diagnostics
+
+typedef __UINT8_TYPE__ uint8_t;
+typedef __UINT16_TYPE__ uint16_t;
+typedef __UINT32_TYPE__ uint32_t;
+
+#pragma clang default_addr_space(1)
+uint8_t foo(void *p);
+
+#pragma clang default_addr_space(2)
+uint16_t foo(void *p);
+
+#pragma clang default_addr_space(4)
+uint32_t foo(void *p);
+
+#pragma clang default_addr_space(default)
+void __attribute__((address_space(1))) *a;
+void __attribute__((address_space(2))) *b;
+void __attribute__((address_space(4))) *c;
+
+void bar() {
+  static_assert(sizeof(foo(a)) == 1, "Should've picked the first overload!");
+  static_assert(sizeof(foo(b)) == 2, "Should've picked the second overload!");
+  static_assert(sizeof(foo(c)) == 4, "Should've picked the third overload!");
+}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/SemaTemplate/address_space-dependent.cpp llvm-toolchain-7-7.0.1.patched/clang/test/SemaTemplate/address_space-dependent.cpp
--- llvm-toolchain-7-7.0.1/clang/test/SemaTemplate/address_space-dependent.cpp	2018-12-16 12:04:51.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/SemaTemplate/address_space-dependent.cpp	2019-05-19 11:21:51.015903000 +0000
@@ -43,7 +43,7 @@
 
 template <long int I>
 void tooBig() {
-  __attribute__((address_space(I))) int *bounds; // expected-error {{address space is larger than the maximum supported (8388598)}}
+  __attribute__((address_space(I))) int *bounds; // expected-error {{address space is larger than the maximum supported (8388597)}}
 }
 
 template <long int I>
@@ -101,7 +101,7 @@
   car<1, 2, 3>(); // expected-note {{in instantiation of function template specialization 'car<1, 2, 3>' requested here}}
   HasASTemplateFields<1> HASTF;
   neg<-1>(); // expected-note {{in instantiation of function template specialization 'neg<-1>' requested here}}
-  correct<0x7FFFF6>();
+  correct<0x7FFFF5>();
   tooBig<8388650>(); // expected-note {{in instantiation of function template specialization 'tooBig<8388650>' requested here}}
 
   __attribute__((address_space(1))) char *x;
diff -rN --unified llvm-toolchain-7-7.0.1/clang/test/SemaTemplate/instantiate-expr-3.cpp llvm-toolchain-7-7.0.1.patched/clang/test/SemaTemplate/instantiate-expr-3.cpp
--- llvm-toolchain-7-7.0.1/clang/test/SemaTemplate/instantiate-expr-3.cpp	2018-12-16 12:04:51.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/test/SemaTemplate/instantiate-expr-3.cpp	2019-05-19 11:21:51.025903000 +0000
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -triple x86_64-unknown-unknown -fsyntax-only -verify %s
+// RUN: %clang_cc1 -triple x86_64-unknown-unknown-wine32 -fsyntax-only -verify %s
 
 // ---------------------------------------------------------------------
 // Imaginary literals
@@ -108,15 +108,16 @@
 struct VaArg1 {
   void f(int n, ...) {
     VaList va;
-    __builtin_va_start(va, n); // expected-error{{int}} expected-error{{char *}}
+    __builtin_va_start(va, n); // expected-error{{int}} expected-error{{char *}} expected-error{{__va_list32 *}}
     for (int i = 0; i != n; ++i)
       (void)__builtin_va_arg(va, ArgType); // expected-error{{int}}
-    __builtin_va_end(va); // expected-error{{int}} expected-error{{char *}}
+    __builtin_va_end(va); // expected-error{{int}} expected-error{{char *}} expected-error{{__va_list32 *}}
   }
 };
 
 template struct VaArg1<__builtin_va_list, int>;
 template struct VaArg1<__builtin_ms_va_list, int>; // expected-note{{instantiation}}
+template struct VaArg1<__builtin_va_list32, int>; // expected-note{{instantiation}}
 template struct VaArg1<int, int>; // expected-note{{instantiation}}
 
 template<typename ArgType>
@@ -136,13 +137,43 @@
 struct VaArg3 {
   void __attribute__((ms_abi)) f(int n, ...) {
     VaList va;
-    __builtin_ms_va_start(va, n); // expected-error{{int}} expected-error{{__va_list_tag}}
+    __builtin_ms_va_start(va, n); // expected-error{{int}} expected-error{{__va_list_tag}} expected-error{{__va_list32 *}}
     for (int i = 0; i != n; ++i)
       (void)__builtin_va_arg(va, ArgType); // expected-error{{int}}
-    __builtin_ms_va_end(va); // expected-error{{int}} expected-error{{__va_list_tag}}
+    __builtin_ms_va_end(va); // expected-error{{int}} expected-error{{__va_list_tag}} expected-error{{__va_list32 *}}
   }
 };
 
 template struct VaArg3<__builtin_ms_va_list, int>;
 template struct VaArg3<__builtin_va_list, int>; // expected-note{{instantiation}}
+template struct VaArg3<__builtin_va_list32, int>; // expected-note{{instantiation}}
 template struct VaArg3<int, int>; // expected-note{{instantiation}}
+
+template<typename ArgType>
+struct VaArg4 {
+  void __attribute__((cdecl32)) f(int n, ...) {
+    __builtin_va_list32 va;
+    __builtin_va_start32(va, n);
+    for (int i = 0; i != n; ++i)
+      (void)__builtin_va_arg(va, ArgType);
+    __builtin_va_end32(va);
+  }
+};
+
+template struct VaArg4<int>;
+
+template<typename VaList, typename ArgType>
+struct VaArg5 {
+  void __attribute__((cdecl32)) f(int n, ...) {
+    VaList va;
+    __builtin_va_start32(va, n); // expected-error{{int}} expected-error{{__va_list_tag}} expected-error{{char *}}
+    for (int i = 0; i != n; ++i)
+      (void)__builtin_va_arg(va, ArgType); // expected-error{{int}}
+    __builtin_va_end32(va); // expected-error{{int}} expected-error{{__va_list_tag}} expected-error{{char *}}
+  }
+};
+
+template struct VaArg5<__builtin_va_list32, int>;
+template struct VaArg5<__builtin_va_list, int>; // expected-note{{instantiation}}
+template struct VaArg5<__builtin_ms_va_list, int>; // expected-note{{instantiation}}
+template struct VaArg5<int, int>; // expected-note{{instantiation}}
diff -rN --unified llvm-toolchain-7-7.0.1/clang/tools/libclang/CXType.cpp llvm-toolchain-7-7.0.1.patched/clang/tools/libclang/CXType.cpp
--- llvm-toolchain-7-7.0.1/clang/tools/libclang/CXType.cpp	2018-12-16 12:04:51.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/clang/tools/libclang/CXType.cpp	2019-05-19 11:21:51.725903000 +0000
@@ -640,6 +640,10 @@
       TCALLINGCONV(Swift);
       TCALLINGCONV(PreserveMost);
       TCALLINGCONV(PreserveAll);
+      TCALLINGCONV(X86C32);
+      TCALLINGCONV(X86StdCall32);
+      TCALLINGCONV(X86FastCall32);
+      TCALLINGCONV(X86ThisCall32);
     case CC_SpirFunction: return CXCallingConv_Unexposed;
     case CC_OpenCLKernel: return CXCallingConv_Unexposed;
       break;
diff -rN --unified llvm-toolchain-7-7.0.1/cmake/config.guess llvm-toolchain-7-7.0.1.patched/cmake/config.guess
--- llvm-toolchain-7-7.0.1/cmake/config.guess	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/cmake/config.guess	2019-05-19 11:21:51.725903000 +0000
@@ -1,14 +1,12 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-#   2011 Free Software Foundation, Inc.
+#   Copyright 1992-2016 Free Software Foundation, Inc.
 
-timestamp='2011-08-20'
+timestamp='2016-10-02'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -17,26 +15,22 @@
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner.  Please send patches (context
-# diff format) to <config-patches@gnu.org> and include a ChangeLog
-# entry.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 #
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+#
+# Please send patches to <config-patches@gnu.org>.
+
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
@@ -56,9 +50,7 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
+Copyright 1992-2016 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -140,12 +132,33 @@
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+case "${UNAME_SYSTEM}" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	eval $set_cc_for_build
+	cat <<-EOF > $dummy.c
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
+	;;
+esac
+
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     *:NetBSD:*:*)
 	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
 	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
 	# switched to ELF, *-*-netbsd* would select the old
 	# object file format.  This provides both forward
@@ -155,19 +168,29 @@
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
 	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    /sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || \
+	    echo unknown)`
 	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
+	    earmv*)
+		arch=`echo ${UNAME_MACHINE_ARCH} | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo ${UNAME_MACHINE_ARCH} | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
+		;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
+	# to ELF recently (or will in the future) and ABI.
 	case "${UNAME_MACHINE_ARCH}" in
+	    earm*)
+		os=netbsdelf
+		;;
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
@@ -184,6 +207,13 @@
 		os=netbsd
 		;;
 	esac
+	# Determine ABI tags.
+	case "${UNAME_MACHINE_ARCH}" in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo ${UNAME_MACHINE_ARCH} | sed -e "$expr"`
+		;;
+	esac
 	# The OS release
 	# Debian GNU/NetBSD machines have a different userland, and
 	# thus, need a distinct triplet. However, they do not need
@@ -194,18 +224,26 @@
 		release='-gnu'
 		;;
 	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		release=`echo ${UNAME_RELEASE} | sed -e 's/[-_].*//' | cut -d. -f1,2`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
+	echo "${machine}-${os}${release}${abi}"
+	exit ;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}
 	exit ;;
     *:OpenBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
 	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
 	exit ;;
+    *:LibertyBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-libertybsd${UNAME_RELEASE}
+	exit ;;
     *:ekkoBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
 	exit ;;
@@ -218,6 +256,9 @@
     *:MirBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
 	exit ;;
+    *:Sortix:*:*)
+	echo ${UNAME_MACHINE}-unknown-sortix
+	exit ;;
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
@@ -234,42 +275,42 @@
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV4.5 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "LCA4 (21066/21068)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV5 (21164)")
-		UNAME_MACHINE="alphaev5" ;;
+		UNAME_MACHINE=alphaev5 ;;
 	    "EV5.6 (21164A)")
-		UNAME_MACHINE="alphaev56" ;;
+		UNAME_MACHINE=alphaev56 ;;
 	    "EV5.6 (21164PC)")
-		UNAME_MACHINE="alphapca56" ;;
+		UNAME_MACHINE=alphapca56 ;;
 	    "EV5.7 (21164PC)")
-		UNAME_MACHINE="alphapca57" ;;
+		UNAME_MACHINE=alphapca57 ;;
 	    "EV6 (21264)")
-		UNAME_MACHINE="alphaev6" ;;
+		UNAME_MACHINE=alphaev6 ;;
 	    "EV6.7 (21264A)")
-		UNAME_MACHINE="alphaev67" ;;
+		UNAME_MACHINE=alphaev67 ;;
 	    "EV6.8CB (21264C)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8AL (21264B)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8CX (21264D)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.9A (21264/EV69A)")
-		UNAME_MACHINE="alphaev69" ;;
+		UNAME_MACHINE=alphaev69 ;;
 	    "EV7 (21364)")
-		UNAME_MACHINE="alphaev7" ;;
+		UNAME_MACHINE=alphaev7 ;;
 	    "EV7.9 (21364A)")
-		UNAME_MACHINE="alphaev79" ;;
+		UNAME_MACHINE=alphaev79 ;;
 	esac
 	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
 	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
 	exitcode=$?
 	trap '' 0
@@ -304,7 +345,7 @@
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
 	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
 	echo arm-unknown-riscos
 	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
@@ -342,16 +383,16 @@
 	exit ;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
 	eval $set_cc_for_build
-	SUN_ARCH="i386"
+	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
 	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
 	    then
-		SUN_ARCH="x86_64"
+		SUN_ARCH=x86_64
 	    fi
 	fi
 	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
@@ -376,7 +417,7 @@
 	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	test "x${UNAME_RELEASE}" = x && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
 		echo m68k-sun-sunos${UNAME_RELEASE}
@@ -562,8 +603,9 @@
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if [ -x /usr/bin/lslpp ] ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
@@ -600,13 +642,13 @@
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
 		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
 		    case "${sc_cpu_version}" in
-		      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-		      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
 		      532)                      # CPU_PA_RISC2_0
 			case "${sc_kernel_bits}" in
-			  32) HP_ARCH="hppa2.0n" ;;
-			  64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+			  32) HP_ARCH=hppa2.0n ;;
+			  64) HP_ARCH=hppa2.0w ;;
+			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
 			esac ;;
 		    esac
 		fi
@@ -645,11 +687,11 @@
 		    exit (0);
 		}
 EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    (CCOPTS="" $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ ${HP_ARCH} = "hppa2.0w" ]
+	if [ ${HP_ARCH} = hppa2.0w ]
 	then
 	    eval $set_cc_for_build
 
@@ -662,12 +704,12 @@
 	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
 	    # => hppa64-hp-hpux11.23
 
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
 		grep -q __LP64__
 	    then
-		HP_ARCH="hppa2.0w"
+		HP_ARCH=hppa2.0w
 	    else
-		HP_ARCH="hppa64"
+		HP_ARCH=hppa64
 	    fi
 	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
@@ -772,14 +814,14 @@
 	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
 	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
 	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     5000:UNIX_System_V:4.*:*)
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
 	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
@@ -803,6 +845,9 @@
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
 	exit ;;
+    *:MINGW64*:*)
+	echo ${UNAME_MACHINE}-pc-mingw64
+	exit ;;
     *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit ;;
@@ -854,17 +899,21 @@
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
 	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
 	exit ;;
-    aarch64*:Linux:*)
-	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+    aarch64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
@@ -877,56 +926,60 @@
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
 	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     arm*:Linux:*:*)
 	eval $set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	else
 	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 		| grep -q __ARM_PCS_VFP
 	    then
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
 	    else
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabihf
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
 	    fi
 	fi
 	exit ;;
     avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     cris:Linux:*:*)
-	echo cris-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     crisv32:Linux:*:*)
-	echo crisv32-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
+	exit ;;
+    e2k:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     frv:Linux:*:*)
-	echo frv-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    hexagon:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:Linux:*:*)
-	LIBC=gnu
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
-	echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    k1om:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
 	eval $set_cc_for_build
@@ -945,57 +998,69 @@
 	#endif
 EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
-    or32:Linux:*:*)
-	echo or32-unknown-linux-gnu
+    mips64el:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-${LIBC}
+	exit ;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-gnu
+	echo sparc-unknown-linux-${LIBC}
 	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
+	echo hppa64-unknown-linux-${LIBC}
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
+	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
+	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
+	  *)    echo hppa-unknown-linux-${LIBC} ;;
 	esac
 	exit ;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
+	echo powerpc64-unknown-linux-${LIBC}
+	exit ;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-${LIBC}
 	exit ;;
     ppc64le:Linux:*:*)
-	echo powerpc64le-unknown-linux-gnu
+	echo powerpc64le-unknown-linux-${LIBC}
 	exit ;;
-    ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
+    ppcle:Linux:*:*)
+	echo powerpcle-unknown-linux-${LIBC}
+	exit ;;
+    riscv32:Linux:*:* | riscv64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
+	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
 	exit ;;
     sh64*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     tile*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-gnu
+	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
 	exit ;;
     x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     xtensa*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
@@ -1071,7 +1136,7 @@
 	# uname -m prints for DJGPP always 'pc', but it prints nothing about
 	# the processor, so we play safe by assuming i586.
 	# Note: whatever this is, it MUST be the same as what config.sub
-	# prints for the "djgpp" host, or else GDB configury will decide that
+	# prints for the "djgpp" host, or else GDB configure will decide that
 	# this is a cross-build.
 	echo i586-pc-msdosdjgpp
 	exit ;;
@@ -1199,7 +1264,7 @@
     BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
 	echo i586-pc-haiku
 	exit ;;
-    x86_64:Haiku:*:*) # Haiku running on x86_64.
+    x86_64:Haiku:*:*)
 	echo x86_64-unknown-haiku
 	exit ;;
     SX-4:SUPER-UX:*:*)
@@ -1220,6 +1285,9 @@
     SX-8R:SUPER-UX:*:*)
 	echo sx8r-nec-superux${UNAME_RELEASE}
 	exit ;;
+    SX-ACE:SUPER-UX:*:*)
+	echo sxace-nec-superux${UNAME_RELEASE}
+	exit ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
 	exit ;;
@@ -1228,24 +1296,36 @@
 	exit ;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    i386)
-		eval $set_cc_for_build
-		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		      grep IS_64BIT_ARCH >/dev/null
-		  then
-		      UNAME_PROCESSOR="x86_64"
-		  fi
-		fi ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
+	eval $set_cc_for_build
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
+	fi
+	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		    (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
+	fi
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
-	if test "$UNAME_PROCESSOR" = "x86"; then
+	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
@@ -1257,7 +1337,7 @@
     NEO-?:NONSTOP_KERNEL:*:*)
 	echo neo-tandem-nsk${UNAME_RELEASE}
 	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
+    NSE-*:NONSTOP_KERNEL:*:*)
 	echo nse-tandem-nsk${UNAME_RELEASE}
 	exit ;;
     NSR-?:NONSTOP_KERNEL:*:*)
@@ -1276,7 +1356,7 @@
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
-	if test "$cputype" = "386"; then
+	if test "$cputype" = 386; then
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
@@ -1318,7 +1398,7 @@
 	echo i386-pc-xenix
 	exit ;;
     i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE} | sed -e 's/ .*$//'`
 	exit ;;
     i*86:rdos:*:*)
 	echo ${UNAME_MACHINE}-pc-rdos
@@ -1326,174 +1406,28 @@
     i*86:AROS:*:*)
 	echo ${UNAME_MACHINE}-pc-aros
 	exit ;;
-esac
-
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-	"4"
-#else
-	""
-#endif
-	); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
-	{ echo "$SYSTEM_NAME"; exit; }
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
+    x86_64:VMkernel:*:*)
+	echo ${UNAME_MACHINE}-unknown-esx
 	exit ;;
-    c34*)
-	echo c34-convex-bsd
+    amd64:Isilon\ OneFS:*:*)
+	echo x86_64-unknown-onefs
 	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
+esac
 
 cat >&2 <<EOF
 $0: unable to guess system type
 
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
+This script (version $timestamp), has failed to recognize the
+operating system you are using. If your script is old, overwrite
+config.guess and config.sub with the latest versions from:
 
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 and
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches@gnu.org> in order to provide the needed
-information to handle your system.
+If $0 has already been updated, send the following data and any
+information you think might be pertinent to config-patches@gnu.org to
+provide the necessary information to handle your system.
 
 config.guess timestamp = $timestamp
 
diff -rN --unified llvm-toolchain-7-7.0.1/docs/LangRef.rst llvm-toolchain-7-7.0.1.patched/docs/LangRef.rst
--- llvm-toolchain-7-7.0.1/docs/LangRef.rst	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/docs/LangRef.rst	2019-05-19 11:21:51.755903000 +0000
@@ -719,7 +719,7 @@
 :ref:`parameter attribute <paramattrs>` for the return type, a function
 name, a (possibly empty) argument list (each with optional :ref:`parameter
 attributes <paramattrs>`), optional :ref:`function attributes <fnattrs>`,
-an optional section, an optional alignment,
+an optional address space, an optional section, an optional alignment,
 an optional :ref:`comdat <langref_comdats>`,
 an optional :ref:`garbage collector name <gc>`, an optional :ref:`prefix <prefixdata>`,
 an optional :ref:`prologue <prologuedata>`,
@@ -731,8 +731,8 @@
 optional :ref:`linkage type <linkage>`, an optional :ref:`visibility style
 <visibility>`, an optional :ref:`DLL storage class <dllstorageclass>`, an
 optional :ref:`calling convention <callingconv>`, an optional ``unnamed_addr``
-or ``local_unnamed_addr`` attribute, a return type, an optional :ref:`parameter
-attribute <paramattrs>` for the return type, a function name, a possibly
+or ``local_unnamed_addr`` attribute, an optional address space, a return type,
+an optional :ref:`parameter attribute <paramattrs>` for the return type, a function name, a possibly
 empty list of arguments, an optional alignment, an optional :ref:`garbage
 collector name <gc>`, an optional :ref:`prefix <prefixdata>`, and an optional
 :ref:`prologue <prologuedata>`.
@@ -769,13 +769,16 @@
 If the ``local_unnamed_addr`` attribute is given, the address is known to
 not be significant within the module.
 
+If an explicit address space is not given, it will default to the program
+address space from the :ref:`datalayout string<langref_datalayout>`.
+
 Syntax::
 
     define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]
            [cconv] [ret attrs]
            <ResultType> @<FunctionName> ([argument list])
-           [(unnamed_addr|local_unnamed_addr)] [fn Attrs] [section "name"]
-           [comdat [($name)]] [align N] [gc] [prefix Constant]
+           [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [fn Attrs]
+           [section "name"] [comdat [($name)]] [align N] [gc] [prefix Constant]
            [prologue Constant] [personality Constant] (!name !N)* { ... }
 
 The argument list is a comma separated sequence of arguments where each
@@ -1495,7 +1498,7 @@
     generated for this function needs to follow certain conventions that
     make it possible for a runtime function to patch over it later.
     The exact effect of this attribute depends on its string value,
-    for which there currently is one legal possibility:
+    for which there currently are two legal possiblities:
 
      * ``"prologue-short-redirect"`` - This style of patchable
        function is intended to support patching a function prologue to
@@ -1511,6 +1514,24 @@
 
        ``"prologue-short-redirect"`` is currently only supported on
        x86-64.
+     * ``"ms-hotpatch"`` - This style of patchable function is similar to
+       ``"prologue-short-redirect"``, but it also imposes several additional
+       guarantees to support the style of hotpatching used on Windows.  On
+       32-bit x86, the first instruction will be a ``mov %edi, %edi``
+       instruction; this is frequently used as a magic value indicating a
+       hotpatchable function.  On other architectures, however, the first
+       instruction can be anything allowed in a Windows-style prologue;
+       this is because all functions on the non-i386 architectures Windows
+       supports are assumed to be hotpatchable.  Additionally, when not
+       targeting a Visual C++-style toolchain, patch space will be provided
+       prior to the function's entry point of an architecturally specific
+       size.  These sizes are compatible with GCC: on 32-bit x86, the patch
+       space is 64 bytes long; on x86-64, it is 128 bytes long.  The patch
+       space is not provided for MSVC toolchains because the
+       `/FUNCTIONPADMIN <https://msdn.microsoft.com/en-us/library/ms173524.aspx>`_
+       option, which provides this space, is expected to be used there.
+
+       ``"ms-hotpatch"`` is currently only supported on x86 and x86-64.
 
     This attribute by itself does not imply restrictions on
     inter-procedural optimizations.  All of the semantic effects the
@@ -6460,7 +6481,7 @@
 
 ::
 
-      <result> = invoke [cconv] [ret attrs] <ty>|<fnty> <fnptrval>(<function args>) [fn attrs]
+      <result> = invoke [cconv] [ret attrs] [addrspace(<num>)] [<ty>|<fnty> <fnptrval>(<function args>) [fn attrs]
                     [operand bundles] to label <normal label> unwind label <exception label>
 
 Overview:
@@ -6496,6 +6517,9 @@
 #. The optional :ref:`Parameter Attributes <paramattrs>` list for return
    values. Only '``zeroext``', '``signext``', and '``inreg``' attributes
    are valid here.
+#. The optional addrspace attribute can be used to indicate the adress space
+   of the called function. If it is not specified, the program address space
+   from the :ref:`datalayout string<langref_datalayout>` will be used.
 #. '``ty``': the type of the call instruction itself which is also the
    type of the return value. Functions that return no value are marked
    ``void``.
@@ -9511,8 +9535,8 @@
 
 ::
 
-      <result> = [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] <ty>|<fnty> <fnptrval>(<function args>) [fn attrs]
-                   [ operand bundles ]
+      <result> = [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] [addrspace(<num>)]
+                 [<ty>|<fnty> <fnptrval>(<function args>) [fn attrs] [ operand bundles ]
 
 Overview:
 """""""""
@@ -9583,6 +9607,9 @@
 #. The optional :ref:`Parameter Attributes <paramattrs>` list for return
    values. Only '``zeroext``', '``signext``', and '``inreg``' attributes
    are valid here.
+#. The optional addrspace attribute can be used to indicate the adress space
+   of the called function. If it is not specified, the program address space
+   from the :ref:`datalayout string<langref_datalayout>` will be used.
 #. '``ty``': the type of the call instruction itself which is also the
    type of the return value. Functions that return no value are marked
    ``void``.
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/ADT/Triple.h llvm-toolchain-7-7.0.1.patched/include/llvm/ADT/Triple.h
--- llvm-toolchain-7-7.0.1/include/llvm/ADT/Triple.h	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/ADT/Triple.h	2019-05-19 11:21:51.755903000 +0000
@@ -207,7 +207,8 @@
     Cygnus,
     CoreCLR,
     Simulator,  // Simulator variants of other systems, e.g., Apple's iOS
-    LastEnvironmentType = Simulator
+    Wine32,     // Special environment for running Win32 binaries under 64-bit
+    LastEnvironmentType = Wine32
   };
   enum ObjectFormatType {
     UnknownObjectFormat,
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/BinaryFormat/Dwarf.def llvm-toolchain-7-7.0.1.patched/include/llvm/BinaryFormat/Dwarf.def
--- llvm-toolchain-7-7.0.1/include/llvm/BinaryFormat/Dwarf.def	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/BinaryFormat/Dwarf.def	2019-05-19 11:21:51.755903000 +0000
@@ -729,6 +729,7 @@
 HANDLE_DW_CC(0xc9, LLVM_PreserveMost)
 HANDLE_DW_CC(0xca, LLVM_PreserveAll)
 HANDLE_DW_CC(0xcb, LLVM_X86RegCall)
+HANDLE_DW_CC(0xcc, LLVM_C32)
 // From GCC source code (include/dwarf2.h): This DW_CC_ value is not currently
 // generated by any toolchain.  It is used internally to GDB to indicate OpenCL C
 // functions that have been compiled with the IBM XL C for OpenCL compiler and use
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/Bitcode/LLVMBitCodes.h llvm-toolchain-7-7.0.1.patched/include/llvm/Bitcode/LLVMBitCodes.h
--- llvm-toolchain-7-7.0.1/include/llvm/Bitcode/LLVMBitCodes.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/Bitcode/LLVMBitCodes.h	2019-05-19 11:21:51.755903000 +0000
@@ -591,6 +591,7 @@
   ATTR_KIND_NOCF_CHECK = 56,
   ATTR_KIND_OPT_FOR_FUZZING = 57,
   ATTR_KIND_SHADOWCALLSTACK = 58,
+  ATTR_KIND_THUNK_DATA = 60,
 };
 
 enum ComdatSelectionKindCodes {
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/CodeGen/TargetCallingConv.h llvm-toolchain-7-7.0.1.patched/include/llvm/CodeGen/TargetCallingConv.h
--- llvm-toolchain-7-7.0.1/include/llvm/CodeGen/TargetCallingConv.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/CodeGen/TargetCallingConv.h	2019-05-19 11:21:51.755903000 +0000
@@ -34,6 +34,7 @@
     unsigned IsNest : 1;     ///< Nested fn static chain
     unsigned IsReturned : 1; ///< Always returned
     unsigned IsSplit : 1;
+    unsigned IsThunkData : 1;  ///< Data used by thunks
     unsigned IsInAlloca : 1;   ///< Passed with inalloca
     unsigned IsSplitEnd : 1;   ///< Last part of a split
     unsigned IsSwiftSelf : 1;  ///< Swift self parameter
@@ -52,9 +53,9 @@
   public:
     ArgFlagsTy()
         : IsZExt(0), IsSExt(0), IsInReg(0), IsSRet(0), IsByVal(0), IsNest(0),
-          IsReturned(0), IsSplit(0), IsInAlloca(0), IsSplitEnd(0),
-          IsSwiftSelf(0), IsSwiftError(0), IsHva(0), IsHvaStart(0),
-          IsSecArgPass(0), ByValAlign(0), OrigAlign(0),
+          IsReturned(0), IsSplit(0), IsThunkData(0), IsInAlloca(0),
+          IsSplitEnd(0), IsSwiftSelf(0), IsSwiftError(0), IsHva(0),
+          IsHvaStart(0), IsSecArgPass(0), ByValAlign(0), OrigAlign(0),
           IsInConsecutiveRegsLast(0), IsInConsecutiveRegs(0),
           IsCopyElisionCandidate(0), ByValSize(0) {
       static_assert(sizeof(*this) == 2 * sizeof(unsigned), "flags are too big");
@@ -114,6 +115,9 @@
     bool isCopyElisionCandidate()  const { return IsCopyElisionCandidate; }
     void setCopyElisionCandidate() { IsCopyElisionCandidate = 1; }
 
+    bool isThunkData()   const { return IsThunkData; }
+    void setThunkData()  { IsThunkData = 1; }
+
     unsigned getByValAlign() const { return (1U << ByValAlign) / 2; }
     void setByValAlign(unsigned A) {
       ByValAlign = Log2_32(A) + 1;
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/CodeGen/TargetInstrInfo.h llvm-toolchain-7-7.0.1.patched/include/llvm/CodeGen/TargetInstrInfo.h
--- llvm-toolchain-7-7.0.1/include/llvm/CodeGen/TargetInstrInfo.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/CodeGen/TargetInstrInfo.h	2019-05-19 11:21:51.755903000 +0000
@@ -1656,6 +1656,19 @@
     return false;
   }
 
+  /// Emit a patchable operation in the given basic block at the given
+  /// insertion point.
+  ///
+  /// Most of the time, this will be a straight-up \c TargetOpcode::PATCHABLE_OP
+  /// instruction, which will be lowered by the target to a no-op that can
+  /// be safely replaced with a short jump. However, some targets under certain
+  /// conditions can have peculiar requirements for this instruction; these
+  /// targets can provide their own implementation of this to emit the correct
+  /// instruction.
+  virtual void
+  emitPatchableOp(StringRef PatchType, MachineBasicBlock &MBB,
+                  MachineBasicBlock::iterator &MBBI) const;
+
 private:
   unsigned CallFrameSetupOpcode, CallFrameDestroyOpcode;
   unsigned CatchRetOpcode;
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/CodeGen/TargetLowering.h llvm-toolchain-7-7.0.1.patched/include/llvm/CodeGen/TargetLowering.h
--- llvm-toolchain-7-7.0.1/include/llvm/CodeGen/TargetLowering.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/CodeGen/TargetLowering.h	2019-05-19 11:21:51.765903000 +0000
@@ -187,12 +187,13 @@
     bool IsReturned : 1;
     bool IsSwiftSelf : 1;
     bool IsSwiftError : 1;
+    bool IsThunkData : 1;
     uint16_t Alignment = 0;
 
     ArgListEntry()
         : IsSExt(false), IsZExt(false), IsInReg(false), IsSRet(false),
           IsNest(false), IsByVal(false), IsInAlloca(false), IsReturned(false),
-          IsSwiftSelf(false), IsSwiftError(false) {}
+          IsSwiftSelf(false), IsSwiftError(false), IsThunkData(false) {}
 
     void setAttributes(ImmutableCallSite *CS, unsigned ArgIdx);
   };
@@ -1480,6 +1481,11 @@
     return isNoopAddrSpaceCast(SrcAS, DestAS);
   }
 
+  /// Returns true if a cast between SrcAS and DestAS will lose no information.
+  virtual bool isLosslessAddrSpaceCast(unsigned SrcAS, unsigned DestAS) const {
+    return isNoopAddrSpaceCast(SrcAS, DestAS);
+  }
+
   /// Return true if the pointer arguments to CI should be aligned by aligning
   /// the object whose address is being passed. If so then MinSize is set to the
   /// minimum size the object must be to be aligned and PrefAlign is set to the
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/CodeGen/TargetRegisterInfo.h llvm-toolchain-7-7.0.1.patched/include/llvm/CodeGen/TargetRegisterInfo.h
--- llvm-toolchain-7-7.0.1/include/llvm/CodeGen/TargetRegisterInfo.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/CodeGen/TargetRegisterInfo.h	2019-05-19 11:21:51.765903000 +0000
@@ -357,7 +357,7 @@
   /// Return the maximal subclass of the given register class that is
   /// allocatable or NULL.
   const TargetRegisterClass *
-    getAllocatableClass(const TargetRegisterClass *RC) const;
+    getAllocatableClass(const TargetRegisterClass *RC, MVT VT = MVT::Any) const;
 
   /// Returns a bitset indexed by register number indicating if a register is
   /// allocatable or not. If a register class is specified, returns the subset
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/IR/Attributes.td llvm-toolchain-7-7.0.1.patched/include/llvm/IR/Attributes.td
--- llvm-toolchain-7-7.0.1/include/llvm/IR/Attributes.td	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/IR/Attributes.td	2019-05-19 11:21:51.765903000 +0000
@@ -182,6 +182,9 @@
 /// Argument is swift self/context.
 def SwiftSelf : EnumAttr<"swiftself">;
 
+/// Argument is used to pass auxiliary data to thunks.
+def ThunkData : EnumAttr<"thunkdata">;
+
 /// Function must be in a unwind table.
 def UWTable : EnumAttr<"uwtable">;
 
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/IR/CallingConv.h llvm-toolchain-7-7.0.1.patched/include/llvm/IR/CallingConv.h
--- llvm-toolchain-7-7.0.1/include/llvm/IR/CallingConv.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/IR/CallingConv.h	2019-05-19 11:21:51.765903000 +0000
@@ -220,6 +220,10 @@
     /// shader if tessellation is in use, or otherwise the vertex shader.
     AMDGPU_ES = 96,
 
+    /// The C convention as implemented for x86-32, but on x86-64. This is
+    /// intended for interoperation between 64-bit and legacy 32-bit code.
+    X86_64_C32 = 98,
+
     /// The highest possible calling convention ID. Must be some 2^k - 1.
     MaxID = 1023
   };
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/IR/Function.h llvm-toolchain-7-7.0.1.patched/include/llvm/IR/Function.h
--- llvm-toolchain-7-7.0.1/include/llvm/IR/Function.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/IR/Function.h	2019-05-19 11:21:51.765903000 +0000
@@ -120,7 +120,7 @@
   /// function is automatically inserted into the end of the function list for
   /// the module.
   ///
-  Function(FunctionType *Ty, LinkageTypes Linkage,
+  Function(FunctionType *Ty, LinkageTypes Linkage, unsigned AddrSpace,
            const Twine &N = "", Module *M = nullptr);
 
 public:
@@ -134,10 +134,24 @@
   const Function &getFunction() const { return *this; }
 
   static Function *Create(FunctionType *Ty, LinkageTypes Linkage,
+                          unsigned AddrSpace, const Twine &N = "",
+                          Module *M = nullptr) {
+    return new Function(Ty, Linkage, AddrSpace, N, M);
+  }
+
+  // TODO: remove this once all users have been updated to pass an AddrSpace
+  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,
                           const Twine &N = "", Module *M = nullptr) {
-    return new Function(Ty, Linkage, N, M);
+    return new Function(Ty, Linkage, static_cast<unsigned>(-1), N, M);
   }
 
+  /// Creates a new function and attaches it to a module.
+  ///
+  /// Places the function in the program address space as specified
+  /// by the module's data layout.
+  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,
+                          const Twine &N, Module &M);
+
   // Provide fast operand accessors.
   DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);
 
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/IR/GlobalValue.h llvm-toolchain-7-7.0.1.patched/include/llvm/IR/GlobalValue.h
--- llvm-toolchain-7-7.0.1/include/llvm/IR/GlobalValue.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/IR/GlobalValue.h	2019-05-19 11:21:51.765903000 +0000
@@ -189,6 +189,7 @@
   GlobalValue(const GlobalValue &) = delete;
 
   unsigned getAlignment() const;
+  unsigned getAddressSpace() const;
 
   enum class UnnamedAddr {
     None,
diff -rN --unified llvm-toolchain-7-7.0.1/include/llvm/Target/TargetCallingConv.td llvm-toolchain-7-7.0.1.patched/include/llvm/Target/TargetCallingConv.td
--- llvm-toolchain-7-7.0.1/include/llvm/Target/TargetCallingConv.td	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/include/llvm/Target/TargetCallingConv.td	2019-05-19 11:21:51.765903000 +0000
@@ -77,6 +77,10 @@
 /// the specified action.
 class CCIfSRet<CCAction A> : CCIf<"ArgFlags.isSRet()", A> {}
 
+/// CCIfThunkData - If this argument is marked with the 'thunkdata'
+/// attribute, apply the specified action.
+class CCIfThunkData<CCAction A> : CCIf<"ArgFlags.isThunkData()", A> {}
+
 /// CCIfVarArg - If the current function is vararg - apply the action
 class CCIfVarArg<CCAction A> : CCIf<"State.isVarArg()", A> {}
 
diff -rN --unified llvm-toolchain-7-7.0.1/lib/AsmParser/LLLexer.cpp llvm-toolchain-7-7.0.1.patched/lib/AsmParser/LLLexer.cpp
--- llvm-toolchain-7-7.0.1/lib/AsmParser/LLLexer.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/AsmParser/LLLexer.cpp	2019-05-19 11:21:51.765903000 +0000
@@ -603,6 +603,7 @@
   KEYWORD(x86_64_sysvcc);
   KEYWORD(win64cc);
   KEYWORD(x86_regcallcc);
+  KEYWORD(x86_64_c32cc);
   KEYWORD(webkit_jscc);
   KEYWORD(swiftcc);
   KEYWORD(anyregcc);
@@ -680,6 +681,7 @@
   KEYWORD(sanitize_memory);
   KEYWORD(swifterror);
   KEYWORD(swiftself);
+  KEYWORD(thunkdata);
   KEYWORD(uwtable);
   KEYWORD(writeonly);
   KEYWORD(zeroext);
diff -rN --unified llvm-toolchain-7-7.0.1/lib/AsmParser/LLParser.cpp llvm-toolchain-7-7.0.1.patched/lib/AsmParser/LLParser.cpp
--- llvm-toolchain-7-7.0.1/lib/AsmParser/LLParser.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/AsmParser/LLParser.cpp	2019-05-19 11:21:51.765903000 +0000
@@ -1300,6 +1300,7 @@
     case lltok::kw_sret:
     case lltok::kw_swifterror:
     case lltok::kw_swiftself:
+    case lltok::kw_thunkdata:
       HaveError |=
         Error(Lex.getLoc(),
               "invalid use of parameter-only attribute on a function");
@@ -1317,7 +1318,8 @@
 static inline GlobalValue *createGlobalFwdRef(Module *M, PointerType *PTy,
                                               const std::string &Name) {
   if (auto *FT = dyn_cast<FunctionType>(PTy->getElementType()))
-    return Function::Create(FT, GlobalValue::ExternalWeakLinkage, Name, M);
+    return Function::Create(FT, GlobalValue::ExternalWeakLinkage,
+                            PTy->getAddressSpace(), Name, M);
   else
     return new GlobalVariable(*M, PTy->getElementType(), false,
                               GlobalValue::ExternalWeakLinkage, nullptr, Name,
@@ -1325,11 +1327,33 @@
                               PTy->getAddressSpace());
 }
 
+Value *LLParser::checkValidVariableType(LocTy Loc, const Twine &Name, Type *Ty,
+                                        Value *Val, bool IsCall) {
+  if (Val->getType() == Ty)
+    return Val;
+  // For calls we also accept variables in the program address space.
+  Type *SuggestedTy = Ty;
+  if (IsCall && isa<PointerType>(Ty)) {
+    Type *TyInProgAS = cast<PointerType>(Ty)->getElementType()->getPointerTo(
+        M->getDataLayout().getProgramAddressSpace());
+    SuggestedTy = TyInProgAS;
+    if (Val->getType() == TyInProgAS)
+      return Val;
+  }
+  if (Ty->isLabelTy())
+    Error(Loc, "'" + Name + "' is not a basic block");
+  else
+    Error(Loc, "'" + Name + "' defined with type '" +
+                   getTypeString(Val->getType()) + "' but expected '" +
+                   getTypeString(SuggestedTy) + "'");
+  return nullptr;
+}
+
 /// GetGlobalVal - Get a value with the specified name or ID, creating a
 /// forward reference record if needed.  This can return null if the value
 /// exists but does not have the right type.
 GlobalValue *LLParser::GetGlobalVal(const std::string &Name, Type *Ty,
-                                    LocTy Loc) {
+                                    LocTy Loc, bool IsCall) {
   PointerType *PTy = dyn_cast<PointerType>(Ty);
   if (!PTy) {
     Error(Loc, "global variable reference must have pointer type");
@@ -1349,12 +1373,9 @@
   }
 
   // If we have the value in the symbol table or fwd-ref table, return it.
-  if (Val) {
-    if (Val->getType() == Ty) return Val;
-    Error(Loc, "'@" + Name + "' defined with type '" +
-          getTypeString(Val->getType()) + "'");
-    return nullptr;
-  }
+  if (Val)
+    return cast_or_null<GlobalValue>(
+        checkValidVariableType(Loc, "@" + Name, Ty, Val, IsCall));
 
   // Otherwise, create a new forward reference for this value and remember it.
   GlobalValue *FwdVal = createGlobalFwdRef(M, PTy, Name);
@@ -1362,7 +1383,8 @@
   return FwdVal;
 }
 
-GlobalValue *LLParser::GetGlobalVal(unsigned ID, Type *Ty, LocTy Loc) {
+GlobalValue *LLParser::GetGlobalVal(unsigned ID, Type *Ty, LocTy Loc,
+                                    bool IsCall) {
   PointerType *PTy = dyn_cast<PointerType>(Ty);
   if (!PTy) {
     Error(Loc, "global variable reference must have pointer type");
@@ -1380,12 +1402,9 @@
   }
 
   // If we have the value in the symbol table or fwd-ref table, return it.
-  if (Val) {
-    if (Val->getType() == Ty) return Val;
-    Error(Loc, "'@" + Twine(ID) + "' defined with type '" +
-          getTypeString(Val->getType()) + "'");
-    return nullptr;
-  }
+  if (Val)
+    return cast_or_null<GlobalValue>(
+        checkValidVariableType(Loc, "@" + Twine(ID), Ty, Val, IsCall));
 
   // Otherwise, create a new forward reference for this value and remember it.
   GlobalValue *FwdVal = createGlobalFwdRef(M, PTy, "");
@@ -1500,8 +1519,8 @@
 /// ParseOptionalAddrSpace
 ///   := /*empty*/
 ///   := 'addrspace' '(' uint32 ')'
-bool LLParser::ParseOptionalAddrSpace(unsigned &AddrSpace) {
-  AddrSpace = 0;
+bool LLParser::ParseOptionalAddrSpace(unsigned &AddrSpace, unsigned DefaultAS) {
+  AddrSpace = DefaultAS;
   if (!EatIfPresent(lltok::kw_addrspace))
     return false;
   return ParseToken(lltok::lparen, "expected '(' in address space") ||
@@ -1573,6 +1592,7 @@
     case lltok::kw_sret:            B.addAttribute(Attribute::StructRet); break;
     case lltok::kw_swifterror:      B.addAttribute(Attribute::SwiftError); break;
     case lltok::kw_swiftself:       B.addAttribute(Attribute::SwiftSelf); break;
+    case lltok::kw_thunkdata:       B.addAttribute(Attribute::ThunkData); break;
     case lltok::kw_writeonly:       B.addAttribute(Attribute::WriteOnly); break;
     case lltok::kw_zeroext:         B.addAttribute(Attribute::ZExt); break;
 
@@ -1668,6 +1688,7 @@
     case lltok::kw_sret:
     case lltok::kw_swifterror:
     case lltok::kw_swiftself:
+    case lltok::kw_thunkdata:
       HaveError |= Error(Lex.getLoc(), "invalid use of parameter-only attribute");
       break;
 
@@ -1860,6 +1881,7 @@
 ///   ::= 'spir_kernel'
 ///   ::= 'x86_64_sysvcc'
 ///   ::= 'win64cc'
+///   ::= 'x86_64_c32cc'
 ///   ::= 'webkit_jscc'
 ///   ::= 'anyregcc'
 ///   ::= 'preserve_mostcc'
@@ -1904,6 +1926,7 @@
   case lltok::kw_intel_ocl_bicc: CC = CallingConv::Intel_OCL_BI; break;
   case lltok::kw_x86_64_sysvcc:  CC = CallingConv::X86_64_SysV; break;
   case lltok::kw_win64cc:        CC = CallingConv::Win64; break;
+  case lltok::kw_x86_64_c32cc:   CC = CallingConv::X86_64_C32; break;
   case lltok::kw_webkit_jscc:    CC = CallingConv::WebKit_JS; break;
   case lltok::kw_anyregcc:       CC = CallingConv::AnyReg; break;
   case lltok::kw_preserve_mostcc:CC = CallingConv::PreserveMost; break;
@@ -2741,19 +2764,6 @@
   return false;
 }
 
-static bool isValidVariableType(Module *M, Type *Ty, Value *Val, bool IsCall) {
-  if (Val->getType() == Ty)
-    return true;
-  // For calls we also accept variables in the program address space
-  if (IsCall && isa<PointerType>(Ty)) {
-    Type *TyInProgAS = cast<PointerType>(Ty)->getElementType()->getPointerTo(
-        M->getDataLayout().getProgramAddressSpace());
-    if (Val->getType() == TyInProgAS)
-      return true;
-  }
-  return false;
-}
-
 /// GetVal - Get a value with the specified name or ID, creating a
 /// forward reference record if needed.  This can return null if the value
 /// exists but does not have the right type.
@@ -2771,16 +2781,8 @@
   }
 
   // If we have the value in the symbol table or fwd-ref table, return it.
-  if (Val) {
-    if (isValidVariableType(P.M, Ty, Val, IsCall))
-      return Val;
-    if (Ty->isLabelTy())
-      P.Error(Loc, "'%" + Name + "' is not a basic block");
-    else
-      P.Error(Loc, "'%" + Name + "' defined with type '" +
-              getTypeString(Val->getType()) + "'");
-    return nullptr;
-  }
+  if (Val)
+    return P.checkValidVariableType(Loc, "%" + Name, Ty, Val, IsCall);
 
   // Don't make placeholders with invalid type.
   if (!Ty->isFirstClassType()) {
@@ -2814,16 +2816,8 @@
   }
 
   // If we have the value in the symbol table or fwd-ref table, return it.
-  if (Val) {
-    if (isValidVariableType(P.M, Ty, Val, IsCall))
-      return Val;
-    if (Ty->isLabelTy())
-      P.Error(Loc, "'%" + Twine(ID) + "' is not a basic block");
-    else
-      P.Error(Loc, "'%" + Twine(ID) + "' defined with type '" +
-              getTypeString(Val->getType()) + "'");
-    return nullptr;
-  }
+  if (Val)
+    return P.checkValidVariableType(Loc, "%" + Twine(ID), Ty, Val, IsCall);
 
   if (!Ty->isFirstClassType()) {
     P.Error(Loc, "invalid use of a non-first-class type");
@@ -4912,10 +4906,10 @@
     return false;
   }
   case ValID::t_GlobalName:
-    V = GetGlobalVal(ID.StrVal, Ty, ID.Loc);
+    V = GetGlobalVal(ID.StrVal, Ty, ID.Loc, IsCall);
     return V == nullptr;
   case ValID::t_GlobalID:
-    V = GetGlobalVal(ID.UIntVal, Ty, ID.Loc);
+    V = GetGlobalVal(ID.UIntVal, Ty, ID.Loc, IsCall);
     return V == nullptr;
   case ValID::t_APSInt:
     if (!Ty->isIntegerTy())
@@ -5058,8 +5052,8 @@
 /// FunctionHeader
 ///   ::= OptionalLinkage OptionalPreemptionSpecifier OptionalVisibility
 ///       OptionalCallingConv OptRetAttrs OptUnnamedAddr Type GlobalName
-///       '(' ArgList ')' OptFuncAttrs OptSection OptionalAlign OptGC
-///       OptionalPrefix OptionalPrologue OptPersonalityFn
+///       '(' ArgList ')' OptAddrSpace OptFuncAttrs OptSection OptionalAlign
+///       OptGC OptionalPrefix OptionalPrologue OptPersonalityFn
 bool LLParser::ParseFunctionHeader(Function *&Fn, bool isDefine) {
   // Parse the linkage.
   LocTy LinkageLoc = Lex.getLoc();
@@ -5137,6 +5131,7 @@
   unsigned Alignment;
   std::string GC;
   GlobalValue::UnnamedAddr UnnamedAddr = GlobalValue::UnnamedAddr::None;
+  unsigned AddrSpace = 0;
   Constant *Prefix = nullptr;
   Constant *Prologue = nullptr;
   Constant *PersonalityFn = nullptr;
@@ -5144,6 +5139,7 @@
 
   if (ParseArgumentList(ArgList, isVarArg) ||
       ParseOptionalUnnamedAddr(UnnamedAddr) ||
+      ParseOptionalProgramAddrSpace(AddrSpace) ||
       ParseFnAttributeValuePairs(FuncAttrs, FwdRefAttrGrps, false,
                                  BuiltinLoc) ||
       (EatIfPresent(lltok::kw_section) &&
@@ -5188,7 +5184,7 @@
 
   FunctionType *FT =
     FunctionType::get(RetType, ParamTypeList, isVarArg);
-  PointerType *PFT = PointerType::getUnqual(FT);
+  PointerType *PFT = PointerType::get(FT, AddrSpace);
 
   Fn = nullptr;
   if (!FunctionName.empty()) {
@@ -5202,8 +5198,9 @@
                      "function as global value!");
       if (Fn->getType() != PFT)
         return Error(FRVI->second.second, "invalid forward reference to "
-                     "function '" + FunctionName + "' with wrong type!");
-
+                     "function '" + FunctionName + "' with wrong type: "
+                     "expected '" + getTypeString(PFT) + "' but was '" +
+                     getTypeString(Fn->getType()) + "'");
       ForwardRefVals.erase(FRVI);
     } else if ((Fn = M->getFunction(FunctionName))) {
       // Reject redefinitions.
@@ -5221,16 +5218,21 @@
       Fn = cast<Function>(I->second.first);
       if (Fn->getType() != PFT)
         return Error(NameLoc, "type of definition and forward reference of '@" +
-                     Twine(NumberedVals.size()) + "' disagree");
+                     Twine(NumberedVals.size()) + "' disagree: "
+                     "expected '" + getTypeString(PFT) + "' but was '" +
+                     getTypeString(Fn->getType()) + "'");
       ForwardRefValIDs.erase(I);
     }
   }
 
   if (!Fn)
-    Fn = Function::Create(FT, GlobalValue::ExternalLinkage, FunctionName, M);
+    Fn = Function::Create(FT, GlobalValue::ExternalLinkage, AddrSpace,
+                          FunctionName, M);
   else // Move the forward-reference to the correct spot in the module.
     M->getFunctionList().splice(M->end(), M->getFunctionList(), Fn);
 
+  assert(Fn->getAddressSpace() == AddrSpace && "Created function in wrong AS");
+
   if (FunctionName.empty())
     NumberedVals.push_back(Fn);
 
@@ -5749,6 +5751,7 @@
   std::vector<unsigned> FwdRefAttrGrps;
   LocTy NoBuiltinLoc;
   unsigned CC;
+  unsigned InvokeAddrSpace;
   Type *RetType = nullptr;
   LocTy RetTypeLoc;
   ValID CalleeID;
@@ -5757,6 +5760,7 @@
 
   BasicBlock *NormalBB, *UnwindBB;
   if (ParseOptionalCallingConv(CC) || ParseOptionalReturnAttrs(RetAttrs) ||
+      ParseOptionalProgramAddrSpace(InvokeAddrSpace) ||
       ParseType(RetType, RetTypeLoc, true /*void allowed*/) ||
       ParseValID(CalleeID) || ParseParameterList(ArgList, PFS) ||
       ParseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false,
@@ -5788,8 +5792,8 @@
 
   // Look up the callee.
   Value *Callee;
-  if (ConvertValIDToValue(PointerType::getUnqual(Ty), CalleeID, Callee, &PFS,
-                          /*IsCall=*/true))
+  if (ConvertValIDToValue(PointerType::get(Ty, InvokeAddrSpace), CalleeID,
+                          Callee, &PFS, /*IsCall=*/true))
     return true;
 
   // Set up the Attribute for the function.
@@ -6332,6 +6336,7 @@
   AttrBuilder RetAttrs, FnAttrs;
   std::vector<unsigned> FwdRefAttrGrps;
   LocTy BuiltinLoc;
+  unsigned CallAddrSpace;
   unsigned CC;
   Type *RetType = nullptr;
   LocTy RetTypeLoc;
@@ -6348,6 +6353,7 @@
   FastMathFlags FMF = EatFastMathFlagsIfPresent();
 
   if (ParseOptionalCallingConv(CC) || ParseOptionalReturnAttrs(RetAttrs) ||
+      ParseOptionalProgramAddrSpace(CallAddrSpace) ||
       ParseType(RetType, RetTypeLoc, true /*void allowed*/) ||
       ParseValID(CalleeID) ||
       ParseParameterList(ArgList, PFS, TCK == CallInst::TCK_MustTail,
@@ -6380,8 +6386,8 @@
 
   // Look up the callee.
   Value *Callee;
-  if (ConvertValIDToValue(PointerType::getUnqual(Ty), CalleeID, Callee, &PFS,
-                          /*IsCall=*/true))
+  if (ConvertValIDToValue(PointerType::get(Ty, CallAddrSpace), CalleeID, Callee,
+                          &PFS, /*IsCall=*/true))
     return true;
 
   // Set up the Attribute for the function.
diff -rN --unified llvm-toolchain-7-7.0.1/lib/AsmParser/LLParser.h llvm-toolchain-7-7.0.1.patched/lib/AsmParser/LLParser.h
--- llvm-toolchain-7-7.0.1/lib/AsmParser/LLParser.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/AsmParser/LLParser.h	2019-05-19 11:21:51.765903000 +0000
@@ -202,8 +202,9 @@
     /// GetGlobalVal - Get a value with the specified name or ID, creating a
     /// forward reference record if needed.  This can return null if the value
     /// exists but does not have the right type.
-    GlobalValue *GetGlobalVal(const std::string &Name, Type *Ty, LocTy Loc);
-    GlobalValue *GetGlobalVal(unsigned ID, Type *Ty, LocTy Loc);
+    GlobalValue *GetGlobalVal(const std::string &N, Type *Ty, LocTy Loc,
+                              bool IsCall);
+    GlobalValue *GetGlobalVal(unsigned ID, Type *Ty, LocTy Loc, bool IsCall);
 
     /// Get a Comdat with the specified name, creating a forward reference
     /// record if needed.
@@ -267,7 +268,11 @@
     bool ParseTLSModel(GlobalVariable::ThreadLocalMode &TLM);
     bool ParseOptionalThreadLocal(GlobalVariable::ThreadLocalMode &TLM);
     bool ParseOptionalUnnamedAddr(GlobalVariable::UnnamedAddr &UnnamedAddr);
-    bool ParseOptionalAddrSpace(unsigned &AddrSpace);
+    bool ParseOptionalAddrSpace(unsigned &AddrSpace, unsigned DefaultAS = 0);
+    bool ParseOptionalProgramAddrSpace(unsigned &AddrSpace) {
+      return ParseOptionalAddrSpace(
+          AddrSpace, M->getDataLayout().getProgramAddressSpace());
+    };
     bool ParseOptionalParamAttrs(AttrBuilder &B);
     bool ParseOptionalReturnAttrs(AttrBuilder &B);
     bool ParseOptionalLinkage(unsigned &Res, bool &HasLinkage,
@@ -448,6 +453,9 @@
     bool ConvertValIDToValue(Type *Ty, ValID &ID, Value *&V,
                              PerFunctionState *PFS, bool IsCall);
 
+    Value *checkValidVariableType(LocTy Loc, const Twine &Name, Type *Ty,
+                                  Value *Val, bool IsCall);
+
     bool parseConstantValue(Type *Ty, Constant *&C);
     bool ParseValue(Type *Ty, Value *&V, PerFunctionState *PFS);
     bool ParseValue(Type *Ty, Value *&V, PerFunctionState &PFS) {
diff -rN --unified llvm-toolchain-7-7.0.1/lib/AsmParser/LLToken.h llvm-toolchain-7-7.0.1.patched/lib/AsmParser/LLToken.h
--- llvm-toolchain-7-7.0.1/lib/AsmParser/LLToken.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/AsmParser/LLToken.h	2019-05-19 11:21:51.765903000 +0000
@@ -148,6 +148,7 @@
   kw_spir_func,
   kw_x86_64_sysvcc,
   kw_win64cc,
+  kw_x86_64_c32cc,
   kw_webkit_jscc,
   kw_anyregcc,
   kw_swiftcc,
@@ -222,6 +223,7 @@
   kw_strictfp,
   kw_swifterror,
   kw_swiftself,
+  kw_thunkdata,
   kw_uwtable,
   kw_writeonly,
   kw_zeroext,
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Bitcode/Reader/BitcodeReader.cpp llvm-toolchain-7-7.0.1.patched/lib/Bitcode/Reader/BitcodeReader.cpp
--- llvm-toolchain-7-7.0.1/lib/Bitcode/Reader/BitcodeReader.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Bitcode/Reader/BitcodeReader.cpp	2019-05-19 11:21:51.765903000 +0000
@@ -1178,6 +1178,9 @@
   case Attribute::AllocSize:
     llvm_unreachable("allocsize not supported in raw format");
     break;
+  case Attribute::ThunkData:
+    llvm_unreachable("thunkdata not supported in raw format");
+    break;
   }
   llvm_unreachable("Unsupported attribute type");
 }
@@ -1190,7 +1193,8 @@
     if (I == Attribute::Dereferenceable ||
         I == Attribute::DereferenceableOrNull ||
         I == Attribute::ArgMemOnly ||
-        I == Attribute::AllocSize)
+        I == Attribute::AllocSize ||
+        I == Attribute::ThunkData)
       continue;
     if (uint64_t A = (Val & getRawAttributeMask(I))) {
       if (I == Attribute::Alignment)
@@ -1353,6 +1357,8 @@
     return Attribute::OptimizeForSize;
   case bitc::ATTR_KIND_OPTIMIZE_NONE:
     return Attribute::OptimizeNone;
+  case bitc::ATTR_KIND_THUNK_DATA:
+    return Attribute::ThunkData;
   case bitc::ATTR_KIND_READ_NONE:
     return Attribute::ReadNone;
   case bitc::ATTR_KIND_READ_ONLY:
@@ -2938,7 +2944,7 @@
 Error BitcodeReader::parseFunctionRecord(ArrayRef<uint64_t> Record) {
   // v1: [type, callingconv, isproto, linkage, paramattr, alignment, section,
   // visibility, gc, unnamed_addr, prologuedata, dllstorageclass, comdat,
-  // prefixdata,  personalityfn, preemption specifier] (name in VST)
+  // prefixdata,  personalityfn, preemption specifier, addrspace] (name in VST)
   // v2: [strtab_offset, strtab_size, v1]
   StringRef Name;
   std::tie(Name, Record) = readNameFromStrtab(Record);
@@ -2957,8 +2963,12 @@
   if (CC & ~CallingConv::MaxID)
     return error("Invalid calling convention ID");
 
-  Function *Func =
-      Function::Create(FTy, GlobalValue::ExternalLinkage, Name, TheModule);
+  unsigned AddrSpace = TheModule->getDataLayout().getProgramAddressSpace();
+  if (Record.size() > 16)
+    AddrSpace = Record[16];
+
+  Function *Func = Function::Create(FTy, GlobalValue::ExternalLinkage,
+                                    AddrSpace, Name, TheModule);
 
   Func->setCallingConv(CC);
   bool isProto = Record[2];
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Bitcode/Writer/BitcodeWriter.cpp llvm-toolchain-7-7.0.1.patched/lib/Bitcode/Writer/BitcodeWriter.cpp
--- llvm-toolchain-7-7.0.1/lib/Bitcode/Writer/BitcodeWriter.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Bitcode/Writer/BitcodeWriter.cpp	2019-05-19 11:21:51.765903000 +0000
@@ -654,6 +654,8 @@
     return bitc::ATTR_KIND_OPTIMIZE_FOR_SIZE;
   case Attribute::OptimizeNone:
     return bitc::ATTR_KIND_OPTIMIZE_NONE;
+  case Attribute::ThunkData:
+    return bitc::ATTR_KIND_THUNK_DATA;
   case Attribute::ReadNone:
     return bitc::ATTR_KIND_READ_NONE;
   case Attribute::ReadOnly:
@@ -1264,7 +1266,7 @@
     // FUNCTION:  [strtab offset, strtab size, type, callingconv, isproto,
     //             linkage, paramattrs, alignment, section, visibility, gc,
     //             unnamed_addr, prologuedata, dllstorageclass, comdat,
-    //             prefixdata, personalityfn, DSO_Local]
+    //             prefixdata, personalityfn, DSO_Local, addrspace]
     Vals.push_back(addToStrtab(F.getName()));
     Vals.push_back(F.getName().size());
     Vals.push_back(VE.getTypeID(F.getFunctionType()));
@@ -1287,6 +1289,8 @@
         F.hasPersonalityFn() ? (VE.getValueID(F.getPersonalityFn()) + 1) : 0);
 
     Vals.push_back(F.isDSOLocal());
+    Vals.push_back(F.getAddressSpace());
+
     unsigned AbbrevToUse = 0;
     Stream.EmitRecord(bitc::MODULE_CODE_FUNCTION, Vals, AbbrevToUse);
     Vals.clear();
diff -rN --unified llvm-toolchain-7-7.0.1/lib/CodeGen/ExpandMemCmp.cpp llvm-toolchain-7-7.0.1.patched/lib/CodeGen/ExpandMemCmp.cpp
--- llvm-toolchain-7-7.0.1/lib/CodeGen/ExpandMemCmp.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/CodeGen/ExpandMemCmp.cpp	2019-05-19 11:21:51.765903000 +0000
@@ -202,10 +202,11 @@
   Type *LoadSizeType = Type::getInt8Ty(CI->getContext());
   // Cast source to LoadSizeType*.
   if (Source1->getType() != LoadSizeType)
-    Source1 = Builder.CreateBitCast(Source1, LoadSizeType->getPointerTo());
+    Source1 = Builder.CreateBitCast(Source1, LoadSizeType->getPointerTo(
+            Source1->getType()->getPointerAddressSpace()));
   if (Source2->getType() != LoadSizeType)
-    Source2 = Builder.CreateBitCast(Source2, LoadSizeType->getPointerTo());
-
+    Source2 = Builder.CreateBitCast(Source2, LoadSizeType->getPointerTo(
+            Source2->getType()->getPointerAddressSpace()));
   // Get the base address using the GEPIndex.
   if (GEPIndex != 0) {
     Source1 = Builder.CreateGEP(LoadSizeType, Source1,
@@ -275,9 +276,11 @@
 
     // Cast source to LoadSizeType*.
     if (Source1->getType() != LoadSizeType)
-      Source1 = Builder.CreateBitCast(Source1, LoadSizeType->getPointerTo());
+      Source1 = Builder.CreateBitCast(Source1, LoadSizeType->getPointerTo(
+              Source1->getType()->getPointerAddressSpace()));
     if (Source2->getType() != LoadSizeType)
-      Source2 = Builder.CreateBitCast(Source2, LoadSizeType->getPointerTo());
+      Source2 = Builder.CreateBitCast(Source2, LoadSizeType->getPointerTo(
+              Source2->getType()->getPointerAddressSpace()));
 
     // Get the base address using a GEP.
     if (CurLoadEntry.Offset != 0) {
@@ -394,9 +397,11 @@
   Builder.SetInsertPoint(LoadCmpBlocks[BlockIndex]);
   // Cast source to LoadSizeType*.
   if (Source1->getType() != LoadSizeType)
-    Source1 = Builder.CreateBitCast(Source1, LoadSizeType->getPointerTo());
+    Source1 = Builder.CreateBitCast(Source1, LoadSizeType->getPointerTo(
+            Source1->getType()->getPointerAddressSpace()));
   if (Source2->getType() != LoadSizeType)
-    Source2 = Builder.CreateBitCast(Source2, LoadSizeType->getPointerTo());
+    Source2 = Builder.CreateBitCast(Source2, LoadSizeType->getPointerTo(
+            Source2->getType()->getPointerAddressSpace()));
 
   // Get the base address using a GEP.
   if (CurLoadEntry.Offset != 0) {
@@ -525,9 +530,11 @@
 
   // Cast source to LoadSizeType*.
   if (Source1->getType() != LoadSizeType)
-    Source1 = Builder.CreateBitCast(Source1, LoadSizeType->getPointerTo());
+    Source1 = Builder.CreateBitCast(Source1, LoadSizeType->getPointerTo(
+            Source1->getType()->getPointerAddressSpace()));
   if (Source2->getType() != LoadSizeType)
-    Source2 = Builder.CreateBitCast(Source2, LoadSizeType->getPointerTo());
+    Source2 = Builder.CreateBitCast(Source2, LoadSizeType->getPointerTo(
+            Source2->getType()->getPointerAddressSpace()));
 
   // Load LoadSizeType from the base address.
   Value *LoadSrc1 = Builder.CreateLoad(LoadSizeType, Source1);
diff -rN --unified llvm-toolchain-7-7.0.1/lib/CodeGen/PatchableFunction.cpp llvm-toolchain-7-7.0.1.patched/lib/CodeGen/PatchableFunction.cpp
--- llvm-toolchain-7-7.0.1/lib/CodeGen/PatchableFunction.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/CodeGen/PatchableFunction.cpp	2019-05-19 11:21:51.765903000 +0000
@@ -14,7 +14,6 @@
 
 #include "llvm/CodeGen/MachineFunction.h"
 #include "llvm/CodeGen/MachineFunctionPass.h"
-#include "llvm/CodeGen/MachineInstrBuilder.h"
 #include "llvm/CodeGen/Passes.h"
 #include "llvm/CodeGen/TargetFrameLowering.h"
 #include "llvm/CodeGen/TargetInstrInfo.h"
@@ -30,7 +29,7 @@
   }
 
   bool runOnMachineFunction(MachineFunction &F) override;
-   MachineFunctionProperties getRequiredProperties() const override {
+  MachineFunctionProperties getRequiredProperties() const override {
     return MachineFunctionProperties().set(
         MachineFunctionProperties::Property::NoVRegs);
   }
@@ -58,11 +57,10 @@
   if (!MF.getFunction().hasFnAttribute("patchable-function"))
     return false;
 
-#ifndef NDEBUG
   Attribute PatchAttr = MF.getFunction().getFnAttribute("patchable-function");
   StringRef PatchType = PatchAttr.getValueAsString();
-  assert(PatchType == "prologue-short-redirect" && "Only possibility today!");
-#endif
+  assert((PatchType == "prologue-short-redirect" ||
+          PatchType == "ms-hotpatch") && "Only possibilities today!");
 
   auto &FirstMBB = *MF.begin();
   MachineBasicBlock::iterator FirstActualI = FirstMBB.begin();
@@ -70,15 +68,8 @@
     assert(FirstActualI != FirstMBB.end());
 
   auto *TII = MF.getSubtarget().getInstrInfo();
-  auto MIB = BuildMI(FirstMBB, FirstActualI, FirstActualI->getDebugLoc(),
-                     TII->get(TargetOpcode::PATCHABLE_OP))
-                 .addImm(2)
-                 .addImm(FirstActualI->getOpcode());
+  TII->emitPatchableOp(PatchType, FirstMBB, FirstActualI);
 
-  for (auto &MO : FirstActualI->operands())
-    MIB.add(MO);
-
-  FirstActualI->eraseFromParent();
   MF.ensureAlignment(4);
   return true;
 }
diff -rN --unified llvm-toolchain-7-7.0.1/lib/CodeGen/SelectionDAG/FastISel.cpp llvm-toolchain-7-7.0.1.patched/lib/CodeGen/SelectionDAG/FastISel.cpp
--- llvm-toolchain-7-7.0.1/lib/CodeGen/SelectionDAG/FastISel.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/CodeGen/SelectionDAG/FastISel.cpp	2019-05-19 11:21:51.765903000 +0000
@@ -1207,6 +1207,8 @@
       Flags.setNest();
     if (NeedsRegBlock)
       Flags.setInConsecutiveRegs();
+    if (Arg.IsThunkData)
+      Flags.setThunkData();
     unsigned OriginalAlignment = DL.getABITypeAlignment(Arg.Ty);
     Flags.setOrigAlign(OriginalAlignment);
 
diff -rN --unified llvm-toolchain-7-7.0.1/lib/CodeGen/SelectionDAG/InstrEmitter.cpp llvm-toolchain-7-7.0.1.patched/lib/CodeGen/SelectionDAG/InstrEmitter.cpp
--- llvm-toolchain-7-7.0.1/lib/CodeGen/SelectionDAG/InstrEmitter.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/CodeGen/SelectionDAG/InstrEmitter.cpp	2019-05-19 11:21:51.765903000 +0000
@@ -134,7 +134,7 @@
             const TargetRegisterClass *RC = nullptr;
             if (i+II.getNumDefs() < II.getNumOperands()) {
               RC = TRI->getAllocatableClass(
-                TII->getRegClass(II, i+II.getNumDefs(), TRI, *MF));
+                TII->getRegClass(II, i+II.getNumDefs(), TRI, *MF), VT);
             }
             if (!UseRC)
               UseRC = RC;
@@ -219,8 +219,10 @@
     // is a vreg in the same register class, use the CopyToReg'd destination
     // register instead of creating a new vreg.
     unsigned VRBase = 0;
+    EVT VT = Node->getValueType(i);
     const TargetRegisterClass *RC =
-      TRI->getAllocatableClass(TII->getRegClass(II, i, TRI, *MF));
+      TRI->getAllocatableClass(TII->getRegClass(II, i, TRI, *MF),
+                               VT.isSimple() ? VT.getSimpleVT() : MVT::Any);
     // Always let the value type influence the used register class. The
     // constraints on the instruction may be too lax to represent the value
     // type correctly. For example, a 64-bit float (X86::FR64) can't live in
@@ -338,7 +340,9 @@
       const TargetRegisterClass *ConstrainedRC
         = MRI->constrainRegClass(VReg, OpRC, MinRCSize);
       if (!ConstrainedRC) {
-        OpRC = TRI->getAllocatableClass(OpRC);
+        EVT VT = Op.getValueType();
+        OpRC = TRI->getAllocatableClass(
+            OpRC, VT.isSimple() ? VT.getSimpleVT() : MVT::Any);
         assert(OpRC && "Constraints cannot be fulfilled for allocation");
         unsigned NewVReg = MRI->createVirtualRegister(OpRC);
         BuildMI(*MBB, InsertPos, Op.getNode()->getDebugLoc(),
diff -rN --unified llvm-toolchain-7-7.0.1/lib/CodeGen/SelectionDAG/SelectionDAG.cpp llvm-toolchain-7-7.0.1.patched/lib/CodeGen/SelectionDAG/SelectionDAG.cpp
--- llvm-toolchain-7-7.0.1/lib/CodeGen/SelectionDAG/SelectionDAG.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/CodeGen/SelectionDAG/SelectionDAG.cpp	2019-05-19 11:21:51.765903000 +0000
@@ -5665,7 +5665,7 @@
                                             unsigned AS) {
   // Lowering memcpy / memset / memmove intrinsics to calls is only valid if all
   // pointer operands can be losslessly bitcasted to pointers of address space 0
-  if (AS != 0 && !TLI->isNoopAddrSpaceCast(AS, 0)) {
+  if (AS != 0 && !TLI->isLosslessAddrSpaceCast(AS, 0)) {
     report_fatal_error("cannot lower memory intrinsic in address space " +
                        Twine(AS));
   }
diff -rN --unified llvm-toolchain-7-7.0.1/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp llvm-toolchain-7-7.0.1.patched/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp
--- llvm-toolchain-7-7.0.1/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -5792,7 +5792,10 @@
     else
       Src = getValue(I.getArgOperand(0));   // The guard's value.
 
-    AllocaInst *Slot = cast<AllocaInst>(I.getArgOperand(1));
+    Value *V = I.getArgOperand(1);
+    AllocaInst *Slot;
+    if (!(Slot = dyn_cast<AllocaInst>(V)))
+      Slot = cast<AllocaInst>(cast<CastInst>(V)->getOperand(0));
 
     int FI = FuncInfo.StaticAllocaMap[Slot];
     MFI.setStackProtectorIndex(FI);
@@ -8493,6 +8496,8 @@
         Flags.setNest();
       if (NeedsRegBlock)
         Flags.setInConsecutiveRegs();
+      if (Args[i].IsThunkData)
+        Flags.setThunkData();
       Flags.setOrigAlign(OriginalAlignment);
 
       MVT PartVT = getRegisterTypeForCallingConv(CLI.RetTy->getContext(),
@@ -8989,6 +8994,8 @@
       Flags.setOrigAlign(OriginalAlignment);
       if (ArgCopyElisionCandidates.count(&Arg))
         Flags.setCopyElisionCandidate();
+      if (Arg.hasAttribute(Attribute::ThunkData))
+        Flags.setThunkData();
 
       MVT RegisterVT = TLI->getRegisterTypeForCallingConv(
           *CurDAG->getContext(), F.getCallingConv(), VT);
diff -rN --unified llvm-toolchain-7-7.0.1/lib/CodeGen/SelectionDAG/TargetLowering.cpp llvm-toolchain-7-7.0.1.patched/lib/CodeGen/SelectionDAG/TargetLowering.cpp
--- llvm-toolchain-7-7.0.1/lib/CodeGen/SelectionDAG/TargetLowering.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/CodeGen/SelectionDAG/TargetLowering.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -110,6 +110,7 @@
   IsReturned = CS->paramHasAttr(ArgIdx, Attribute::Returned);
   IsSwiftSelf = CS->paramHasAttr(ArgIdx, Attribute::SwiftSelf);
   IsSwiftError = CS->paramHasAttr(ArgIdx, Attribute::SwiftError);
+  IsThunkData = CS->paramHasAttr(ArgIdx, Attribute::ThunkData);
   Alignment  = CS->getParamAlignment(ArgIdx);
 }
 
diff -rN --unified llvm-toolchain-7-7.0.1/lib/CodeGen/StackProtector.cpp llvm-toolchain-7-7.0.1.patched/lib/CodeGen/StackProtector.cpp
--- llvm-toolchain-7-7.0.1/lib/CodeGen/StackProtector.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/CodeGen/StackProtector.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -355,11 +355,14 @@
 /// Returns true if the platform/triple supports the stackprotectorcreate pseudo
 /// node.
 static bool CreatePrologue(Function *F, Module *M, ReturnInst *RI,
-                           const TargetLoweringBase *TLI, AllocaInst *&AI) {
+                           const TargetLoweringBase *TLI, Value *&AI) {
   bool SupportsSelectionDAGSP = false;
   IRBuilder<> B(&F->getEntryBlock().front());
   PointerType *PtrTy = Type::getInt8PtrTy(RI->getContext());
   AI = B.CreateAlloca(PtrTy, nullptr, "StackGuardSlot");
+  if (F->getParent()->getDataLayout().getAllocaAddrSpace() != 0)
+    AI = B.CreateAddrSpaceCast(
+        AI, AI->getType()->getPointerElementType()->getPointerTo());
 
   Value *GuardSlot = getStackGuard(TLI, M, B, &SupportsSelectionDAGSP);
   B.CreateCall(Intrinsic::getDeclaration(M, Intrinsic::stackprotector),
@@ -380,7 +383,7 @@
   bool SupportsSelectionDAGSP =
       TLI->useStackGuardXorFP() ||
       (EnableSelectionDAGSP && !TM->Options.EnableFastISel);
-  AllocaInst *AI = nullptr;       // Place on stack that stores the stack guard.
+  Value *AI = nullptr;            // Place on stack that stores the stack guard.
 
   for (Function::iterator I = F->begin(), E = F->end(); I != E;) {
     BasicBlock *BB = &*I++;
diff -rN --unified llvm-toolchain-7-7.0.1/lib/CodeGen/TargetInstrInfo.cpp llvm-toolchain-7-7.0.1.patched/lib/CodeGen/TargetInstrInfo.cpp
--- llvm-toolchain-7-7.0.1/lib/CodeGen/TargetInstrInfo.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/CodeGen/TargetInstrInfo.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -1229,3 +1229,16 @@
   InsertedReg.SubIdx = (unsigned)MOSubIdx.getImm();
   return true;
 }
+
+void TargetInstrInfo::emitPatchableOp(StringRef, MachineBasicBlock &MBB,
+                                      MachineBasicBlock::iterator &MBBI) const {
+  auto MIB = BuildMI(MBB, MBBI, MBBI->getDebugLoc(),
+                     get(TargetOpcode::PATCHABLE_OP))
+                 .addImm(2)
+                 .addImm(MBBI->getOpcode());
+
+  for (auto &MO : MBBI->operands())
+    MIB.add(MO);
+
+  MBBI->eraseFromParent();
+}
diff -rN --unified llvm-toolchain-7-7.0.1/lib/CodeGen/TargetRegisterInfo.cpp llvm-toolchain-7-7.0.1.patched/lib/CodeGen/TargetRegisterInfo.cpp
--- llvm-toolchain-7-7.0.1/lib/CodeGen/TargetRegisterInfo.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/CodeGen/TargetRegisterInfo.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -171,14 +171,16 @@
 /// getAllocatableClass - Return the maximal subclass of the given register
 /// class that is alloctable, or NULL.
 const TargetRegisterClass *
-TargetRegisterInfo::getAllocatableClass(const TargetRegisterClass *RC) const {
+TargetRegisterInfo::getAllocatableClass(const TargetRegisterClass *RC,
+                                        MVT VT) const {
   if (!RC || RC->isAllocatable())
     return RC;
 
   for (BitMaskClassIterator It(RC->getSubClassMask(), *this); It.isValid();
        ++It) {
     const TargetRegisterClass *SubRC = getRegClass(It.getID());
-    if (SubRC->isAllocatable())
+    if (SubRC->isAllocatable() &&
+        (VT == MVT::Any || isTypeLegalForClass(*SubRC, VT)))
       return SubRC;
   }
   return nullptr;
diff -rN --unified llvm-toolchain-7-7.0.1/lib/IR/AsmWriter.cpp llvm-toolchain-7-7.0.1.patched/lib/IR/AsmWriter.cpp
--- llvm-toolchain-7-7.0.1/lib/IR/AsmWriter.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/IR/AsmWriter.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -384,6 +384,7 @@
   case CallingConv::AMDGPU_PS:     Out << "amdgpu_ps"; break;
   case CallingConv::AMDGPU_CS:     Out << "amdgpu_cs"; break;
   case CallingConv::AMDGPU_KERNEL: Out << "amdgpu_kernel"; break;
+  case CallingConv::X86_64_C32:    Out << "x86_64_c32cc"; break;
   }
 }
 
@@ -3354,6 +3355,13 @@
   StringRef UA = getUnnamedAddrEncoding(F->getUnnamedAddr());
   if (!UA.empty())
     Out << ' ' << UA;
+  // We print the function address space if it is non-zero or if we are writing
+  // a module with a non-zero program address space or if there is no valid
+  // Module* so that the file can be parsed without the datalayout string.
+  const Module *Mod = F->getParent();
+  if (F->getAddressSpace() != 0 || !Mod ||
+      Mod->getDataLayout().getProgramAddressSpace() != 0)
+    Out << " addrspace(" << F->getAddressSpace() << ")";
   if (Attrs.hasAttributes(AttributeList::FunctionIndex))
     Out << " #" << Machine.getAttributeGroupSlot(Attrs.getFnAttributes());
   if (F->hasSection()) {
@@ -3491,6 +3499,23 @@
     AnnotationWriter->printInfoComment(V, Out);
 }
 
+static void maybePrintCallAddrSpace(const Value *Operand, const Instruction *I,
+                                    raw_ostream &Out) {
+  // We print the address space of the call if it is non-zero.
+  unsigned CallAddrSpace = Operand->getType()->getPointerAddressSpace();
+  bool PrintAddrSpace = CallAddrSpace != 0;
+  if (!PrintAddrSpace) {
+    const Module *Mod = getModuleFromVal(I);
+    // We also print it if it is zero but not equal to the program address space
+    // or if we can't find a valid Module* to make it possible to parse
+    // the resulting file even without a datalayout string.
+    if (!Mod || Mod->getDataLayout().getProgramAddressSpace() != 0)
+      PrintAddrSpace = true;
+  }
+  if (PrintAddrSpace)
+    Out << " addrspace(" << CallAddrSpace << ")";
+}
+
 // This member is called for each Instruction in a function..
 void AssemblyWriter::printInstruction(const Instruction &I) {
   if (AnnotationWriter) AnnotationWriter->emitInstructionAnnot(&I, Out);
@@ -3688,6 +3713,9 @@
     if (PAL.hasAttributes(AttributeList::ReturnIndex))
       Out << ' ' << PAL.getAsString(AttributeList::ReturnIndex);
 
+    // Only print addrspace(N) if necessary:
+    maybePrintCallAddrSpace(Operand, &I, Out);
+
     // If possible, print out the short form of the call instruction.  We can
     // only do this if the first argument is a pointer to a nonvararg function,
     // and if the return type is not a pointer to a function.
@@ -3730,6 +3758,9 @@
     if (PAL.hasAttributes(AttributeList::ReturnIndex))
       Out << ' ' << PAL.getAsString(AttributeList::ReturnIndex);
 
+    // Only print addrspace(N) if necessary:
+    maybePrintCallAddrSpace(Operand, &I, Out);
+
     // If possible, print out the short form of the invoke instruction. We can
     // only do this if the first argument is a pointer to a nonvararg function,
     // and if the return type is not a pointer to a function.
diff -rN --unified llvm-toolchain-7-7.0.1/lib/IR/Attributes.cpp llvm-toolchain-7-7.0.1.patched/lib/IR/Attributes.cpp
--- llvm-toolchain-7-7.0.1/lib/IR/Attributes.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/IR/Attributes.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -343,6 +343,8 @@
     return "sanitize_thread";
   if (hasAttribute(Attribute::SanitizeMemory))
     return "sanitize_memory";
+  if (hasAttribute(Attribute::ThunkData))
+    return "thunkdata";
   if (hasAttribute(Attribute::UWTable))
     return "uwtable";
   if (hasAttribute(Attribute::ZExt))
diff -rN --unified llvm-toolchain-7-7.0.1/lib/IR/AutoUpgrade.cpp llvm-toolchain-7-7.0.1.patched/lib/IR/AutoUpgrade.cpp
--- llvm-toolchain-7-7.0.1/lib/IR/AutoUpgrade.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/IR/AutoUpgrade.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -456,7 +456,7 @@
       // the end of the name. Change name from llvm.arm.neon.vclz.* to
       //  llvm.ctlz.*
       FunctionType* fType = FunctionType::get(F->getReturnType(), args, false);
-      NewFn = Function::Create(fType, F->getLinkage(),
+      NewFn = Function::Create(fType, F->getLinkage(), F->getAddressSpace(),
                                "llvm.ctlz." + Name.substr(14), F->getParent());
       return true;
     }
@@ -472,7 +472,7 @@
       // Can't use Intrinsic::getDeclaration here as the return types might
       // then only be structurally equal.
       FunctionType* fType = FunctionType::get(F->getReturnType(), Tys, false);
-      NewFn = Function::Create(fType, F->getLinkage(),
+      NewFn = Function::Create(fType, F->getLinkage(), F->getAddressSpace(),
                                "llvm." + Name + ".p0i8", F->getParent());
       return true;
     }
diff -rN --unified llvm-toolchain-7-7.0.1/lib/IR/Function.cpp llvm-toolchain-7-7.0.1.patched/lib/IR/Function.cpp
--- llvm-toolchain-7-7.0.1/lib/IR/Function.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/IR/Function.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -203,6 +203,11 @@
   return NumInstrs;
 }
 
+Function *Function::Create(FunctionType *Ty, LinkageTypes Linkage,
+                           const Twine &N, Module &M) {
+  return Create(Ty, Linkage, M.getDataLayout().getProgramAddressSpace(), N, &M);
+}
+
 void Function::removeFromParent() {
   getParent()->getFunctionList().remove(getIterator());
 }
@@ -215,10 +220,19 @@
 // Function Implementation
 //===----------------------------------------------------------------------===//
 
-Function::Function(FunctionType *Ty, LinkageTypes Linkage, const Twine &name,
-                   Module *ParentModule)
+static unsigned computeAddrSpace(unsigned AddrSpace, Module *M) {
+  // If AS == -1 and we are passed a valid module pointer we place the function
+  // in the program address space. Otherwise we default to AS0.
+  if (AddrSpace == static_cast<unsigned>(-1))
+    return M ? M->getDataLayout().getProgramAddressSpace() : 0;
+  return AddrSpace;
+}
+
+Function::Function(FunctionType *Ty, LinkageTypes Linkage, unsigned AddrSpace,
+                   const Twine &name, Module *ParentModule)
     : GlobalObject(Ty, Value::FunctionVal,
-                   OperandTraits<Function>::op_begin(this), 0, Linkage, name),
+                   OperandTraits<Function>::op_begin(this), 0, Linkage, name,
+                   computeAddrSpace(AddrSpace, ParentModule)),
       NumArgs(Ty->getNumParams()) {
   assert(FunctionType::isValidReturnType(getReturnType()) &&
          "invalid return type");
diff -rN --unified llvm-toolchain-7-7.0.1/lib/IR/Globals.cpp llvm-toolchain-7-7.0.1.patched/lib/IR/Globals.cpp
--- llvm-toolchain-7-7.0.1/lib/IR/Globals.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/IR/Globals.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -108,6 +108,11 @@
   return cast<GlobalObject>(this)->getAlignment();
 }
 
+unsigned GlobalValue::getAddressSpace() const {
+  PointerType *PtrTy = getType();
+  return PtrTy->getAddressSpace();
+}
+
 void GlobalObject::setAlignment(unsigned Align) {
   assert((Align & (Align-1)) == 0 && "Alignment is not a power of 2!");
   assert(Align <= MaximumAlignment &&
diff -rN --unified llvm-toolchain-7-7.0.1/lib/IR/Module.cpp llvm-toolchain-7-7.0.1.patched/lib/IR/Module.cpp
--- llvm-toolchain-7-7.0.1/lib/IR/Module.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/IR/Module.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -145,7 +145,8 @@
   GlobalValue *F = getNamedValue(Name);
   if (!F) {
     // Nope, add it
-    Function *New = Function::Create(Ty, GlobalVariable::ExternalLinkage, Name);
+    Function *New = Function::Create(Ty, GlobalVariable::ExternalLinkage,
+                                     DL.getProgramAddressSpace(), Name);
     if (!New->isIntrinsic())       // Intrinsics get attrs set on construction
       New->setAttributes(AttributeList);
     FunctionList.push_back(New);
@@ -154,8 +155,9 @@
 
   // If the function exists but has the wrong type, return a bitcast to the
   // right type.
-  if (F->getType() != PointerType::getUnqual(Ty))
-    return ConstantExpr::getBitCast(F, PointerType::getUnqual(Ty));
+  auto *PTy = PointerType::get(Ty, F->getAddressSpace());
+  if (F->getType() != PTy)
+    return ConstantExpr::getBitCast(F, PTy);
 
   // Otherwise, we just found the existing function or a prototype.
   return F;
diff -rN --unified llvm-toolchain-7-7.0.1/lib/IR/Verifier.cpp llvm-toolchain-7-7.0.1.patched/lib/IR/Verifier.cpp
--- llvm-toolchain-7-7.0.1/lib/IR/Verifier.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/IR/Verifier.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -1604,6 +1604,10 @@
            "Attribute 'swifterror' only applies to parameters "
            "with pointer type!",
            V);
+    Assert(!Attrs.hasAttribute(Attribute::ThunkData),
+           "Attribute 'thunkdata' only applies to parameters "
+           "with pointer type!",
+           V);
   }
 }
 
@@ -1629,10 +1633,11 @@
           !RetAttrs.hasAttribute(Attribute::Returned) &&
           !RetAttrs.hasAttribute(Attribute::InAlloca) &&
           !RetAttrs.hasAttribute(Attribute::SwiftSelf) &&
-          !RetAttrs.hasAttribute(Attribute::SwiftError)),
+          !RetAttrs.hasAttribute(Attribute::SwiftError) &&
+          !RetAttrs.hasAttribute(Attribute::ThunkData)),
          "Attributes 'byval', 'inalloca', 'nest', 'sret', 'nocapture', "
-         "'returned', 'swiftself', and 'swifterror' do not apply to return "
-         "values!",
+         "'returned', 'swiftself', 'swifterror', and 'thunkdata' do not "
+         "apply to return values!",
          V);
   Assert((!RetAttrs.hasAttribute(Attribute::ReadOnly) &&
           !RetAttrs.hasAttribute(Attribute::WriteOnly) &&
@@ -2804,6 +2809,11 @@
       Assert(!ArgAttrs.hasAttribute(Attribute::StructRet),
              "Attribute 'sret' cannot be used for vararg call arguments!", I);
 
+      Assert(!ArgAttrs.hasAttribute(Attribute::ThunkData),
+             "Attribute 'thunkdata' cannot be used for "
+             "vararg call arguments!",
+             I);
+
       if (ArgAttrs.hasAttribute(Attribute::InAlloca))
         Assert(Idx == CS.arg_size() - 1, "inalloca isn't on the last argument!",
                I);
@@ -2883,7 +2893,7 @@
   static const Attribute::AttrKind ABIAttrs[] = {
       Attribute::StructRet, Attribute::ByVal, Attribute::InAlloca,
       Attribute::InReg, Attribute::Returned, Attribute::SwiftSelf,
-      Attribute::SwiftError};
+      Attribute::SwiftError, Attribute::ThunkData};
   AttrBuilder Copy;
   for (auto AK : ABIAttrs) {
     if (Attrs.hasParamAttribute(I, AK))
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Support/Triple.cpp llvm-toolchain-7-7.0.1.patched/lib/Support/Triple.cpp
--- llvm-toolchain-7-7.0.1/lib/Support/Triple.cpp	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Support/Triple.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -236,6 +236,7 @@
   case Cygnus: return "cygnus";
   case CoreCLR: return "coreclr";
   case Simulator: return "simulator";
+  case Wine32: return "wine32";
   }
 
   llvm_unreachable("Invalid EnvironmentType!");
@@ -527,6 +528,7 @@
     .StartsWith("cygnus", Triple::Cygnus)
     .StartsWith("coreclr", Triple::CoreCLR)
     .StartsWith("simulator", Triple::Simulator)
+    .StartsWith("wine32", Triple::Wine32)
     .Default(Triple::UnknownEnvironment);
 }
 
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/CMakeLists.txt llvm-toolchain-7-7.0.1.patched/lib/Target/X86/CMakeLists.txt
--- llvm-toolchain-7-7.0.1/lib/Target/X86/CMakeLists.txt	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/CMakeLists.txt	2019-05-19 11:21:51.775903000 +0000
@@ -22,6 +22,7 @@
 
 set(sources
   ShadowCallStack.cpp
+  X866432InteropThunkInserter.cpp
   X86AsmPrinter.cpp
   X86CallFrameOptimization.cpp
   X86CallingConv.cpp
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86.h llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86.h
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86.h	2019-05-19 11:21:51.775903000 +0000
@@ -129,6 +129,8 @@
 
 FunctionPass *createX86SpeculativeLoadHardeningPass();
 
+ModulePass *createX866432InteropThunkInserter();
+
 } // End llvm namespace
 
 #endif
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X866432InteropThunkInserter.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X866432InteropThunkInserter.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X866432InteropThunkInserter.cpp	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X866432InteropThunkInserter.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -0,0 +1,674 @@
+//===----- X866432InteropThunkInserter.cpp - Insert 64/32 interop thunks --===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines a module pass that generates 32-bit and 64-bit thunks
+// for all functions with a 32-bit calling convention for which thunks do
+// not already exist.
+//
+//===----------------------------------------------------------------------===//
+
+#include "X86.h"
+#include "X86InstrBuilder.h"
+#include "X86InstrInfo.h"
+#include "X86Subtarget.h"
+#include "llvm/Pass.h"
+#include "llvm/PassAnalysisSupport.h"
+#include "llvm/ADT/StringSet.h"
+#include "llvm/ADT/StringSwitch.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineModuleInfo.h"
+#include "llvm/CodeGen/Passes.h"
+#include "llvm/CodeGen/TargetInstrInfo.h"
+#include "llvm/IR/CallingConv.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Mangler.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/Regex.h"
+
+using namespace llvm;
+
+namespace {
+
+class X866432InteropThunkInserter : public ModulePass {
+public:
+  X866432InteropThunkInserter() : ModulePass(ID) {}
+
+  bool runOnModule(Module &M) override;
+
+  void getAnalysisUsage(AnalysisUsage &AU) const override;
+
+private:
+  // The set of all symbols defined in inline asm.
+  StringSet<> ExistingAsmSymbols;
+
+  void scanExistingAsmSymbols(Module &M);
+  bool generateThunks(Module &M, Function &Fn);
+  void generateThunk32Side(Module &M, Function &Fn, StringRef Prefix,
+                           CallingConv::ID CC);
+  Function *getOrInsertFarCallHelper(Module &M, unsigned PopAmount,
+                                     StringRef Prefix, StringRef CS32Name,
+                                     StringRef CS64Name);
+  GlobalValue *getExternalObject(Module &M, StringRef Name);
+  bool expandFarCallPseudos(Module &M, Function &Fn);
+  bool expandMBB(Module &M, MachineBasicBlock &MBB, StringRef Prefix,
+                 StringRef CS32Name, StringRef CS64Name);
+  bool expandMI(Module &M, MachineBasicBlock &MBB,
+                MachineBasicBlock::iterator MBBI, StringRef Prefix,
+                StringRef CS32Name, StringRef CS64Name);
+
+  MachineModuleInfo *MMI;
+  Mangler Mang;
+
+  const X86Subtarget *STI;
+  const TargetInstrInfo *TII;
+
+  StringRef getPassName() const override {
+    return "X86 64/32 Interop Thunk Inserter";
+  }
+  static char ID;
+};
+
+char X866432InteropThunkInserter::ID = 0;
+
+} // end anonymous namespace
+
+ModulePass *llvm::createX866432InteropThunkInserter() {
+  return new X866432InteropThunkInserter();
+}
+
+void X866432InteropThunkInserter::getAnalysisUsage(AnalysisUsage &AU) const {
+  AU.addRequired<MachineModuleInfo>();
+  AU.setPreservesCFG();
+}
+
+void X866432InteropThunkInserter::scanExistingAsmSymbols(Module &M) {
+  static Regex SymbolRE("[^[:digit:]].*:");
+
+  // It's not enough to getOrInsertFunction() and check that it isn't defined.
+  // Thunks may be defined in file-scope inline asm, which isn't really
+  // accounted for in LLVM IR's symbol table. This bit scans all the file-scope
+  // inline asm and grabs all defined symbols.
+  StringRef InlineAsm = M.getModuleInlineAsm();
+  SmallVector<StringRef, 4> Lines;
+  InlineAsm.split(Lines, "\n");
+  for (StringRef Line : Lines) {
+    // Strip away any comment.
+    Line = Line.split("#").first.trim();
+    // If it matches the form /[^[:digit:]].*:/, it's a symbol definition.
+    if (SymbolRE.match(Line)) {
+      Line = Line.drop_back().trim();
+      // If surrounded by quotes, strip those, too.
+      if ((Line.front() == '"' && Line.back() == '"') ||
+          (Line.front() == '\'' && Line.back() == '\''))
+        Line = Line.drop_front().drop_back();
+      ExistingAsmSymbols.insert(Line);
+    }
+  }
+}
+
+bool X866432InteropThunkInserter::generateThunks(Module &M, Function &Fn) {
+  CallingConv::ID CC = Fn.getCallingConv();
+  if (CC != CallingConv::X86_64_C32 && CC != CallingConv::X86_StdCall &&
+      CC != CallingConv::X86_FastCall && CC != CallingConv::X86_ThisCall)
+    return false;
+
+  if (Fn.empty())
+    return false;
+
+  StringRef Prefix = "__i386_on_x86_64_";
+  if (Fn.hasFnAttribute("thunk-prefix"))
+    Prefix = Fn.getFnAttribute("thunk-prefix").getValueAsString();
+
+  generateThunk32Side(M, Fn, Prefix, CC);
+  return true;
+}
+
+static unsigned getTypeStackSize(const DataLayout &DL, Type *Ty) {
+  return alignTo(DL.getTypeStoreSize(Ty), 4);
+}
+
+void X866432InteropThunkInserter::generateThunk32Side(
+    Module &M, Function &Fn, StringRef Prefix, CallingConv::ID CC) {
+  std::string ThunkName = (Prefix + "thunk_" + Fn.getName()).str();
+
+  // If it's already defined, don't define it again.
+  Function *ThunkFn = M.getFunction(ThunkName);
+  if (ThunkFn && !ThunkFn->empty())
+    return;
+
+  if (!ThunkFn)
+    ThunkFn = cast<Function>(M.getOrInsertFunction(
+        ThunkName, Fn.getFunctionType()));
+
+  ThunkFn->setLinkage(GlobalValue::ExternalLinkage);
+
+  // Make sure this isn't one of the symbols defined in inline asm.
+  SmallString<32> Mangled;
+  Mang.getNameWithPrefix(Mangled, ThunkName, M.getDataLayout());
+  if (ExistingAsmSymbols.count(Mangled)) {
+    return;
+  }
+
+  // Give the function a body so it will get emitted.
+  auto *BB = BasicBlock::Create(M.getContext(), "", ThunkFn);
+  new UnreachableInst(M.getContext(), BB);
+
+  // Mark this function as one we need to generate prefix data for.
+  Mangled.clear();
+  Mang.getNameWithPrefix(Mangled, Fn.getName(), M.getDataLayout());
+  ThunkFn->addFnAttr("thunk-32bit-side", Mangled);
+
+  // Skip generating IR. Instead, just generate a MachineFunction directly.
+  MachineFunction &MF = MMI->getOrCreateMachineFunction(*ThunkFn);
+  auto *MBB = MF.CreateMachineBasicBlock();
+  // The 64-bit part has an IR-level basic block so we can take its address.
+  auto *MBB64 = MF.CreateMachineBasicBlock(BB);
+  MF.push_back(MBB);
+  MF.push_back(MBB64);
+  STI = &MF.getSubtarget<X86Subtarget>();
+  TII = STI->getInstrInfo();
+
+  // Get the external variable holding the segment selector to use.
+  StringRef CSName = "__i386_on_x86_64_cs64";
+  if (Fn.hasFnAttribute("thunk-cs64-name"))
+    CSName = Fn.getFnAttribute("thunk-cs64-name").getValueAsString();
+  auto *TargetCS = getExternalObject(M, CSName);
+
+  // Insert a magic 'mov edi, edi' (8b ff) instruction so this can be
+  // hotpatched. The prefix data will get overwritten by the hotpatch jump.
+  BuildMI(MBB, DebugLoc(), TII->get(X86::MOV32rr_REV), X86::EDI)
+      .addReg(X86::EDI);
+
+  // Get the current instruction pointer to use as a PIC base.
+  BuildMI(MBB, DebugLoc(), TII->get(X86::MOVPC32r), X86::EAX).addImm(0);
+
+  // Move the offset part of the far pointer onto the stack. This is tricky
+  // because we need to LEA the block address, but we only have one register.
+  // The only place we have to save the PIC base is in the stack.
+  // While we're at it, reserve the stack space we're using so that the OS
+  // doesn't accidentally overwrite it. We'll release it when we get to the
+  // other side of the thunk.
+  BuildMI(MBB, DebugLoc(), TII->get(X86::PUSH64r)).addReg(X86::RAX);
+  BuildMI(MBB, DebugLoc(), TII->get(X86::PUSH64r)).addReg(X86::RAX);
+  BuildMI(MBB, DebugLoc(), TII->get(X86::LEA64_32r), X86::EAX)
+      .addReg(X86::RAX)  // Base
+      .addImm(1)         // Scale
+      .addReg(0)         // Index
+                         // Displacement
+      .addBlockAddress(BlockAddress::get(BB), 0, X86II::MO_PIC_BASE_OFFSET)
+      .addReg(0);
+  // Use an XCHG here. This will give us the PIC base back.
+  addRegOffset(BuildMI(MBB, DebugLoc(), TII->get(X86::XCHG32rm), X86::EAX)
+                   .addReg(X86::EAX),
+               X86::RSP, /*isKill=*/false, 0);
+
+  // Get the segment part of the far pointer.
+  // Since this global might be defined in another image, we have to use a
+  // GOT reference here. We can't use GOTPCREL here, though--that only works
+  // in 64-bit code.
+  unsigned OpFlag = STI->isTargetDarwin()
+      ? X86II::MO_DARWIN_NONLAZY_PIC_BASE : X86II::MO_GOT;
+  BuildMI(MBB, DebugLoc(), TII->get(X86::MOV32rm), X86::EAX)
+      .addReg(X86::RAX, getKillRegState(true))
+      .addImm(1)
+      .addReg(0)
+      .addGlobalAddress(TargetCS, 0, OpFlag)
+      .addReg(0);
+  addRegOffset(BuildMI(MBB, DebugLoc(), TII->get(X86::MOV16rm), X86::AX),
+               X86::RAX, /*isKill=*/true, 0);
+
+  // Move the segment selector onto the stack.
+  addRegOffset(BuildMI(MBB, DebugLoc(), TII->get(X86::MOV16mr)),
+               X86::RSP, /*isKill=*/false, 4)
+      .addReg(X86::AX, getKillRegState(true));
+
+  // Call the function.
+  addRegOffset(BuildMI(MBB, DebugLoc(), TII->get(X86::FARCALL32m)),
+               X86::RSP, /*isKill=*/false, 0);
+
+  // If this is a cdecl thunk, we can just return now.
+  if (CC == CallingConv::X86_64_C32) {
+    // This is really a 32-bit return, but in 64-bit mode we can't directly
+    // encode 32-bit branch instructions.
+    BuildMI(MBB, DebugLoc(), TII->get(X86::RETQ));
+  } else {
+    // This follows one of the callee-pop conventions. We need to use a popping
+    // return. But first we have to work out how many bytes to pop.
+    bool FoundECX = false, FoundEDX = false;
+    unsigned PopAmt = 0;
+    FunctionType *FnTy = Fn.getFunctionType();
+    for (unsigned i = 0; i < FnTy->getNumParams(); ++i) {
+      // Ignore the 'thunkdata' parameter; that's a hidden parameter that is
+      // always passed in a register. It's only used when calling a 32-bit
+      // function pointer.
+      if (Fn.hasParamAttribute(i, Attribute::ThunkData))
+        continue;
+      Type *ParamTy = FnTy->getParamType(i);
+      const DataLayout &DL = M.getDataLayout();
+      // For fastcall, the first two integers that fit in 4 bytes are in ECX and
+      // EDX. For thiscall, only the first such argument is in ECX; further,
+      // sret arguments are always passed on the stack.
+      if ((CC == CallingConv::X86_FastCall ||
+           (CC == CallingConv::X86_ThisCall &&
+            !Fn.hasParamAttribute(i, Attribute::StructRet))) &&
+          !FoundECX && ParamTy->isIntegerTy() &&
+          DL.getTypeStoreSize(ParamTy) <= 4) {
+        FoundECX = true;
+        continue;
+      }
+      if (CC == CallingConv::X86_FastCall && !FoundEDX &&
+          ParamTy->isIntegerTy() && DL.getTypeStoreSize(ParamTy) <= 4) {
+        FoundEDX = true;
+        continue;
+      }
+      // Otherwise, it's passed on the stack.
+      PopAmt += getTypeStackSize(DL, ParamTy);
+    }
+
+    // Now we can pop the required number of bytes.
+    BuildMI(MBB, DebugLoc(), TII->get(X86::RETIQ)).addImm(PopAmt);
+  }
+
+  // Now for the 64-bit side of the thunk.
+  // We need to move the far return address over the far target address.
+  BuildMI(MBB64, DebugLoc(), TII->get(X86::POP64r), X86::RAX);
+  addRegOffset(BuildMI(MBB64, DebugLoc(), TII->get(X86::MOV64mr)),
+               X86::ESP, /*isKill=*/false, 0)
+      .addReg(X86::RAX);
+  // Do the call.
+  BuildMI(MBB64, DebugLoc(), TII->get(X86::CALL64pcrel32))
+      .addGlobalAddress(&Fn);
+  // Return far. This needs to be a 32-bit return, since we were called by
+  // 32-bit code.
+  BuildMI(MBB64, DebugLoc(), TII->get(X86::LRETL));
+
+  // Add the 64-bit part as a successor of the 32-bit part.
+  MBB->addSuccessorWithoutProb(MBB64);
+  MBB64->setHasAddressTaken();
+}
+
+Function *X866432InteropThunkInserter::getOrInsertFarCallHelper(
+    Module &M, unsigned PopAmount, StringRef Prefix,
+    StringRef CS32Name, StringRef CS64Name) {
+  FunctionType *HelperTy = llvm::FunctionType::get(
+      llvm::IntegerType::get(M.getContext(), 32),
+      llvm::PointerType::get(llvm::IntegerType::get(M.getContext(), 8), 32),
+      /*isVarArg=*/true);
+  std::string HelperName = (Prefix + "invoke32_" +utostr(PopAmount)).str();
+
+  Function *Helper = M.getFunction(HelperName);
+  // If the function is already defined, there's nothing to do.
+  if (Helper && !Helper->empty())
+    return Helper;
+
+  // If we have to define the helper ourselves, make sure it's of the right
+  // type.
+  if (Helper && Helper->getFunctionType() != HelperTy)
+    M.getFunctionList().erase(Helper);
+  Helper = cast<Function>(M.getOrInsertFunction(HelperName, HelperTy));
+
+  Helper->setLinkage(GlobalValue::LinkOnceAnyLinkage);
+  // Give the function a body so it will get emitted.
+  auto *BB = BasicBlock::Create(M.getContext(), "", Helper);
+  new UnreachableInst(M.getContext(), BB);
+
+  MachineFunction &MF = MMI->getOrCreateMachineFunction(*Helper);
+  auto *MBB = MF.CreateMachineBasicBlock();
+  MF.push_back(MBB);
+  STI = &MF.getSubtarget<X86Subtarget>();
+  TII = STI->getInstrInfo();
+
+  auto *Call64MBB = MF.CreateMachineBasicBlock();
+  auto *Call32MBB = MF.CreateMachineBasicBlock();
+  MF.push_back(Call64MBB);
+  MF.push_back(Call32MBB);
+
+  // This MBB has an IR-level basic block underlying it so it can be addressed.
+  auto *MBB32 = MF.CreateMachineBasicBlock(BB);
+  MF.push_back(MBB32);
+
+  auto *CS32 = getExternalObject(M, CS32Name);
+  auto *CS64 = getExternalObject(M, CS64Name);
+
+  // Get the target address.
+  addRegOffset(BuildMI(MBB, DebugLoc(), TII->get(X86::MOV32rm), X86::R8D),
+               X86::EAX, /*isKill=*/false, 8);
+
+  // First, check that the pointer is properly aligned.
+  BuildMI(MBB, DebugLoc(), TII->get(X86::TEST32ri), X86::R8D)
+      .addImm(0xf);
+  // If it's misaligned, it's probably not one of ours.
+  BuildMI(MBB, DebugLoc(), TII->get(X86::JNE_1)).addMBB(Call32MBB);
+
+  // Then, check that the hotpatch signature is untouched (8b ff).
+  addRegOffset(BuildMI(MBB, DebugLoc(), TII->get(X86::CMP16mi)),
+               X86::R8D, /*isKill=*/false, 0)
+      .addImm(0xff8b);
+  // If it was hotpatched, then we need to invoke the hotpatched code.
+  BuildMI(MBB, DebugLoc(), TII->get(X86::JNE_1)).addMBB(Call32MBB);
+
+  // Now, check that the signature marking this as a thunk is present.
+  // There's no CMP64mi with a 64-bit operand, so we need to load the
+  // signature into a register first.
+  BuildMI(MBB, DebugLoc(), TII->get(X86::MOV64ri), X86::R9)
+      .addImm(0x77496e4554683332 /* 'wInETh32' */);
+  addRegOffset(BuildMI(MBB, DebugLoc(), TII->get(X86::CMP64mr)),
+               X86::R8D, /*isKill=*/false, -8)
+      .addReg(X86::R9);
+  // If this isn't one of ours, we can't invoke it 64-bit.
+  BuildMI(MBB, DebugLoc(), TII->get(X86::JNE_1)).addMBB(Call32MBB);
+
+  // Otherwise, this is a 64-bit function, and we can invoke it as such.
+  //BuildMI(MBB, DebugLoc(), TII->get(X86::JMP_1)).addMBB(Call64MBB);
+
+  // Now we can prepare the 64-bit call. Get the address of the actual
+  // function. To do *that*, first we need to get the address of the 64-bit
+  // side of the thunk. Exactly 16 bytes prior is the offset of the target
+  // function from the PIC base of the thunk. We should be able to get the full
+  // address with one LEA.
+  addRegOffset(BuildMI(Call64MBB, DebugLoc(), TII->get(X86::MOV32rm), X86::EAX),
+               X86::R8D, /*isKill=*/false, -16);
+  BuildMI(Call64MBB, DebugLoc(), TII->get(X86::LEA64_32r), X86::R8D)
+      .addReg(X86::R8D, getKillRegState(true))
+      .addImm(1)
+      .addReg(X86::EAX)
+      .addImm(7)
+      .addReg(0);
+
+  // The target address is now in R8.
+  // What happens next depends on whether or not we're expected to pop the
+  // arguments.
+  if (PopAmount) {
+    // Here, we need to pop the stack, because the caller is expecting the
+    // *32-bit callee* to do that, so we can't tail-call. So, adjust the stack,
+    // call the target normally, then do a popping return.
+    BuildMI(Call64MBB, DebugLoc(), TII->get(X86::SUB32ri8), X86::ESP)
+        .addReg(X86::ESP)
+        .addImm(4);
+    BuildMI(Call64MBB, DebugLoc(), TII->get(X86::CALL64r)).addReg(X86::R8);
+    BuildMI(Call64MBB, DebugLoc(), TII->get(X86::ADD32ri8), X86::ESP)
+        .addReg(X86::ESP)
+        .addImm(4);
+    BuildMI(Call64MBB, DebugLoc(), TII->get(X86::RETIQ)).addImm(PopAmount);
+  } else {
+    // Adjust the stack, then tail-call the function.
+    addRegOffset(BuildMI(Call64MBB,DebugLoc(),TII->get(X86::MOV64rm),X86::RAX),
+                 X86::ESP, /*isKill=*/false, 8);
+    BuildMI(Call64MBB, DebugLoc(), TII->get(X86::SUB32ri8), X86::ESP)
+        .addReg(X86::ESP)
+        .addImm(4);
+    BuildMI(Call64MBB, DebugLoc(), TII->get(X86::PUSH64r))
+        .addReg(X86::RAX, getKillRegState(true));
+    BuildMI(Call64MBB, DebugLoc(), TII->get(X86::JMP64r)).addReg(X86::R8);
+    // No need for a RET here.
+  }
+
+  // Now for the 32-bit invoke. But first, make sure we're inside the VM.
+  // Otherwise, we can't make a 32-bit call.
+  // FIXME: If we're not in the VM, then we should try to enter it.
+  BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV16rs), X86::R8W)
+      .addReg(X86::CS);
+  unsigned OpFlags = STI->classifyGlobalReference(CS64);
+  unsigned BaseReg = STI->isPICStyleRIPRel() ? X86::RIP : 0;
+  if (!isGlobalStubReference(OpFlags)) {
+    BuildMI(Call32MBB, DebugLoc(), TII->get(X86::CMP16rm), X86::R8W)
+        .addReg(BaseReg)
+        .addImm(1)
+        .addReg(0)
+        .addGlobalAddress(CS64, 0, OpFlags)
+        .addReg(0);
+  } else {
+    BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV64rm), X86::R9)
+        .addReg(BaseReg)
+        .addImm(1)
+        .addReg(0)
+        .addGlobalAddress(CS64, 0, OpFlags)
+        .addReg(0);
+    BuildMI(Call32MBB, DebugLoc(), TII->get(X86::CMP16rm), X86::R8W)
+        .addReg(X86::R9)
+        .addImm(1)
+        .addReg(0)
+        .addImm(0)
+        .addReg(0);
+  }
+  BuildMI(Call32MBB, DebugLoc(), TII->get(X86::JNE_1)).addMBB(Call64MBB);
+
+  // We need to save the real return address, as well as RBX, RSI, and RDI.
+  // The 32-bit code will likely overwrite their 32-bit counterparts, and
+  // thereby clear their upper halves.
+  addRegOffset(BuildMI(Call32MBB, DebugLoc(), TII->get(X86::POP64rmm)),
+               X86::EAX, /*isKill=*/false, 16);
+  addRegOffset(BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV64mr)),
+               X86::EAX, /*isKill=*/false, 24)
+      .addReg(X86::RBX);
+  addRegOffset(BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV64mr)),
+               X86::EAX, /*isKill=*/false, 32)
+      .addReg(X86::RSI);
+  addRegOffset(BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV64mr)),
+               X86::EAX, /*isKill=*/false, 40)
+      .addReg(X86::RDI);
+
+  // Fetch both parts of the target address.
+  BuildMI(Call32MBB, DebugLoc(), TII->get(X86::LEA64_32r), X86::R8D)
+      .addReg(BaseReg)
+      .addImm(1)
+      .addReg(0)
+      .addBlockAddress(BlockAddress::get(BB))
+      .addReg(0);
+  OpFlags = STI->classifyGlobalReference(CS32);
+  if (!isGlobalStubReference(OpFlags)) {
+    BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV16rm), X86::R9W)
+        .addReg(BaseReg)
+        .addImm(1)
+        .addReg(0)
+        .addGlobalAddress(CS32, 0, OpFlags)
+        .addReg(0);
+  } else {
+    BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV64rm), X86::R9)
+        .addReg(BaseReg)
+        .addImm(1)
+        .addReg(0)
+        .addGlobalAddress(CS32, 0, OpFlags)
+        .addReg(0);
+    BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV16rm), X86::R9W)
+        .addReg(X86::R9)
+        .addImm(1)
+        .addReg(0)
+        .addImm(0)
+        .addReg(0);
+  }
+  // Save the thunk data pointer while we're at it. This is a good time to
+  // do it while the CPU waits for the memory accesses to complete.
+  BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV32rr), X86::EBX)
+      .addReg(X86::EAX);
+  // Save the stack pointer, too. Some ill-behaved stdcall callbacks don't
+  // obey the rules of the stdcall convention and pop the stack.
+  BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV32rr), X86::ESI)
+      .addReg(X86::ESP);
+  // Put the target far address onto the stack.
+  BuildMI(Call32MBB, DebugLoc(), TII->get(X86::SUB32ri8), X86::ESP)
+      .addReg(X86::ESP)
+      .addImm(8);
+  addRegOffset(BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV32mr)),
+               X86::ESP, /*isKill=*/false, 0)
+      .addReg(X86::R8D);
+  addRegOffset(BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV16mr)),
+               X86::ESP, /*isKill=*/false, 4)
+      .addReg(X86::R9W);
+
+  // Make the call.
+  addRegOffset(BuildMI(Call32MBB, DebugLoc(), TII->get(X86::FARCALL32m)),
+               X86::ESP, /*isKill=*/false, 0);
+
+  // Restore the registers we saved, and the proper return address.
+  BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV32rr), X86::ESP)
+      .addReg(X86::ESI);
+  addRegOffset(BuildMI(Call32MBB, DebugLoc(), TII->get(X86::PUSH64rmm)),
+               X86::EBX, /*isKill=*/false, 16);
+  addRegOffset(BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV64rm), X86::RDI),
+               X86::EBX, /*isKill=*/false, 40);
+  addRegOffset(BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV64rm), X86::RSI),
+               X86::EBX, /*isKill=*/false, 32);
+  addRegOffset(BuildMI(Call32MBB, DebugLoc(), TII->get(X86::MOV64rm), X86::RBX),
+               X86::EBX, /*isKill=*/true, 24);
+
+  // Return to caller.
+  if (PopAmount)
+    BuildMI(Call32MBB, DebugLoc(), TII->get(X86::RETIQ)).addImm(PopAmount);
+  else
+    BuildMI(Call32MBB, DebugLoc(), TII->get(X86::RETQ));
+
+  // And now for the 32-bit part.
+  // Fetch the far return address, and save it in the thunk data.
+  // We use "64-bit" instructions here, even though this is 32-bit code,
+  // because the compiler is still in 64-bit mode and we can't use the
+  // corresponding 32-bit instructions here. Don't worry; these will encode
+  // the same as their 32-bit counterparts, so this should work.
+  addRegOffset(BuildMI(MBB32, DebugLoc(), TII->get(X86::POP64rmm)),
+               X86::RBX, /*isKill=*/false, 0);
+  addRegOffset(BuildMI(MBB32, DebugLoc(), TII->get(X86::POP64rmm)),
+               X86::RBX, /*isKill=*/false, 4);
+  // Remove the target address from the stack.
+  BuildMI(MBB32, DebugLoc(), TII->get(X86::ADD32ri8), X86::RSP)
+      .addReg(X86::RSP)
+      .addImm(8);
+
+  // Now we're ready to near-call the target function.
+  addRegOffset(BuildMI(MBB32, DebugLoc(), TII->get(X86::CALL64m)),
+               X86::RBX, /*isKill=*/false, 8);
+
+  // Restore the original far return address. Luckily for us, the 64-bit
+  // side was kind enough to stash the thunk data pointer in the non-volatile
+  // EBX register.
+  addRegOffset(BuildMI(MBB32, DebugLoc(), TII->get(X86::PUSH64rmm)),
+               X86::RBX, /*isKill=*/false, 4);
+  addRegOffset(BuildMI(MBB32, DebugLoc(), TII->get(X86::PUSH64rmm)),
+               X86::RBX, /*isKill=*/false, 0);
+
+  // Now return.
+  BuildMI(MBB32, DebugLoc(), TII->get(X86::LRETL));
+
+  // Add the 32-bit part as a successor of the call-32 block.
+  Call32MBB->addSuccessorWithoutProb(MBB32);
+  MBB32->setHasAddressTaken();
+
+  return Helper;
+}
+
+GlobalValue *X866432InteropThunkInserter::getExternalObject(
+    Module &M, StringRef Name) {
+  auto *Value = M.getNamedValue(Name);
+  if (Value)
+    return Value;
+  return new GlobalVariable(M, IntegerType::get(M.getContext(), 16),
+                            false, GlobalValue::ExternalLinkage, nullptr,
+                            Name, nullptr, GlobalVariable::NotThreadLocal, 32,
+                            /*isExternallyInitialized=*/true);
+}
+
+bool X866432InteropThunkInserter::expandFarCallPseudos(Module &M, Function &Fn){
+  MachineFunction &MF = MMI->getOrCreateMachineFunction(Fn);
+  bool Modified = false;
+
+  STI = &MF.getSubtarget<X86Subtarget>();
+  TII = STI->getInstrInfo();
+
+  StringRef Prefix = "__i386_on_x86_64_";
+  if (Fn.hasFnAttribute("thunk-prefix"))
+    Prefix = Fn.getFnAttribute("thunk-prefix").getValueAsString();
+  StringRef CS32Name = "__i386_on_x86_64_cs32";
+  if (Fn.hasFnAttribute("thunk-cs32-name"))
+    CS32Name = Fn.getFnAttribute("thunk-cs32-name").getValueAsString();
+  StringRef CS64Name = "__i386_on_x86_64_cs64";
+  if (Fn.hasFnAttribute("thunk-cs64-name"))
+    CS64Name = Fn.getFnAttribute("thunk-cs64-name").getValueAsString();
+
+  for (auto &MBB : MF)
+    Modified |= expandMBB(M, MBB, Prefix, CS32Name, CS64Name);
+  return Modified;
+}
+
+bool X866432InteropThunkInserter::expandMBB(
+    Module &M, MachineBasicBlock &MBB, StringRef Prefix,
+    StringRef CS32Name, StringRef CS64Name) {
+  bool Modified = false;
+
+  // MBBI may be invalidated by the expansion.
+  MachineBasicBlock::iterator MBBI = MBB.begin(), E = MBB.end();
+  while (MBBI != E) {
+    MachineBasicBlock::iterator NMBBI = std::next(MBBI);
+    Modified |= expandMI(M, MBB, MBBI, Prefix, CS32Name, CS64Name);
+    MBBI = NMBBI;
+  }
+
+  return Modified;
+}
+
+bool X866432InteropThunkInserter::expandMI(
+    Module &M, MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI,
+    StringRef Prefix, StringRef CS32Name, StringRef CS64Name) {
+  MachineInstr &MI = *MBBI;
+  unsigned Opcode = MI.getOpcode();
+
+  if (Opcode != X86::FARCALL6432r && Opcode != X86::FARCALL6432m)
+    return false;
+
+  DebugLoc DL = MBBI->getDebugLoc();
+  MachineOperand &JumpTarget = MBBI->getOperand(0);
+  unsigned PopAmount =
+      MBBI->getOperand(Opcode == X86::FARCALL6432m ? 5 : 1).getImm();
+
+  // Jump to label or value in register.
+  unsigned JumpAddrReg;
+  if (Opcode == X86::FARCALL6432m) {
+    MachineInstrBuilder MIB = BuildMI(MBB, MBBI, DL, TII->get(X86::MOV32rm));
+    JumpAddrReg = X86::R8D;
+    MIB.addReg(JumpAddrReg, RegState::Define);
+    for (unsigned i = 0; i != 5; ++i)
+      MIB.add(MBBI->getOperand(i));
+  } else {
+    JumpAddrReg = JumpTarget.getReg();
+  }
+
+  // Write the offset to the thunk data.
+  addRegOffset(BuildMI(MBB, MBBI, DL, TII->get(X86::MOV64mr)),
+               X86::EAX, /*isKill=*/false, 8)
+      .addReg(getX86SubSuperRegister(JumpAddrReg, 64), RegState::Kill);
+  // If the helper doesn't exist, create it.
+  Function *Helper = getOrInsertFarCallHelper(
+      M, PopAmount, Prefix, CS32Name, CS64Name);
+  // Call the helper.
+  BuildMI(MBB, MBBI, DL, TII->get(X86::CALL64pcrel32))
+      .addGlobalAddress(Helper);
+
+  MachineInstr &NewMI = *std::prev(MBBI);
+  NewMI.copyImplicitOps(*MBBI->getParent()->getParent(), *MBBI);
+
+  // Delete the pseudo instruction.
+  MBB.erase(MBBI);
+
+  return true;
+}
+
+bool X866432InteropThunkInserter::runOnModule(Module &M) {
+  bool Modified = false;
+
+  MMI = &getAnalysis<MachineModuleInfo>();
+
+  scanExistingAsmSymbols(M);
+  for (auto &Fn : M) {
+    // Don't use '||'. That'll short circuit if the first function returns
+    // true.
+    Modified |= generateThunks(M, Fn);
+    Modified |= expandFarCallPseudos(M, Fn);
+  }
+
+  return Modified;
+}
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86AsmPrinter.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86AsmPrinter.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86AsmPrinter.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86AsmPrinter.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -86,6 +86,70 @@
   return false;
 }
 
+void X86AsmPrinter::EmitConstantPool() {
+  if (MF) {
+    // If an MS hotpatch function, we need to ensure 64 (32-bit) or 128 (64-bit)
+    // bytes of padding precede the label.  This is the scratch space used
+    // by the hotpatching mechanism to insert the patch code.  The movl %edi,
+    // %edi instruction emitted as the very first instruction of a hotpatch
+    // function is usually overwritten with a short jump instruction when the
+    // patch is installed, so it will jump directly into this space.  (But
+    // don't add the space when targeting MSVC.  There, the /FUNCTIONPADMIN
+    // option to link.exe is expected to be used.)
+    const Function &Fn = MF->getFunction();
+    if (!Subtarget->isTargetKnownWindowsMSVC() &&
+        Fn.hasFnAttribute("patchable-function") &&
+        Fn.getFnAttribute("patchable-function").getValueAsString() ==
+            "ms-hotpatch") {
+      // Emit INT3 instructions instead of NOPs. If a patch runs off the end,
+      // best to let the patcher know with a crash/debug break than to silently
+      // continue, only to run into the jump back into the patch.
+      OutStreamer->emitFill(Subtarget->is64Bit() ? 128 : 64, 0xcc);
+    }
+
+    if (Fn.hasFnAttribute("thunk-32bit-side")) {
+      // If this is the 32-bit side of a thunk, we need to emit a magic
+      // signature here. That way, if we're calling out to a 32-bit function
+      // that just so happens to be a thunk to a 64-bit one, we can skip the
+      // dual far calls and just call the target directly.
+      // Align this magic number to twice the function's alignment so the thunk
+      // and the magic number should wind up on the same page. This should
+      // prevent a spurious page fault.
+      unsigned Align = std::min(1 << MF->getAlignment(), 16);
+      OutStreamer->EmitValueToAlignment(2 * Align, 0x90 /* nop */);
+      // Pad the output up to sixteen bytes before the thunk starts. We want
+      // the magic number to directly abut the thunk, since that's how callers
+      // will find it.
+      if (Align > 16)
+        OutStreamer->emitFill(Align - 16, 0x90);
+      // Emit the offset from the PIC base to the start of the target function.
+      const MCSymbol *TargetSym = OutContext.getOrCreateSymbol(
+          Fn.getFnAttribute("thunk-32bit-side").getValueAsString());
+      const MCExpr *Offset = MCBinaryExpr::createSub(
+          MCSymbolRefExpr::create(TargetSym, OutContext),
+          MCSymbolRefExpr::create(MF->getPICBaseSymbol(), OutContext),
+          OutContext);
+      OutStreamer->EmitValue(Offset, 8);
+      // We need to emit a magic number that is unmistakably *not* executable
+      // code. ASCII is usually hard to mistake for x86 machine code.
+      OutStreamer->EmitIntValue(0x77496e4554683332 /* 'wInETh32' */, 8);
+    }
+  }
+
+  AsmPrinter::EmitConstantPool();
+}
+
+const MCExpr *X86AsmPrinter::lowerConstant(const Constant *CV) {
+  const ConstantExpr *CE = dyn_cast<ConstantExpr>(CV);
+  if (CE && CE->getOpcode() == Instruction::AddrSpaceCast) {
+    // Strip the addrspacecast and pass along the operand
+    PointerType *DstTy = cast<PointerType>(CE->getType());
+    if (DstTy->getAddressSpace() == 0)
+      CV = cast<Constant>(CE->getOperand(0));
+  }
+  return AsmPrinter::lowerConstant(CV);
+}
+
 void X86AsmPrinter::EmitFunctionBodyStart() {
   if (EmitFPOData) {
     X86TargetStreamer *XTS =
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86AsmPrinter.h llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86AsmPrinter.h
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86AsmPrinter.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86AsmPrinter.h	2019-05-19 11:21:51.775903000 +0000
@@ -123,6 +123,9 @@
     SMShadowTracker.emitShadowPadding(*OutStreamer, getSubtargetInfo());
   }
 
+  void EmitConstantPool() override;
+  const MCExpr *lowerConstant(const Constant *CV) override;
+
   bool PrintAsmOperand(const MachineInstr *MI, unsigned OpNo,
                        unsigned AsmVariant, const char *ExtraCode,
                        raw_ostream &OS) override;
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86CallFrameOptimization.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86CallFrameOptimization.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86CallFrameOptimization.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86CallFrameOptimization.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -438,11 +438,17 @@
     // We really don't want to consider the unaligned case.
     if (StackDisp & (SlotSize - 1))
       return;
-    StackDisp >>= Log2SlotSize;
 
-    assert((size_t)StackDisp < Context.ArgStoreVector.size() &&
+    assert(StackDisp < TII->getFrameSize(*FrameSetup) &&
            "Function call has more parameters than the stack is adjusted for.");
 
+    // We don't want to consider the case where the stack slot extends past the
+    // stack frame, either.
+    if ((TII->getFrameSize(*FrameSetup) - StackDisp) < SlotSize)
+      return;
+
+    StackDisp >>= Log2SlotSize;
+
     // If the same stack slot is being filled twice, something's fishy.
     if (Context.ArgStoreVector[StackDisp] != nullptr)
       return;
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86CallingConv.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86CallingConv.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86CallingConv.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86CallingConv.cpp	2019-05-19 11:21:51.775903000 +0000
@@ -58,6 +58,43 @@
   return true;
 }
 
+bool CC_X86_64_C32_Assign2Regs(unsigned &ValNo, MVT &ValVT, MVT &LocVT,
+                               CCValAssign::LocInfo &LocInfo,
+                               ISD::ArgFlagsTy &ArgFlags, CCState &State) {
+  // List of GPRs that are available to store return values.
+  static const MCPhysReg RegList[] = {X86::EAX, X86::EDX};
+
+  // This vector will save all available registers for allocation.
+  SmallVector<unsigned, 2> AvailableRegs;
+
+  // Search for available registers.
+  for (auto Reg : RegList) {
+    if (!State.isAllocated(Reg))
+      AvailableRegs.push_back(Reg);
+  }
+
+  const size_t RequiredGPRsUponSplit = 2;
+  if (AvailableRegs.size() < RequiredGPRsUponSplit)
+    return false; // Not enough free registers - continue the search.
+
+  // Allocate the available registers.
+  for (unsigned I = 0; I < RequiredGPRsUponSplit; I++) {
+
+    // Mark the register as allocated.
+    unsigned Reg = State.AllocateReg(AvailableRegs[I]);
+
+    // Since we previously made sure that 2 registers are available
+    // we expect that a real register number will be returned.
+    assert(Reg && "A register should have been available!");
+
+    // Assign the value to the allocated register
+    State.addLoc(CCValAssign::getCustomReg(ValNo, ValVT, Reg, LocVT, LocInfo));
+  }
+
+  // Successful in allocating registers - stop scanning next rules.
+  return true;
+}
+
 static ArrayRef<MCPhysReg> CC_X86_VectorCallGetSSEs(const MVT &ValVT) {
   if (ValVT.is512BitVector()) {
     static const MCPhysReg RegListZMM[] = {X86::ZMM0, X86::ZMM1, X86::ZMM2,
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86CallingConv.h llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86CallingConv.h
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86CallingConv.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86CallingConv.h	2019-05-19 11:21:51.775903000 +0000
@@ -29,6 +29,14 @@
                                    CCValAssign::LocInfo &LocInfo,
                                    ISD::ArgFlagsTy &ArgFlags, CCState &State);
 
+/// When compiling a 32-bit calling convention for a 64-bit arch, special
+/// treatment is required for returning 64-bit integers.
+/// The value should be assigned to two 32-bit GPRs.
+/// \return true if registers were allocated and false otherwise.
+bool CC_X86_64_C32_Assign2Regs(unsigned &ValNo, MVT &ValVT, MVT &LocVT,
+                               CCValAssign::LocInfo &LocInfo,
+                               ISD::ArgFlagsTy &ArgFlags, CCState &State);
+
 /// Vectorcall calling convention has special handling for vector types or
 /// HVA for 64 bit arch.
 /// For HVAs shadow registers might be allocated on the first pass
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86CallingConv.td llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86CallingConv.td
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86CallingConv.td	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86CallingConv.td	2019-05-19 11:21:51.785903000 +0000
@@ -421,6 +421,18 @@
                                  RAX, R10, R11, R13, R14, R15]>>
 ]>;
 
+// Convention for 32-bit interop CCs in 64-bit mode.
+def RetCC_X86_64_C32 : CallingConv<[
+  // 64-bit integers need to be handled specially, due to 64-bit code being
+  // able to use 64-bit registers when 32-bit code cannot. Simply not
+  // specifying what to do with i64 doesn't DTRT: it uses an implicit SRet
+  // instead of splitting the value among EDX:EAX as 32-bit does.
+  CCIfType<[i64], CCCustom<"CC_X86_64_C32_Assign2Regs">>,
+
+  // Otherwise, it's the same as the normal 32-bit convention.
+  CCDelegateTo<RetCC_X86_32_C>
+]>;
+
 
 defm X86_32_RegCall :
 	 X86_RegCall_base<RC_X86_32_RegCall>;
@@ -468,7 +480,21 @@
           CCIfSubtarget<"isTargetWin64()",
                         CCDelegateTo<RetCC_X86_Win64_RegCall>>>,
   CCIfCC<"CallingConv::X86_RegCall", CCDelegateTo<RetCC_X86_SysV64_RegCall>>,
-          
+
+
+  // Handle 32-bit interop CCs.
+  CCIfCC<"CallingConv::X86_64_C32", CCDelegateTo<RetCC_X86_64_C32>>,
+  CCIfCC<"CallingConv::X86_StdCall",
+         CCIfSubtarget<"isTarget64BitWine32()",
+         CCDelegateTo<RetCC_X86_64_C32>>>,
+  CCIfCC<"CallingConv::X86_FastCall",
+         CCIfSubtarget<"isTarget64BitWine32()",
+         CCDelegateTo<RetCC_X86_64_C32>>>,
+  CCIfCC<"CallingConv::X86_ThisCall",
+         CCIfSubtarget<"isTarget64BitWine32()",
+         CCDelegateTo<RetCC_X86_64_C32>>>,
+
+
   // Mingw64 and native Win64 use Win64 CC
   CCIfSubtarget<"isTargetWin64()", CCDelegateTo<RetCC_X86_Win64_C>>,
 
@@ -792,7 +818,7 @@
   CCIfType<[i32, f32], CCAssignToStack<4, 4>>,
 
   // Doubles get 8-byte slots that are 4-byte aligned.
-  CCIfType<[f64], CCAssignToStack<8, 4>>,
+  CCIfType<[i64, f64], CCAssignToStack<8, 4>>,
 
   // Long doubles get slots whose size depends on the subtarget.
   CCIfType<[f80], CCAssignToStack<0, 4>>,
@@ -825,6 +851,9 @@
   // The 'nest' parameter, if any, is passed in ECX.
   CCIfNest<CCAssignToReg<[ECX]>>,
 
+  // The thunk data is always passed in EAX.
+  CCIfSubtarget<"isTarget64BitWine32()", CCIfThunkData<CCAssignToReg<[EAX]>>>,
+
   // The first 3 integer arguments, if marked 'inreg' and if the call is not
   // a vararg call, are passed in integer registers.
   CCIfNotVarArg<CCIfInReg<CCIfType<[i32], CCAssignToReg<[EAX, EDX, ECX]>>>>,
@@ -857,6 +886,9 @@
   // The 'nest' parameter, if any, is passed in EAX.
   CCIfNest<CCAssignToReg<[EAX]>>,
 
+  // The thunk data is always passed in EAX.
+  CCIfSubtarget<"isTarget64BitWine32()", CCIfThunkData<CCAssignToReg<[EAX]>>>,
+
   // The first 2 integer arguments are passed in ECX/EDX
   CCIfInReg<CCIfType<[ i8], CCAssignToReg<[ CL,  DL]>>>,
   CCIfInReg<CCIfType<[i16], CCAssignToReg<[ CX,  DX]>>>,
@@ -875,6 +907,9 @@
 ]>;
 
 def CC_X86_32_ThisCall_Common : CallingConv<[
+  // The thunk data is always passed in EAX.
+  CCIfSubtarget<"isTarget64BitWine32()", CCIfThunkData<CCAssignToReg<[EAX]>>>,
+
   // The first integer argument is passed in ECX
   CCIfType<[i32], CCAssignToReg<[ECX]>>,
 
@@ -1029,6 +1064,15 @@
   CCIfCC<"CallingConv::X86_RegCall", CCDelegateTo<CC_X86_SysV64_RegCall>>,
   CCIfCC<"CallingConv::X86_INTR", CCDelegateTo<CC_X86_64_Intr>>,
 
+  // Handle 32-bit interop CCs.
+  CCIfCC<"CallingConv::X86_64_C32", CCDelegateTo<CC_X86_32_C>>,
+  CCIfCC<"CallingConv::X86_StdCall",
+         CCIfSubtarget<"isTarget64BitWine32()", CCDelegateTo<CC_X86_32_C>>>,
+  CCIfCC<"CallingConv::X86_FastCall",
+         CCIfSubtarget<"isTarget64BitWine32()", CCDelegateTo<CC_X86_32_FastCall>>>,
+  CCIfCC<"CallingConv::X86_ThisCall",
+         CCIfSubtarget<"isTarget64BitWine32()", CCDelegateTo<CC_X86_32_ThisCall>>>,
+
   // Mingw64 and native Win64 use Win64 CC
   CCIfSubtarget<"isTargetWin64()", CCDelegateTo<CC_X86_Win64_C>>,
 
@@ -1049,13 +1093,15 @@
 
 def CSR_NoRegs : CalleeSavedRegs<(add)>;
 
-def CSR_32 : CalleeSavedRegs<(add ESI, EDI, EBX, EBP)>;
-def CSR_64 : CalleeSavedRegs<(add RBX, R12, R13, R14, R15, RBP)>;
+def CSR_32   : CalleeSavedRegs<(add ESI, EDI, EBX, EBP)>;
+def CSR_6432 : CalleeSavedRegs<(add RSI, RDI, RBX, RBP)>;
+def CSR_64   : CalleeSavedRegs<(add RBX, R12, R13, R14, R15, RBP)>;
 
 def CSR_64_SwiftError : CalleeSavedRegs<(sub CSR_64, R12)>;
 
-def CSR_32EHRet : CalleeSavedRegs<(add EAX, EDX, CSR_32)>;
-def CSR_64EHRet : CalleeSavedRegs<(add RAX, RDX, CSR_64)>;
+def CSR_32EHRet   : CalleeSavedRegs<(add EAX, EDX, CSR_32)>;
+def CSR_6432EHRet : CalleeSavedRegs<(add RAX, RDX, CSR_6432)>;
+def CSR_64EHRet   : CalleeSavedRegs<(add RAX, RDX, CSR_64)>;
 
 def CSR_Win64_NoSSE : CalleeSavedRegs<(add RBX, RBP, RDI, RSI, R12, R13, R14, R15)>;
 
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86ExpandPseudo.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86ExpandPseudo.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86ExpandPseudo.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86ExpandPseudo.cpp	2019-05-19 11:21:51.785903000 +0000
@@ -275,7 +275,8 @@
     MachineOperand &DestAddr = MBBI->getOperand(0);
     assert(DestAddr.isReg() && "Offset should be in register!");
     const bool Uses64BitFramePtr =
-        STI->isTarget64BitLP64() || STI->isTargetNaCl64();
+        (STI->isTarget64BitLP64() && !STI->isTarget64BitWine32()) ||
+        STI->isTargetNaCl64();
     unsigned StackPtr = TRI->getStackRegister();
     BuildMI(MBB, MBBI, DL,
             TII->get(Uses64BitFramePtr ? X86::MOV64rr : X86::MOV32rr), StackPtr)
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86FastISel.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86FastISel.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86FastISel.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86FastISel.cpp	2019-05-19 11:21:51.785903000 +0000
@@ -1178,7 +1178,8 @@
       CC != CallingConv::X86_StdCall &&
       CC != CallingConv::X86_ThisCall &&
       CC != CallingConv::X86_64_SysV &&
-      CC != CallingConv::Win64)
+      CC != CallingConv::Win64 &&
+      CC != CallingConv::X86_64_C32)
     return false;
 
   // Don't handle popping bytes if they don't fit the ret's immediate.
@@ -2784,7 +2785,10 @@
     EVT PtrTy = TLI.getPointerTy(DL);
 
     const Value *Op1 = II->getArgOperand(0); // The guard's value.
-    const AllocaInst *Slot = cast<AllocaInst>(II->getArgOperand(1));
+    const Value *Op2 = II->getArgOperand(1);
+    const AllocaInst *Slot = dyn_cast<AllocaInst>(Op2);
+    if (!Slot)
+      Slot = cast<AllocaInst>(cast<CastInst>(Op2)->getOperand(0));
 
     MFI.setStackProtectorIndex(FuncInfo.StaticAllocaMap[Slot]);
 
@@ -3205,6 +3209,11 @@
 
   bool Is64Bit        = Subtarget->is64Bit();
   bool IsWin64        = Subtarget->isCallingConvWin64(CC);
+  bool IsInterop6432  = Subtarget->isCallingConv6432Interop(CC);
+  bool IsFarCall32    = Is64Bit && Subtarget->isTarget64BitWine32() &&
+                        Callee->getType()->isPointerTy() &&
+                        cast<PointerType>(
+                            Callee->getType())->getAddressSpace() == 32;
 
   const CallInst *CI =
       CLI.CS ? dyn_cast<CallInst>(CLI.CS->getInstruction()) : nullptr;
@@ -3226,6 +3235,10 @@
   if (Subtarget->useRetpoline())
     return false;
 
+  // If this is a 32-bit downcall, use SDISel.
+  if (IsFarCall32)
+    return false;
+
   // Handle only C, fastcc, and webkit_js calling conventions for now.
   switch (CC) {
   default: return false;
@@ -3238,6 +3251,7 @@
   case CallingConv::X86_ThisCall:
   case CallingConv::Win64:
   case CallingConv::X86_64_SysV:
+  case CallingConv::X86_64_C32:
     break;
   }
 
@@ -3260,7 +3274,7 @@
     return false;
 
   for (auto Flag : CLI.OutFlags)
-    if (Flag.isSwiftError())
+    if (Flag.isSwiftError() || Flag.isThunkData())
       return false;
 
   SmallVector<MVT, 16> OutVTs;
@@ -3320,6 +3334,8 @@
   // Allocate shadow area for Win64
   if (IsWin64)
     CCInfo.AllocateStack(32, 8);
+  if (IsInterop6432)
+    CCInfo.AllocateStack(12, 4);
 
   CCInfo.AnalyzeCallOperands(OutVTs, OutFlags, CC_X86);
 
@@ -3549,7 +3565,8 @@
 
   // Issue CALLSEQ_END
   unsigned NumBytesForCalleeToPop =
-      X86::isCalleePop(CC, Subtarget->is64Bit(), IsVarArg,
+      X86::isCalleePop(CC, Subtarget->is64Bit(),
+                       Subtarget->isTarget64BitWine32(), IsVarArg,
                        TM.Options.GuaranteedTailCallOpt)
           ? NumBytes // Callee pops everything.
           : computeBytesPoppedByCalleeForSRet(Subtarget, CC, CLI.CS);
@@ -3871,7 +3888,7 @@
     } else {
       unsigned Opc =
           TLI.getPointerTy(DL) == MVT::i32
-              ? (Subtarget->isTarget64BitILP32() ? X86::LEA64_32r : X86::LEA32r)
+              ? (Subtarget->is64Bit() ? X86::LEA64_32r : X86::LEA32r)
               : X86::LEA64r;
       addFullAddress(BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
                              TII.get(Opc), ResultReg), AM);
@@ -3916,7 +3933,7 @@
     return 0;
   unsigned Opc =
       TLI.getPointerTy(DL) == MVT::i32
-          ? (Subtarget->isTarget64BitILP32() ? X86::LEA64_32r : X86::LEA32r)
+          ? (Subtarget->is64Bit() ? X86::LEA64_32r : X86::LEA32r)
           : X86::LEA64r;
   const TargetRegisterClass *RC = TLI.getRegClassFor(TLI.getPointerTy(DL));
   unsigned ResultReg = createResultReg(RC);
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86FrameLowering.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86FrameLowering.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86FrameLowering.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86FrameLowering.cpp	2019-05-19 11:21:51.785903000 +0000
@@ -45,7 +45,8 @@
   Is64Bit = STI.is64Bit();
   IsLP64 = STI.isTarget64BitLP64();
   // standard x86_64 and NaCl use 64-bit frame/stack pointers, x32 - 32-bit.
-  Uses64BitFramePtr = STI.isTarget64BitLP64() || STI.isTargetNaCl64();
+  Uses64BitFramePtr = (STI.isTarget64BitLP64() && !STI.isTarget64BitWine32()) ||
+                      STI.isTargetNaCl64();
   StackPtr = TRI->getStackRegister();
 }
 
@@ -984,9 +985,13 @@
   bool NeedsWinCFI = NeedsWin64CFI || NeedsWinFPO;
   bool NeedsDwarfCFI =
       !IsWin64Prologue && (MMI.hasDebugInfo() || Fn.needsUnwindTableEntry());
+  bool IsMSHotpatch =
+      Fn.hasFnAttribute("patchable-function") &&
+      Fn.getFnAttribute("patchable-function").getValueAsString() ==
+          "ms-hotpatch";
   unsigned FramePtr = TRI->getFrameRegister(MF);
   const unsigned MachineFramePtr =
-      STI.isTarget64BitILP32()
+      (STI.isTarget64BitILP32() || STI.isTarget64BitWine32())
           ? getX86SubSuperRegister(FramePtr, 64) : FramePtr;
   unsigned BasePtr = TRI->getBaseRegister();
   bool HasWinCFI = false;
@@ -1140,7 +1145,9 @@
     if (!IsWin64Prologue && !IsFunclet) {
       // Update EBP with the new base value.
       BuildMI(MBB, MBBI, DL,
-              TII.get(Uses64BitFramePtr ? X86::MOV64rr : X86::MOV32rr),
+              TII.get(IsMSHotpatch ?
+                      (Uses64BitFramePtr ? X86::MOV64rr_REV : X86::MOV32rr_REV):
+                      (Uses64BitFramePtr ? X86::MOV64rr : X86::MOV32rr)),
               FramePtr)
           .addReg(StackPtr)
           .setMIFlag(MachineInstr::FrameSetup);
@@ -1580,9 +1587,11 @@
     DL = MBBI->getDebugLoc();
   // standard x86_64 and NaCl use 64-bit frame/stack pointers, x32 - 32-bit.
   const bool Is64BitILP32 = STI.isTarget64BitILP32();
+  const bool Is64BitWine32 = STI.isTarget64BitWine32();
   unsigned FramePtr = TRI->getFrameRegister(MF);
   unsigned MachineFramePtr =
-      Is64BitILP32 ? getX86SubSuperRegister(FramePtr, 64) : FramePtr;
+      (Is64BitILP32 || Is64BitWine32)
+          ? getX86SubSuperRegister(FramePtr, 64) : FramePtr;
 
   bool IsWin64Prologue = MF.getTarget().getMCAsmInfo()->usesWindowsCFI();
   bool NeedsWin64CFI =
@@ -2175,7 +2184,7 @@
   // Spill the BasePtr if it's used.
   if (TRI->hasBasePointer(MF)){
     unsigned BasePtr = TRI->getBaseRegister();
-    if (STI.isTarget64BitILP32())
+    if (STI.isTarget64BitILP32() || STI.isTarget64BitWine32())
       BasePtr = getX86SubSuperRegister(BasePtr, 64);
     SavedRegs.set(BasePtr);
   }
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86ISelDAGToDAG.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86ISelDAGToDAG.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86ISelDAGToDAG.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86ISelDAGToDAG.cpp	2019-05-19 11:21:51.785903000 +0000
@@ -255,7 +255,7 @@
       Base = (AM.BaseType == X86ISelAddressMode::FrameIndexBase)
                  ? CurDAG->getTargetFrameIndex(
                        AM.Base_FrameIndex,
-                       TLI->getPointerTy(CurDAG->getDataLayout()))
+                       TLI->getFrameIndexTy(CurDAG->getDataLayout()))
                  : AM.Base_Reg;
       Scale = getI8Imm(AM.Scale, DL);
       Index = AM.IndexReg;
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86ISelLowering.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86ISelLowering.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86ISelLowering.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86ISelLowering.cpp	2019-05-19 11:21:51.785903000 +0000
@@ -308,6 +308,12 @@
   } else if (!Subtarget.is64Bit())
     setOperationAction(ISD::BITCAST      , MVT::i64  , Custom);
 
+  if (Subtarget.isTarget64BitWine32()) {
+    setOperationAction(ISD::ADDRSPACECAST, MVT::i32, Custom);
+    setOperationAction(ISD::ADDRSPACECAST, MVT::i64, Custom);
+    setOperationAction(ISD::BUILD_PAIR, MVT::i64, Expand);
+  }
+
   // Scalar integer divide and remainder are lowered to use operations that
   // produce two results, to match the available instructions. This exposes
   // the two-result form to trivial CSE, which is able to combine x/y and x%y
@@ -510,6 +516,8 @@
   setOperationAction(ISD::STACKRESTORE,       MVT::Other, Expand);
 
   setOperationAction(ISD::DYNAMIC_STACKALLOC, PtrVT, Custom);
+  if (Subtarget.isTarget64BitWine32())
+    setOperationAction(ISD::DYNAMIC_STACKALLOC, MVT::i32, Custom);
 
   // GC_TRANSITION_START and GC_TRANSITION_END need custom lowering.
   setOperationAction(ISD::GC_TRANSITION_START, MVT::Other, Custom);
@@ -1780,7 +1788,7 @@
 
 SDValue X86TargetLowering::emitStackGuardXorFP(SelectionDAG &DAG, SDValue Val,
                                                const SDLoc &DL) const {
-  EVT PtrTy = getPointerTy(DAG.getDataLayout());
+  EVT PtrTy = getFrameIndexTy(DAG.getDataLayout());
   unsigned XorOp = Subtarget.is64Bit() ? X86::XOR64_FP : X86::XOR32_FP;
   MachineSDNode *Node = DAG.getMachineNode(XorOp, DL, PtrTy, Val);
   return SDValue(Node, 0);
@@ -2136,7 +2144,8 @@
         M.getOrInsertFunction("__security_check_cookie",
                               Type::getVoidTy(M.getContext()),
                               Type::getInt8PtrTy(M.getContext())));
-    SecurityCheckCookie->setCallingConv(CallingConv::X86_FastCall);
+    if (Subtarget.is32Bit())
+      SecurityCheckCookie->setCallingConv(CallingConv::X86_FastCall);
     SecurityCheckCookie->addAttribute(1, Attribute::AttrKind::InReg);
     return;
   }
@@ -2191,9 +2200,33 @@
                                             unsigned DestAS) const {
   assert(SrcAS != DestAS && "Expected different address spaces!");
 
+  if (Subtarget.isTarget64BitWine32() && (SrcAS == 32 || DestAS == 32))
+    return false;
   return SrcAS < 256 && DestAS < 256;
 }
 
+bool X86TargetLowering::isCheapAddrSpaceCast(unsigned SrcAS,
+                                             unsigned DestAS) const {
+  assert(SrcAS != DestAS && "Expected different address spaces!");
+
+  if (Subtarget.isTarget64BitWine32() && (SrcAS == 32 || DestAS == 32))
+    return true;
+  return isNoopAddrSpaceCast(SrcAS, DestAS);
+}
+
+bool X86TargetLowering::isLosslessAddrSpaceCast(unsigned SrcAS,
+                                             unsigned DestAS) const {
+  assert(SrcAS != DestAS && "Expected different address spaces!");
+
+  if (Subtarget.isTarget64BitWine32()) {
+    if (SrcAS == 32 && DestAS == 0)
+      return true;
+    if (SrcAS == 0 && DestAS == 32)
+      return false;
+  }
+  return isNoopAddrSpaceCast(SrcAS, DestAS);
+}
+
 //===----------------------------------------------------------------------===//
 //               Return Value Calling Convention Implementation
 //===----------------------------------------------------------------------===//
@@ -2245,6 +2278,23 @@
   return DAG.getNode(ISD::ANY_EXTEND, Dl, ValLoc, ValArg);
 }
 
+/// Breaks a 64-bit value into two registers and adds the new node to the DAG.
+static void Pass64BitArgInRegs(
+    const SDLoc &dl, SelectionDAG &DAG, SDValue Chain, SDValue &Arg,
+    SmallVector<std::pair<unsigned, SDValue>, 8> &RegsToPass, CCValAssign &VA,
+    CCValAssign &NextVA) {
+  // Split the value into two i32 values.
+  SDValue Lo, Hi;
+  Lo = DAG.getNode(ISD::EXTRACT_ELEMENT, dl, MVT::i32, Arg,
+                   DAG.getConstant(0, dl, MVT::i32));
+  Hi = DAG.getNode(ISD::EXTRACT_ELEMENT, dl, MVT::i32, Arg,
+                   DAG.getConstant(1, dl, MVT::i32));
+
+  // Attach the two i32 values to their corresponding registers.
+  RegsToPass.push_back(std::make_pair(VA.getLocReg(), Lo));
+  RegsToPass.push_back(std::make_pair(NextVA.getLocReg(), Hi));
+}
+
 /// Breaks v64i1 value into two registers and adds the new node to the DAG
 static void Passv64i1ArgInRegs(
     const SDLoc &Dl, SelectionDAG &DAG, SDValue Chain, SDValue &Arg,
@@ -2259,16 +2309,20 @@
   // Before splitting the value we cast it to i64
   Arg = DAG.getBitcast(MVT::i64, Arg);
 
-  // Splitting the value into two i32 types
-  SDValue Lo, Hi;
-  Lo = DAG.getNode(ISD::EXTRACT_ELEMENT, Dl, MVT::i32, Arg,
-                   DAG.getConstant(0, Dl, MVT::i32));
-  Hi = DAG.getNode(ISD::EXTRACT_ELEMENT, Dl, MVT::i32, Arg,
-                   DAG.getConstant(1, Dl, MVT::i32));
+  Pass64BitArgInRegs(Dl, DAG, Chain, Arg, RegsToPass, VA, NextVA);
+}
 
-  // Attach the two i32 types into corresponding registers
-  RegsToPass.push_back(std::make_pair(VA.getLocReg(), Lo));
-  RegsToPass.push_back(std::make_pair(NextVA.getLocReg(), Hi));
+/// Breaks an i64 value into two registers and adds the new node to the DAG.
+static void Passi64ArgInRegs(
+    const SDLoc &dl, SelectionDAG &DAG, SDValue Chain, SDValue &Arg,
+    SmallVector<std::pair<unsigned, SDValue>, 8> &RegsToPass, CCValAssign &VA,
+    CCValAssign &NextVA, const X86Subtarget &Subtarget) {
+  assert(Subtarget.isTarget64BitWine32() && "Expected 64-bit target!");
+  assert(Arg.getValueType() == MVT::i64 && "Expected 64-bit value!");
+  assert(VA.isRegLoc() && NextVA.isRegLoc() &&
+         "The value should reside in two registers!");
+
+  Pass64BitArgInRegs(dl, DAG, Chain, Arg, RegsToPass, VA, NextVA);
 }
 
 SDValue
@@ -2378,11 +2432,14 @@
     SmallVector<std::pair<unsigned, SDValue>, 8> RegsToPass;
 
     if (VA.needsCustom()) {
-      assert(VA.getValVT() == MVT::v64i1 &&
-             "Currently the only custom case is when we split v64i1 to 2 regs");
-
-      Passv64i1ArgInRegs(dl, DAG, Chain, ValToCopy, RegsToPass, VA, RVLocs[++I],
+      if (VA.getValVT() == MVT::v64i1)
+        Passv64i1ArgInRegs(dl, DAG, Chain, ValToCopy, RegsToPass, VA,
+                           RVLocs[++I], Subtarget);
+      else if (VA.getValVT() == MVT::i64)
+        Passi64ArgInRegs(dl, DAG, Chain, ValToCopy, RegsToPass, VA, RVLocs[++I],
                          Subtarget);
+      else
+        llvm_unreachable("Unexpected custom return value case!");
 
       assert(2 == RegsToPass.size() &&
              "Expecting two registers after Pass64BitArgInRegs");
@@ -2589,6 +2646,54 @@
   return DAG.getNode(ISD::CONCAT_VECTORS, Dl, MVT::v64i1, Lo, Hi);
 }
 
+/// Reads two 32 bit registers and creates a 64 bit value.
+/// \param VA The current 32 bit value that needs to be assigned.
+/// \param NextVA The next 32 bit value that needs to be assigned.
+/// \param Root The parent DAG node.
+/// \param [in,out] InFlag Represents an SDValue in the parent DAG node for
+///                        glue purposes. In case the DAG is already using
+///                        physical registers instead of virtual, we should glue
+///                        our new SDValue to this SDValue.
+/// \return a new 64-bit SDValue.
+static SDValue geti64Argument(CCValAssign &VA, CCValAssign &NextVA,
+                              SDValue &Root, SelectionDAG &DAG,
+                              const SDLoc &Dl, const X86Subtarget &Subtarget,
+                              SDValue *InFlag = nullptr) {
+  assert(Subtarget.isTarget64BitWine32() && "Expected 64-bit target!");
+  assert(VA.getValVT() == MVT::i64 &&
+         "Expected first location to be of a 64-bit type!");
+  assert(NextVA.getValVT() == VA.getValVT() &&
+         "The locations should have the same type!");
+  assert(VA.isRegLoc() && NextVA.isRegLoc() &&
+         "The values should reside in two registers!");
+
+  SDValue Lo, Hi;
+  unsigned Reg;
+
+  MachineFunction &MF = DAG.getMachineFunction();
+  const TargetRegisterClass *RC = &X86::GR32RegClass;
+
+  // Read a 32 bit value from the registers.
+  if (nullptr == InFlag) {
+    // When no physical register is present,
+    // create an intermediate virtual register.
+    Reg = MF.addLiveIn(VA.getLocReg(), RC);
+    Lo = DAG.getCopyFromReg(Root, Dl, Reg, MVT::i32);
+    Reg = MF.addLiveIn(NextVA.getLocReg(), RC);
+    Hi = DAG.getCopyFromReg(Root, Dl, Reg, MVT::i32);
+  } else {
+    // When a physical register is available read the value from it and glue
+    // the reads together.
+    Lo = DAG.getCopyFromReg(Root, Dl, VA.getLocReg(), MVT::i32, *InFlag);
+    *InFlag = Lo.getValue(2);
+    Hi = DAG.getCopyFromReg(Root, Dl, NextVA.getLocReg(), MVT::i32, *InFlag);
+    *InFlag = Hi.getValue(2);
+  }
+
+  // Concatenate the two values together.
+  return DAG.getNode(ISD::BUILD_PAIR, Dl, MVT::i64, Lo, Hi);
+}
+
 /// The function will lower a register of various sizes (8/16/32/64)
 /// to a mask value of the expected size (v8i1/v16i1/v32i1/v64i1)
 /// \returns a DAG node contains the operand after lowering to mask type.
@@ -2676,10 +2781,14 @@
 
     SDValue Val;
     if (VA.needsCustom()) {
-      assert(VA.getValVT() == MVT::v64i1 &&
-             "Currently the only custom case is when we split v64i1 to 2 regs");
-      Val =
-          getv64i1Argument(VA, RVLocs[++I], Chain, DAG, dl, Subtarget, &InFlag);
+      if (VA.getValVT() == MVT::v64i1)
+        Val = getv64i1Argument(VA, RVLocs[++I], Chain, DAG, dl, Subtarget,
+                               &InFlag);
+      else if (VA.getValVT() == MVT::i64)
+        Val = geti64Argument(VA, RVLocs[++I], Chain, DAG, dl, Subtarget,
+                             &InFlag);
+      else
+        llvm_unreachable("Unexpected custom return value case!");
     } else {
       Chain = DAG.getCopyFromReg(Chain, dl, VA.getLocReg(), CopyVT, InFlag)
                   .getValue(1);
@@ -2823,7 +2932,7 @@
       CallConv, DAG.getTarget().Options.GuaranteedTailCallOpt);
   bool isImmutable = !AlwaysUseMutable && !Flags.isByVal();
   EVT ValVT;
-  MVT PtrVT = getPointerTy(DAG.getDataLayout());
+  MVT PtrVT = getFrameIndexTy(DAG.getDataLayout());
 
   // If value is passed by pointer we have address passed instead of the value
   // itself. No need to extend if the mask value and location share the same
@@ -2902,9 +3011,10 @@
           break;
       }
       if (MFI.isFixedObjectIndex(FI)) {
+        EVT FIVT = getFrameIndexTy(DAG.getDataLayout());
         SDValue Addr =
-            DAG.getNode(ISD::ADD, dl, PtrVT, DAG.getFrameIndex(FI, PtrVT),
-                        DAG.getIntPtrConstant(Ins[i].PartOffset, dl));
+            DAG.getNode(ISD::ADD, dl, FIVT, DAG.getFrameIndex(FI, PtrVT),
+                        DAG.getConstant(Ins[i].PartOffset, dl, FIVT));
         return DAG.getLoad(
             ValVT, dl, Chain, Addr,
             MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI,
@@ -3005,13 +3115,17 @@
   const TargetFrameLowering &TFI = *Subtarget.getFrameLowering();
 
   const Function &F = MF.getFunction();
-  if (F.hasExternalLinkage() && Subtarget.isTargetCygMing() &&
-      F.getName() == "main")
+  if ((F.hasExternalLinkage() && Subtarget.isTargetCygMing() &&
+       F.getName() == "main") ||
+      (!Subtarget.is64Bit() && F.hasFnAttribute("patchable-function") &&
+       F.getFnAttribute("patchable-function").getValueAsString() ==
+           "ms-hotpatch"))
     FuncInfo->setForceFramePointer(true);
 
   MachineFrameInfo &MFI = MF.getFrameInfo();
   bool Is64Bit = Subtarget.is64Bit();
   bool IsWin64 = Subtarget.isCallingConvWin64(CallConv);
+  bool IsInterop6432 = Subtarget.isCallingConv6432Interop(CallConv);
 
   assert(
       !(isVarArg && canGuaranteeTCO(CallConv)) &&
@@ -3029,9 +3143,11 @@
   SmallVector<CCValAssign, 16> ArgLocs;
   CCState CCInfo(CallConv, isVarArg, MF, ArgLocs, *DAG.getContext());
 
-  // Allocate shadow area for Win64.
+  // Allocate shadow area for Win64 and 32-bit interop.
   if (IsWin64)
     CCInfo.AllocateStack(32, 8);
+  if (IsInterop6432)
+    CCInfo.AllocateStack(12, 4);
 
   CCInfo.AnalyzeArguments(Ins, CC_X86);
 
@@ -3239,12 +3355,12 @@
 
     // Store the integer parameter registers.
     SmallVector<SDValue, 8> MemOps;
-    SDValue RSFIN = DAG.getFrameIndex(FuncInfo->getRegSaveFrameIndex(),
-                                      getPointerTy(DAG.getDataLayout()));
+    EVT FIVT = getFrameIndexTy(DAG.getDataLayout());
+    SDValue RSFIN = DAG.getFrameIndex(FuncInfo->getRegSaveFrameIndex(), FIVT);
     unsigned Offset = FuncInfo->getVarArgsGPOffset();
     for (SDValue Val : LiveGPRs) {
-      SDValue FIN = DAG.getNode(ISD::ADD, dl, getPointerTy(DAG.getDataLayout()),
-                                RSFIN, DAG.getIntPtrConstant(Offset, dl));
+      SDValue FIN = DAG.getNode(ISD::ADD, dl, FIVT, RSFIN,
+                                DAG.getConstant(Offset, dl, FIVT));
       SDValue Store =
           DAG.getStore(Val.getValue(1), dl, Val, FIN,
                        MachinePointerInfo::getFixedStack(
@@ -3256,13 +3372,14 @@
 
     if (!ArgXMMs.empty() && NumXMMRegs != ArgXMMs.size()) {
       // Now store the XMM (fp + vector) parameter registers.
+      EVT FIVT = getFrameIndexTy(DAG.getDataLayout());
       SmallVector<SDValue, 12> SaveXMMOps;
       SaveXMMOps.push_back(Chain);
       SaveXMMOps.push_back(ALVal);
-      SaveXMMOps.push_back(DAG.getIntPtrConstant(
-                             FuncInfo->getRegSaveFrameIndex(), dl));
-      SaveXMMOps.push_back(DAG.getIntPtrConstant(
-                             FuncInfo->getVarArgsFPOffset(), dl));
+      SaveXMMOps.push_back(DAG.getConstant(
+                             FuncInfo->getRegSaveFrameIndex(), dl, FIVT));
+      SaveXMMOps.push_back(DAG.getConstant(
+                             FuncInfo->getVarArgsFPOffset(), dl, FIVT));
       SaveXMMOps.insert(SaveXMMOps.end(), LiveXMMRegs.begin(),
                         LiveXMMRegs.end());
       MemOps.push_back(DAG.getNode(X86ISD::VASTART_SAVE_XMM_REGS, dl,
@@ -3314,7 +3431,8 @@
   }
 
   // Some CCs need callee pop.
-  if (X86::isCalleePop(CallConv, Is64Bit, isVarArg,
+  if (X86::isCalleePop(CallConv, Is64Bit,
+                       Subtarget.isTarget64BitWine32(), isVarArg,
                        MF.getTarget().Options.GuaranteedTailCallOpt)) {
     FuncInfo->setBytesToPopOnReturn(StackSize); // Callee pops everything.
   } else if (CallConv == CallingConv::X86_INTR && Ins.size() == 2) {
@@ -3374,9 +3492,9 @@
                                             const CCValAssign &VA,
                                             ISD::ArgFlagsTy Flags) const {
   unsigned LocMemOffset = VA.getLocMemOffset();
-  SDValue PtrOff = DAG.getIntPtrConstant(LocMemOffset, dl);
-  PtrOff = DAG.getNode(ISD::ADD, dl, getPointerTy(DAG.getDataLayout()),
-                       StackPtr, PtrOff);
+  EVT FIVT = getFrameIndexTy(DAG.getDataLayout());
+  SDValue PtrOff = DAG.getConstant(LocMemOffset, dl, FIVT);
+  PtrOff = DAG.getNode(ISD::ADD, dl, FIVT, StackPtr, PtrOff);
   if (Flags.isByVal())
     return CreateCopyOfByValArgument(Arg, PtrOff, Chain, Flags, DAG, dl);
 
@@ -3447,6 +3565,7 @@
   MachineFunction &MF = DAG.getMachineFunction();
   bool Is64Bit        = Subtarget.is64Bit();
   bool IsWin64        = Subtarget.isCallingConvWin64(CallConv);
+  bool IsInterop6432  = Subtarget.isCallingConv6432Interop(CallConv);
   StructReturnType SR = callIsStructReturn(Outs, Subtarget.isTargetMCU());
   bool IsSibcall      = false;
   X86MachineFunctionInfo *X86Info = MF.getInfo<X86MachineFunctionInfo>();
@@ -3460,6 +3579,8 @@
       (CI && CI->doesNoCfCheck()) || (II && II->doesNoCfCheck());
   const Module *M = MF.getMMI().getModule();
   Metadata *IsCFProtectionSupported = M->getModuleFlag("cf-protection-branch");
+  bool IsFarCall32 = Is64Bit && Subtarget.isTarget64BitWine32() &&
+                     Callee.getSimpleValueType() == MVT::i32 && IsInterop6432;
 
   if (CallConv == CallingConv::X86_INTR)
     report_fatal_error("X86 interrupts may not be called directly");
@@ -3467,6 +3588,11 @@
   if (Attr.getValueAsString() == "true")
     isTailCall = false;
 
+  if (IsFarCall32)
+    // We can't TCO tail calls from 64-bit to 32-bit code.
+    // FIXME: Unless the caller was itself called far by 32-bit code.
+    isTailCall = false;
+
   if (Subtarget.isPICStyleGOT() &&
       !MF.getTarget().Options.GuaranteedTailCallOpt) {
     // If we are using a GOT, disable tail calls to external symbols with
@@ -3482,6 +3608,8 @@
 
   bool IsMustTail = CLI.CS && CLI.CS.isMustTailCall();
   if (IsMustTail) {
+    if (IsFarCall32)
+      report_fatal_error("Cannot tail-call 32-bit function from 64-bit code!");
     // Force this to be a tail call.  The verifier rules are enough to ensure
     // that we can lower this successfully without moving the return address
     // around.
@@ -3509,9 +3637,11 @@
   SmallVector<CCValAssign, 16> ArgLocs;
   CCState CCInfo(CallConv, isVarArg, MF, ArgLocs, *DAG.getContext());
 
-  // Allocate shadow area for Win64.
+  // Allocate shadow area for Win64 and 32-bit interop.
   if (IsWin64)
     CCInfo.AllocateStack(32, 8);
+  if (IsInterop6432 && !IsFarCall32)
+    CCInfo.AllocateStack(12, 4);
 
   CCInfo.AnalyzeArguments(Outs, CC_X86);
 
@@ -3657,7 +3787,7 @@
       assert(VA.isMemLoc());
       if (!StackPtr.getNode())
         StackPtr = DAG.getCopyFromReg(Chain, dl, RegInfo->getStackRegister(),
-                                      getPointerTy(DAG.getDataLayout()));
+                                      getFrameIndexTy(DAG.getDataLayout()));
       MemOpChains.push_back(LowerMemOpCallTo(Chain, StackPtr, Arg,
                                              dl, DAG, VA, Flags));
     }
@@ -3692,7 +3822,7 @@
     }
   }
 
-  if (Is64Bit && isVarArg && !IsWin64 && !IsMustTail) {
+  if (Is64Bit && isVarArg && !IsWin64 && !IsMustTail && !IsInterop6432) {
     // From AMD64 ABI document:
     // For calls that may call functions that use varargs or stdargs
     // (prototype-less calls or calls to functions containing ellipsis (...) in
@@ -3764,16 +3894,16 @@
       int32_t Offset = VA.getLocMemOffset()+FPDiff;
       uint32_t OpSize = (VA.getLocVT().getSizeInBits()+7)/8;
       FI = MF.getFrameInfo().CreateFixedObject(OpSize, Offset, true);
-      FIN = DAG.getFrameIndex(FI, getPointerTy(DAG.getDataLayout()));
+      FIN = DAG.getFrameIndex(FI, getFrameIndexTy(DAG.getDataLayout()));
 
       if (Flags.isByVal()) {
         // Copy relative to framepointer.
-        SDValue Source = DAG.getIntPtrConstant(VA.getLocMemOffset(), dl);
+        EVT FIVT = getFrameIndexTy(DAG.getDataLayout());
+        SDValue Source = DAG.getConstant(VA.getLocMemOffset(), dl, FIVT);
         if (!StackPtr.getNode())
           StackPtr = DAG.getCopyFromReg(Chain, dl, RegInfo->getStackRegister(),
-                                        getPointerTy(DAG.getDataLayout()));
-        Source = DAG.getNode(ISD::ADD, dl, getPointerTy(DAG.getDataLayout()),
-                             StackPtr, Source);
+                                        FIVT);
+        Source = DAG.getNode(ISD::ADD, dl, FIVT, StackPtr, Source);
 
         MemOpChains2.push_back(CreateCopyOfByValArgument(Source, FIN,
                                                          ArgChain,
@@ -3791,7 +3921,7 @@
 
     // Store the return address to the appropriate stack slot.
     Chain = EmitTailCallStoreRetAddr(DAG, MF, Chain, RetAddrFrIdx,
-                                     getPointerTy(DAG.getDataLayout()),
+                                     getFrameIndexTy(DAG.getDataLayout()),
                                      RegInfo->getSlotSize(), FPDiff, dl);
   }
 
@@ -3870,6 +4000,31 @@
   Ops.push_back(Chain);
   Ops.push_back(Callee);
 
+  unsigned NumBytesForCalleeToPop;
+  if (X86::isCalleePop(CallConv, Is64Bit, Subtarget.isTarget64BitWine32(),
+                       isVarArg, DAG.getTarget().Options.GuaranteedTailCallOpt,
+                       IsFarCall32))
+    NumBytesForCalleeToPop = NumBytes;    // Callee pops everything
+  else if (!Is64Bit && !canGuaranteeTCO(CallConv) &&
+           !Subtarget.getTargetTriple().isOSMSVCRT() &&
+           SR == StackStructReturn)
+    // If this is a call to a struct-return function, the callee
+    // pops the hidden struct pointer, so we have to push it back.
+    // This is common for Darwin/X86, Linux & Mingw32 targets.
+    // For MSVC Win32 targets, the caller pops the hidden struct pointer.
+    NumBytesForCalleeToPop = 4;
+  else
+    NumBytesForCalleeToPop = 0;  // Callee pops nothing.
+
+  if (CLI.DoesNotReturn && !getTargetMachine().Options.TrapUnreachable) {
+    // No need to reset the stack after the call if the call doesn't return. To
+    // make the MI verify, we'll pretend the callee does it for us.
+    NumBytesForCalleeToPop = NumBytes;
+  }
+
+  if (IsFarCall32)
+    Ops.push_back(DAG.getConstant(NumBytesForCalleeToPop, dl, MVT::i16));
+
   if (isTailCall)
     Ops.push_back(DAG.getConstant(FPDiff, dl, MVT::i32));
 
@@ -3945,33 +4100,14 @@
 
   if (HasNoCfCheck && IsCFProtectionSupported) {
     Chain = DAG.getNode(X86ISD::NT_CALL, dl, NodeTys, Ops);
+  } else if (IsFarCall32) {
+    Chain = DAG.getNode(X86ISD::FARCALL32, dl, NodeTys, Ops);
   } else {
     Chain = DAG.getNode(X86ISD::CALL, dl, NodeTys, Ops);
   }
   InFlag = Chain.getValue(1);
 
   // Create the CALLSEQ_END node.
-  unsigned NumBytesForCalleeToPop;
-  if (X86::isCalleePop(CallConv, Is64Bit, isVarArg,
-                       DAG.getTarget().Options.GuaranteedTailCallOpt))
-    NumBytesForCalleeToPop = NumBytes;    // Callee pops everything
-  else if (!Is64Bit && !canGuaranteeTCO(CallConv) &&
-           !Subtarget.getTargetTriple().isOSMSVCRT() &&
-           SR == StackStructReturn)
-    // If this is a call to a struct-return function, the callee
-    // pops the hidden struct pointer, so we have to push it back.
-    // This is common for Darwin/X86, Linux & Mingw32 targets.
-    // For MSVC Win32 targets, the caller pops the hidden struct pointer.
-    NumBytesForCalleeToPop = 4;
-  else
-    NumBytesForCalleeToPop = 0;  // Callee pops nothing.
-
-  if (CLI.DoesNotReturn && !getTargetMachine().Options.TrapUnreachable) {
-    // No need to reset the stack after the call if the call doesn't return. To
-    // make the MI verify, we'll pretend the callee does it for us.
-    NumBytesForCalleeToPop = NumBytes;
-  }
-
   // Returns a flag for retval copy to use.
   if (!IsSibcall) {
     Chain = DAG.getCALLSEQ_END(Chain,
@@ -4160,12 +4296,17 @@
   bool CCMatch = CallerCC == CalleeCC;
   bool IsCalleeWin64 = Subtarget.isCallingConvWin64(CalleeCC);
   bool IsCallerWin64 = Subtarget.isCallingConvWin64(CallerCC);
+  bool IsCalleeInterop6432 = Subtarget.isCallingConv6432Interop(CalleeCC);
+  bool IsCallerInterop6432 = Subtarget.isCallingConv6432Interop(CallerCC);
 
   // Win64 functions have extra shadow space for argument homing. Don't do the
   // sibcall if the caller and callee have mismatched expectations for this
   // space.
   if (IsCalleeWin64 != IsCallerWin64)
     return false;
+  // Ditto 32-bit interop.
+  if (IsCalleeInterop6432 != IsCallerInterop6432)
+    return false;
 
   if (DAG.getTarget().Options.GuaranteedTailCallOpt) {
     if (canGuaranteeTCO(CalleeCC) && CCMatch)
@@ -4252,6 +4393,8 @@
     // Allocate shadow area for Win64
     if (IsCalleeWin64)
       CCInfo.AllocateStack(32, 8);
+    if (IsCalleeInterop6432)
+      CCInfo.AllocateStack(12, 4);
 
     CCInfo.AnalyzeCallOperands(Outs, CC_X86);
     StackArgsSize = CCInfo.getNextStackOffset();
@@ -4311,7 +4454,8 @@
   }
 
   bool CalleeWillPop =
-      X86::isCalleePop(CalleeCC, Subtarget.is64Bit(), isVarArg,
+      X86::isCalleePop(CalleeCC, Subtarget.is64Bit(),
+                       Subtarget.isTarget64BitWine32(), isVarArg,
                        MF.getTarget().Options.GuaranteedTailCallOpt);
 
   if (unsigned BytesToPop =
@@ -4426,7 +4570,8 @@
     FuncInfo->setRAIndex(ReturnAddrIndex);
   }
 
-  return DAG.getFrameIndex(ReturnAddrIndex, getPointerTy(DAG.getDataLayout()));
+  return DAG.getFrameIndex(
+      ReturnAddrIndex, getFrameIndexTy(DAG.getDataLayout()));
 }
 
 bool X86::isOffsetSuitableForCodeModel(int64_t Offset, CodeModel::Model M,
@@ -4462,7 +4607,8 @@
 /// Determines whether the callee is required to pop its own arguments.
 /// Callee pop is necessary to support tail calls.
 bool X86::isCalleePop(CallingConv::ID CallingConv,
-                      bool is64Bit, bool IsVarArg, bool GuaranteeTCO) {
+                      bool is64Bit, bool isWine32, bool IsVarArg,
+                      bool GuaranteeTCO, bool IsFarCall32) {
   // If GuaranteeTCO is true, we force some calls to be callee pop so that we
   // can guarantee TCO.
   if (!IsVarArg && shouldGuaranteeTCO(CallingConv, GuaranteeTCO))
@@ -4474,6 +4620,7 @@
   case CallingConv::X86_StdCall:
   case CallingConv::X86_FastCall:
   case CallingConv::X86_ThisCall:
+    return !is64Bit || (isWine32 && IsFarCall32);
   case CallingConv::X86_VectorCall:
     return !is64Bit;
   }
@@ -15836,7 +15983,7 @@
   // offset if it is legal.
   unsigned char OpFlags = Subtarget.classifyGlobalReference(GV);
   CodeModel::Model M = DAG.getTarget().getCodeModel();
-  auto PtrVT = getPointerTy(DAG.getDataLayout());
+  auto PtrVT = getPointerTy(DAG.getDataLayout(), GV->getAddressSpace());
   SDValue Result;
   if (OpFlags == X86II::MO_NO_FLAG &&
       X86::isOffsetSuitableForCodeModel(Offset, M)) {
@@ -16288,7 +16435,7 @@
 
   unsigned Size = SrcVT.getSizeInBits()/8;
   MachineFunction &MF = DAG.getMachineFunction();
-  auto PtrVT = getPointerTy(MF.getDataLayout());
+  auto PtrVT = getFrameIndexTy(MF.getDataLayout());
   int SSFI = MF.getFrameInfo().CreateStackObject(Size, Size, false);
   SDValue StackSlot = DAG.getFrameIndex(SSFI, PtrVT);
   SDValue Chain = DAG.getStore(
@@ -16337,7 +16484,7 @@
     MachineFunction &MF = DAG.getMachineFunction();
     unsigned SSFISize = Op.getValueSizeInBits()/8;
     int SSFI = MF.getFrameInfo().CreateStackObject(SSFISize, SSFISize, false);
-    auto PtrVT = getPointerTy(MF.getDataLayout());
+    auto PtrVT = getFrameIndexTy(MF.getDataLayout());
     SDValue StackSlot = DAG.getFrameIndex(SSFI, PtrVT);
     Tys = DAG.getVTList(MVT::Other);
     SDValue Ops[] = {
@@ -16722,7 +16869,7 @@
 
   EVT DstTy = Op.getValueType();
   EVT TheVT = Op.getOperand(0).getValueType();
-  auto PtrVT = getPointerTy(DAG.getDataLayout());
+  auto PtrVT = getFrameIndexTy(DAG.getDataLayout());
 
   if (TheVT != MVT::f32 && TheVT != MVT::f64 && TheVT != MVT::f80) {
     // f16 must be promoted before using the lowering in this routine.
@@ -17338,6 +17485,29 @@
                      DAG.getIntPtrConstant(0, DL));
 }
 
+SDValue
+X86TargetLowering::LowerADDRSPACECAST(SDValue Op, SelectionDAG &DAG) const {
+  SDLoc SL(Op);
+  const AddrSpaceCastSDNode *ASC = cast<AddrSpaceCastSDNode>(Op);
+
+  // Casts to the 32-bit space require truncation.
+  if (ASC->getSrcAddressSpace() != 32 && ASC->getDestAddressSpace() == 32)
+    return DAG.getNode(ISD::TRUNCATE, SL, Op.getValueType(),
+                       ASC->getOperand(0));
+  // Casts from the 32-bit space require extension.
+  else if (ASC->getSrcAddressSpace() == 32 && ASC->getDestAddressSpace() != 32)
+    return DAG.getNode(ISD::ZERO_EXTEND, SL, Op.getValueType(),
+                       ASC->getOperand(0));
+
+  // All other addrspacecasts are noops.
+  const MachineFunction &MF = DAG.getMachineFunction();
+  DiagnosticInfoUnsupported InvalidAddrSpaceCast(
+    MF.getFunction(), "invalid addrspacecast", SL.getDebugLoc());
+  DAG.getContext()->diagnose(InvalidAddrSpaceCast);
+
+  return DAG.getUNDEF(ASC->getValueType(0));
+}
+
 SDValue X86TargetLowering::LowerFP_TO_INT(SDValue Op, SelectionDAG &DAG) const {
   bool IsSigned = Op.getOpcode() == ISD::FP_TO_SINT;
   MVT VT = Op.getSimpleValueType();
@@ -19939,7 +20109,7 @@
   Chain = DAG.getCALLSEQ_START(Chain, 0, 0, dl);
 
   bool Is64Bit = Subtarget.is64Bit();
-  MVT SPTy = getPointerTy(DAG.getDataLayout());
+  MVT SPTy = getFrameIndexTy(DAG.getDataLayout());
 
   SDValue Result;
   if (!Lower) {
@@ -20004,7 +20174,7 @@
 
 SDValue X86TargetLowering::LowerVASTART(SDValue Op, SelectionDAG &DAG) const {
   MachineFunction &MF = DAG.getMachineFunction();
-  auto PtrVT = getPointerTy(MF.getDataLayout());
+  auto PtrVT = getFrameIndexTy(MF.getDataLayout());
   X86MachineFunctionInfo *FuncInfo = MF.getInfo<X86MachineFunctionInfo>();
 
   const Value *SV = cast<SrcValueSDNode>(Op.getOperand(2))->getValue();
@@ -20026,6 +20196,12 @@
   //   reg_save_area
   SmallVector<SDValue, 8> MemOps;
   SDValue FIN = Op.getOperand(1);
+  EVT FIVT = getFrameIndexTy(DAG.getDataLayout());
+  if (FIN.getValueType() != FIVT)
+    // If the pointer and frame index types don't match, we must convert.
+    FIN = DAG.getNode(
+        FIN.getValueType().getSizeInBits() > FIVT.getSizeInBits()
+            ? ISD::TRUNCATE : ISD::ZERO_EXTEND, DL, FIVT, FIN);
   // Store gp_offset
   SDValue Store = DAG.getStore(
       Op.getOperand(0), DL,
@@ -20042,15 +20218,15 @@
   MemOps.push_back(Store);
 
   // Store ptr to overflow_arg_area
-  FIN = DAG.getNode(ISD::ADD, DL, PtrVT, FIN, DAG.getIntPtrConstant(4, DL));
+  FIN = DAG.getNode(ISD::ADD, DL, FIVT, FIN, DAG.getConstant(4, DL, FIVT));
   SDValue OVFIN = DAG.getFrameIndex(FuncInfo->getVarArgsFrameIndex(), PtrVT);
   Store =
       DAG.getStore(Op.getOperand(0), DL, OVFIN, FIN, MachinePointerInfo(SV, 8));
   MemOps.push_back(Store);
 
   // Store ptr to reg_save_area.
-  FIN = DAG.getNode(ISD::ADD, DL, PtrVT, FIN, DAG.getIntPtrConstant(
-      Subtarget.isTarget64BitLP64() ? 8 : 4, DL));
+  FIN = DAG.getNode(ISD::ADD, DL, FIVT, FIN, DAG.getConstant(
+      Subtarget.isTarget64BitLP64() ? 8 : 4, DL, FIVT));
   SDValue RSFIN = DAG.getFrameIndex(FuncInfo->getRegSaveFrameIndex(), PtrVT);
   Store = DAG.getStore(
       Op.getOperand(0), DL, RSFIN, FIN,
@@ -21858,7 +22034,8 @@
 SDValue X86TargetLowering::LowerFRAME_TO_ARGS_OFFSET(SDValue Op,
                                                      SelectionDAG &DAG) const {
   const X86RegisterInfo *RegInfo = Subtarget.getRegisterInfo();
-  return DAG.getIntPtrConstant(2 * RegInfo->getSlotSize(), SDLoc(Op));
+  return DAG.getConstant(2 * RegInfo->getSlotSize(), SDLoc(Op),
+                         getFrameIndexTy(DAG.getDataLayout()));
 }
 
 unsigned X86TargetLowering::getExceptionPointerRegister(
@@ -21886,7 +22063,7 @@
   SDValue Handler   = Op.getOperand(2);
   SDLoc dl      (Op);
 
-  EVT PtrVT = getPointerTy(DAG.getDataLayout());
+  EVT PtrVT = getFrameIndexTy(DAG.getDataLayout());
   const X86RegisterInfo *RegInfo = Subtarget.getRegisterInfo();
   unsigned FrameReg = RegInfo->getFrameRegister(DAG.getMachineFunction());
   assert(((FrameReg == X86::RBP && PtrVT == MVT::i64) ||
@@ -21896,8 +22073,8 @@
   unsigned StoreAddrReg = (PtrVT == MVT::i64) ? X86::RCX : X86::ECX;
 
   SDValue StoreAddr = DAG.getNode(ISD::ADD, dl, PtrVT, Frame,
-                                 DAG.getIntPtrConstant(RegInfo->getSlotSize(),
-                                                       dl));
+                                  DAG.getConstant(RegInfo->getSlotSize(),
+                                                  dl, PtrVT));
   StoreAddr = DAG.getNode(ISD::ADD, dl, PtrVT, StoreAddr, Offset);
   Chain = DAG.getStore(Chain, dl, Handler, StoreAddr, MachinePointerInfo());
   Chain = DAG.getCopyToReg(Chain, dl, StoreAddrReg, StoreAddr);
@@ -22119,7 +22296,7 @@
   // Save FP Control Word to stack slot
   int SSFI = MF.getFrameInfo().CreateStackObject(2, StackAlignment, false);
   SDValue StackSlot =
-      DAG.getFrameIndex(SSFI, getPointerTy(DAG.getDataLayout()));
+      DAG.getFrameIndex(SSFI, getFrameIndexTy(DAG.getDataLayout()));
 
   MachineMemOperand *MMO =
       MF.getMachineMemOperand(MachinePointerInfo::getFixedStack(MF, SSFI),
@@ -25320,6 +25497,7 @@
   case ISD::FP_TO_SINT:
   case ISD::FP_TO_UINT:         return LowerFP_TO_INT(Op, DAG);
   case ISD::FP_EXTEND:          return LowerFP_EXTEND(Op, DAG);
+  case ISD::ADDRSPACECAST:      return LowerADDRSPACECAST(Op, DAG);
   case ISD::LOAD:               return LowerLoad(Op, Subtarget, DAG);
   case ISD::STORE:              return LowerStore(Op, Subtarget, DAG);
   case ISD::FABS:
@@ -26205,6 +26383,7 @@
   case X86ISD::NT_BRIND:           return "X86ISD::NT_BRIND";
   case X86ISD::UMWAIT:             return "X86ISD::UMWAIT";
   case X86ISD::TPAUSE:             return "X86ISD::TPAUSE";
+  case X86ISD::FARCALL32:          return "X86ISD::FARCALL32";
   }
   return nullptr;
 }
@@ -27985,7 +28164,8 @@
   // restoreMBB:
   if (RegInfo->hasBasePointer(*MF)) {
     const bool Uses64BitFramePtr =
-        Subtarget.isTarget64BitLP64() || Subtarget.isTargetNaCl64();
+        (Subtarget.isTarget64BitLP64() && !Subtarget.isTarget64BitWine32()) ||
+        Subtarget.isTargetNaCl64();
     X86MachineFunctionInfo *X86FI = MF->getInfo<X86MachineFunctionInfo>();
     X86FI->setRestoreBasePointer(MF);
     unsigned FramePtr = RegInfo->getFrameRegister(*MF);
@@ -28386,7 +28566,8 @@
   // registers being marked as clobbered.
   if (RI.hasBasePointer(*MF)) {
     const bool FPIs64Bit =
-        Subtarget.isTarget64BitLP64() || Subtarget.isTargetNaCl64();
+        (Subtarget.isTarget64BitLP64() && !Subtarget.isTarget64BitWine32()) ||
+        Subtarget.isTargetNaCl64();
     X86MachineFunctionInfo *MFI = MF->getInfo<X86MachineFunctionInfo>();
     MFI->setRestoreBasePointer(MF);
 
@@ -28758,7 +28939,7 @@
            "base pointer in mind");
 
     MachineRegisterInfo &MRI = MF->getRegInfo();
-    MVT SPTy = getPointerTy(MF->getDataLayout());
+    MVT SPTy = getFrameIndexTy(MF->getDataLayout());
     const TargetRegisterClass *AddrRegClass = getRegClassFor(SPTy);
     unsigned computedAddrVReg = MRI.createVirtualRegister(AddrRegClass);
 
@@ -40635,6 +40816,38 @@
     return Res;
   }
 
+  // The base implementation may have picked one of the MIXED_ADDR_ACCESS
+  // classes, which contains all the registers that can be used as a pointer
+  // in 64-bit code. This class is only meant to be returned from
+  // X86RegisterInfo::getPointerRegClass(), to avoid redundant copies for
+  // 32-bit pointers in 64-bit-native code. We can't use it here. If we have
+  // one of those regclasses, pick the corresponding GR32 or GR64 regclass.
+  if (Res.second == &X86::MIXED_ADDR_ACCESSRegClass) {
+    if (X86::GR64RegClass.contains(Res.first)) {
+      if (!Subtarget.is64Bit()) return std::make_pair(0, nullptr);
+      Res.second = &X86::GR64RegClass;
+    } else
+      Res.second = &X86::GR32RegClass;
+  } else if (Res.second == &X86::MIXED_ADDR_ACCESS_NOREXRegClass) {
+    if (X86::GR64_NOREXRegClass.contains(Res.first)) {
+      if (!Subtarget.is64Bit()) return std::make_pair(0, nullptr);
+      Res.second = &X86::GR64_NOREXRegClass;
+    } else
+      Res.second = &X86::GR32_NOREXRegClass;
+  } else if (Res.second == &X86::MIXED_ADDR_ACCESS_NOSPRegClass) {
+    if (X86::GR64_NOSPRegClass.contains(Res.first)) {
+      if (!Subtarget.is64Bit()) return std::make_pair(0, nullptr);
+      Res.second = &X86::GR64_NOSPRegClass;
+    } else
+      Res.second = &X86::GR32_NOSPRegClass;
+  } else if (Res.second == &X86::MIXED_ADDR_ACCESS_NOREX_NOSPRegClass) {
+    if (X86::GR64_NOREX_NOSPRegClass.contains(Res.first)) {
+      if (!Subtarget.is64Bit()) return std::make_pair(0, nullptr);
+      Res.second = &X86::GR64_NOREX_NOSPRegClass;
+    } else
+      Res.second = &X86::GR32_NOREX_NOSPRegClass;
+  }
+
   // Make sure it isn't a register that requires 64-bit mode.
   if (!Subtarget.is64Bit() &&
       (isFRClass(*Res.second) || isGRClass(*Res.second)) &&
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86ISelLowering.h llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86ISelLowering.h
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86ISelLowering.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86ISelLowering.h	2019-05-19 11:21:51.785903000 +0000
@@ -78,6 +78,10 @@
       /// Same as call except it adds the NoTrack prefix.
       NT_CALL,
 
+      /// Same as call except it is compiled to a far call to a 32-bit
+      /// function.
+      FARCALL32,
+
       /// This operation implements the lowering for readcyclecounter.
       RDTSC_DAG,
 
@@ -656,7 +660,8 @@
     /// Determines whether the callee is required to pop its
     /// own arguments. Callee pop is necessary to support tail calls.
     bool isCalleePop(CallingConv::ID CallingConv,
-                     bool is64Bit, bool IsVarArg, bool GuaranteeTCO);
+                     bool is64Bit, bool isWine32, bool IsVarArg,
+                     bool GuaranteeTCO, bool IsFarCall32 = false);
 
   } // end namespace X86
 
@@ -1094,6 +1099,10 @@
 
     bool isNoopAddrSpaceCast(unsigned SrcAS, unsigned DestAS) const override;
 
+    bool isCheapAddrSpaceCast(unsigned SrcAS, unsigned DestAS) const override;
+
+    bool isLosslessAddrSpaceCast(unsigned SrcAS, unsigned DestAS)const override;
+
     /// Customize the preferred legalization strategy for certain types.
     LegalizeTypeAction getPreferredVectorAction(EVT VT) const override;
 
@@ -1218,6 +1227,7 @@
     SDValue LowerUINT_TO_FP(SDValue Op, SelectionDAG &DAG) const;
     SDValue LowerTRUNCATE(SDValue Op, SelectionDAG &DAG) const;
     SDValue LowerFP_TO_INT(SDValue Op, SelectionDAG &DAG) const;
+    SDValue LowerADDRSPACECAST(SDValue Op, SelectionDAG &DAG) const;
     SDValue LowerSETCC(SDValue Op, SelectionDAG &DAG) const;
     SDValue LowerSETCCCARRY(SDValue Op, SelectionDAG &DAG) const;
     SDValue LowerSELECT(SDValue Op, SelectionDAG &DAG) const;
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstrCompiler.td llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstrCompiler.td
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstrCompiler.td	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstrCompiler.td	2019-05-19 11:21:51.785903000 +0000
@@ -50,14 +50,14 @@
 let Defs = [ESP, EFLAGS, SSP], Uses = [ESP, SSP], SchedRW = [WriteALU] in {
 def ADJCALLSTACKDOWN32 : I<0, Pseudo, (outs),
                            (ins i32imm:$amt1, i32imm:$amt2, i32imm:$amt3),
-                           "#ADJCALLSTACKDOWN", []>, Requires<[NotLP64]>;
+                           "#ADJCALLSTACKDOWN", []>, Requires<[Stack32]>;
 def ADJCALLSTACKUP32   : I<0, Pseudo, (outs), (ins i32imm:$amt1, i32imm:$amt2),
                            "#ADJCALLSTACKUP",
                            [(X86callseq_end timm:$amt1, timm:$amt2)]>,
-                           Requires<[NotLP64]>;
+                           Requires<[Stack32]>;
 }
 def : Pat<(X86callseq_start timm:$amt1, timm:$amt2),
-       (ADJCALLSTACKDOWN32 i32imm:$amt1, i32imm:$amt2, 0)>, Requires<[NotLP64]>;
+       (ADJCALLSTACKDOWN32 i32imm:$amt1, i32imm:$amt2, 0)>, Requires<[Stack32]>;
 
 
 // ADJCALLSTACKDOWN/UP implicitly use/def RSP because they may be expanded into
@@ -68,14 +68,15 @@
 let Defs = [RSP, EFLAGS, SSP], Uses = [RSP, SSP], SchedRW = [WriteALU] in {
 def ADJCALLSTACKDOWN64 : I<0, Pseudo, (outs),
                            (ins i32imm:$amt1, i32imm:$amt2, i32imm:$amt3),
-                           "#ADJCALLSTACKDOWN", []>, Requires<[IsLP64]>;
+                           "#ADJCALLSTACKDOWN", []>, Requires<[Stack64]>;
 def ADJCALLSTACKUP64   : I<0, Pseudo, (outs), (ins i32imm:$amt1, i32imm:$amt2),
                            "#ADJCALLSTACKUP",
                            [(X86callseq_end timm:$amt1, timm:$amt2)]>,
-                           Requires<[IsLP64]>;
+                           Requires<[Stack64]>;
 }
 def : Pat<(X86callseq_start timm:$amt1, timm:$amt2),
-        (ADJCALLSTACKDOWN64 i32imm:$amt1, i32imm:$amt2, 0)>, Requires<[IsLP64]>;
+        (ADJCALLSTACKDOWN64 i32imm:$amt1, i32imm:$amt2, 0)>,
+        Requires<[Stack64]>;
 
 let SchedRW = [WriteSystem] in {
 
@@ -114,7 +115,7 @@
                       "# variable sized alloca for segmented stacks",
                       [(set GR32:$dst,
                          (X86SegAlloca GR32:$size))]>,
-                    Requires<[NotLP64]>;
+                    Requires<[Stack32]>;
 
 let Defs = [RAX, RSP, EFLAGS], Uses = [RSP] in
 def SEG_ALLOCA_64 : I<0, Pseudo, (outs GR64:$dst), (ins GR64:$size),
@@ -136,7 +137,7 @@
 def WIN_ALLOCA_32 : I<0, Pseudo, (outs), (ins GR32:$size),
                      "# dynamic stack allocation",
                      [(X86WinAlloca GR32:$size)]>,
-                     Requires<[NotLP64]>;
+                     Requires<[Stack32]>;
 
 let Defs = [RAX, RSP, EFLAGS], Uses = [RSP] in
 def WIN_ALLOCA_64 : I<0, Pseudo, (outs), (ins GR64:$size),
@@ -151,7 +152,7 @@
 let Constraints = "$src = $dst", isPseudo = 1, Defs = [EFLAGS] in {
   def XOR32_FP : I<0, Pseudo, (outs GR32:$dst), (ins GR32:$src),
                   "xorl\t$$FP, $src", []>,
-                  Requires<[NotLP64]>, Sched<[WriteALU]>;
+                  Requires<[Stack32]>, Sched<[WriteALU]>;
   def XOR64_FP : I<0, Pseudo, (outs GR64:$dst), (ins GR64:$src),
                   "xorq\t$$FP $src", []>,
                   Requires<[In64BitMode]>, Sched<[WriteALU]>;
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstrControl.td llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstrControl.td
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstrControl.td	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstrControl.td	2019-05-19 11:21:51.785903000 +0000
@@ -339,6 +339,15 @@
 
   def FARCALL64   : RI<0xFF, MRM3m, (outs), (ins opaquemem:$dst),
                        "lcall{q}\t{*}$dst", []>;
+
+  // Special pseudo-instructions for modeling 64->32 far calls.
+  let isCodeGenOnly = 1 in {
+  def FARCALL6432r       : PseudoI<(outs), (ins GR32:$dst, i16imm:$amt),
+                                   [(X86farcall32 GR32:$dst, imm:$amt)]>;
+  def FARCALL6432m       : PseudoI<(outs), (ins i32mem:$dst, i16imm:$amt),
+                                   [(X86farcall32 (loadi32 addr:$dst),
+                                                  imm:$amt)]>;
+  }
 }
 
 let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1,
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstrInfo.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstrInfo.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstrInfo.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstrInfo.cpp	2019-05-19 11:21:51.795903000 +0000
@@ -78,10 +78,11 @@
 void X86InstrInfo::anchor() {}
 
 X86InstrInfo::X86InstrInfo(X86Subtarget &STI)
-    : X86GenInstrInfo((STI.isTarget64BitLP64() ? X86::ADJCALLSTACKDOWN64
-                                               : X86::ADJCALLSTACKDOWN32),
-                      (STI.isTarget64BitLP64() ? X86::ADJCALLSTACKUP64
-                                               : X86::ADJCALLSTACKUP32),
+    : X86GenInstrInfo(
+        ((STI.isTarget64BitLP64() && !STI.isTarget64BitWine32())
+            ? X86::ADJCALLSTACKDOWN64 : X86::ADJCALLSTACKDOWN32),
+        ((STI.isTarget64BitLP64() && !STI.isTarget64BitWine32())
+            ? X86::ADJCALLSTACKUP64 : X86::ADJCALLSTACKUP32),
                       X86::CATCHRET,
                       (STI.is64Bit() ? X86::RETQ : X86::RETL)),
       Subtarget(STI), RI(STI.getTargetTriple()) {
@@ -3090,6 +3091,23 @@
   // All KMASK RegClasses hold the same k registers, can be tested against anyone.
   else if (X86::VK16RegClass.contains(DestReg, SrcReg))
     Opc = Subtarget.hasBWI() ? X86::KMOVQkk : X86::KMOVWkk;
+  else if (X86::GR64RegClass.contains(DestReg) &&
+           X86::GR32RegClass.contains(SrcReg)) {
+    // This can happen with __ptr32 pointers. Since any 32-bit move zeroes
+    // the upper 32 bits of a 64-bit register, we can get away with a 32-bit
+    // move here.
+    Opc = X86::MOV32rr;
+    // But we need the corresponding 32-bit register for the destination.
+    DestReg = getRegisterInfo().getSubReg(DestReg, X86::sub_32bit);
+  } else if (X86::GR32RegClass.contains(DestReg) &&
+             X86::GR64RegClass.contains(SrcReg)) {
+    // This can happen with __ptr32 pointers. Since any 32-bit move zeroes
+    // the upper 32 bits of a 64-bit register, we can get away with a 32-bit
+    // move here.
+    Opc = X86::MOV32rr;
+    // But we need the corresponding 32-bit register for the source.
+    SrcReg = getRegisterInfo().getSubReg(SrcReg, X86::sub_32bit);
+  }
   if (!Opc)
     Opc = CopyToFromAsymmetricReg(DestReg, SrcReg, Subtarget);
 
@@ -7343,6 +7361,19 @@
   return makeArrayRef(TargetFlags);
 }
 
+void X86InstrInfo::emitPatchableOp(StringRef PatchType,
+                                   MachineBasicBlock &MBB,
+                                   MachineBasicBlock::iterator &MBBI) const {
+  if (PatchType != "ms-hotpatch" || !Subtarget.is32Bit()) {
+    TargetInstrInfo::emitPatchableOp(PatchType, MBB, MBBI);
+    return;
+  }
+
+  BuildMI(MBB, MBBI, MBBI->getDebugLoc(), get(X86::MOV32rr_REV), X86::EDI)
+      .addReg(X86::EDI)
+      .setMIFlag(MachineInstr::FrameSetup);
+}
+
 namespace {
   /// Create Global Base Reg pass. This initializes the PIC
   /// global base register for x86-32.
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstrInfo.h llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstrInfo.h
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstrInfo.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstrInfo.h	2019-05-19 11:21:51.795903000 +0000
@@ -561,6 +561,10 @@
                      MachineBasicBlock::iterator &It, MachineFunction &MF,
                      const outliner::Candidate &C) const override;
 
+  void
+  emitPatchableOp(StringRef PatchType, MachineBasicBlock &MBB,
+                  MachineBasicBlock::iterator &MBBI) const override;
+
 protected:
   /// Commutes the operands in the given instruction by changing the operands
   /// order and/or changing the instruction's opcode and/or the immediate value
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstrInfo.td llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstrInfo.td
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstrInfo.td	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstrInfo.td	2019-05-19 11:21:51.795903000 +0000
@@ -94,6 +94,9 @@
 
 def SDT_X86Call   : SDTypeProfile<0, -1, [SDTCisVT<0, iPTR>]>;
 
+def SDT_X86FarCall32 : SDTypeProfile<0, -1, [SDTCisVT<0, i32>,
+                                             SDTCisVT<1, i16>]>;
+
 def SDT_X86NtBrind : SDTypeProfile<0, -1, [SDTCisVT<0, iPTR>]>;
 
 def SDT_X86VASTART_SAVE_XMM_REGS : SDTypeProfile<0, -1, [SDTCisVT<0, i8>,
@@ -204,6 +207,10 @@
 def X86NoTrackBrind : SDNode<"X86ISD::NT_BRIND", SDT_X86NtBrind,
                              [SDNPHasChain]>;
 
+def X86farcall32 : SDNode<"X86ISD::FARCALL32", SDT_X86FarCall32,
+                          [SDNPHasChain, SDNPOutGlue, SDNPOptInGlue,
+                           SDNPVariadic]>;
+
 def X86rep_stos: SDNode<"X86ISD::REP_STOS", SDTX86RepStr,
                         [SDNPHasChain, SDNPInGlue, SDNPOutGlue, SDNPMayStore]>;
 def X86rep_movs: SDNode<"X86ISD::REP_MOVS", SDTX86RepStr,
@@ -913,6 +920,10 @@
                              AssemblerPredicate<"Mode64Bit", "64-bit mode">;
 def IsLP64  : Predicate<"Subtarget->isTarget64BitLP64()">;
 def NotLP64 : Predicate<"!Subtarget->isTarget64BitLP64()">;
+def Stack32 : Predicate<"!Subtarget->isTarget64BitLP64() || "
+                        "Subtarget->isTarget64BitWine32()">;
+def Stack64 : Predicate<"Subtarget->isTarget64BitLP64() && "
+                        "!Subtarget->isTarget64BitWine32()">;
 def In16BitMode  : Predicate<"Subtarget->is16Bit()">,
                              AssemblerPredicate<"Mode16Bit", "16-bit mode">;
 def Not16BitMode : Predicate<"!Subtarget->is16Bit()">,
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstructionSelector.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstructionSelector.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86InstructionSelector.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86InstructionSelector.cpp	2019-05-19 11:21:51.795903000 +0000
@@ -532,7 +532,7 @@
   if (Ty == LLT::pointer(0, 64))
     return X86::LEA64r;
   else if (Ty == LLT::pointer(0, 32))
-    return STI.isTarget64BitILP32() ? X86::LEA64_32r : X86::LEA32r;
+    return STI.is64Bit() ? X86::LEA64_32r : X86::LEA32r;
   else
     llvm_unreachable("Can't get LEA opcode. Unsupported type.");
 }
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86RegisterInfo.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86RegisterInfo.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86RegisterInfo.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86RegisterInfo.cpp	2019-05-19 11:21:51.795903000 +0000
@@ -61,7 +61,8 @@
     // This matches the simplified 32-bit pointer code in the data layout
     // computation.
     // FIXME: Should use the data layout?
-    bool Use64BitReg = TT.getEnvironment() != Triple::GNUX32;
+    bool Use64BitReg = TT.getEnvironment() != Triple::GNUX32 &&
+                       TT.getEnvironment() != Triple::Wine32;
     StackPtr = Use64BitReg ? X86::RSP : X86::ESP;
     FramePtr = Use64BitReg ? X86::RBP : X86::EBP;
     BasePtr = Use64BitReg ? X86::RBX : X86::EBX;
@@ -182,6 +183,8 @@
   switch (Kind) {
   default: llvm_unreachable("Unexpected Kind in getPointerRegClass!");
   case 0: // Normal GPRs.
+    if (Subtarget.isTarget64BitWine32())
+      return &X86::MIXED_ADDR_ACCESSRegClass;
     if (Subtarget.isTarget64BitLP64())
       return &X86::GR64RegClass;
     // If the target is 64bit but we have been told to use 32bit addresses,
@@ -198,15 +201,21 @@
     }
     return &X86::GR32RegClass;
   case 1: // Normal GPRs except the stack pointer (for encoding reasons).
+    if (Subtarget.isTarget64BitWine32())
+      return &X86::MIXED_ADDR_ACCESS_NOSPRegClass;
     if (Subtarget.isTarget64BitLP64())
       return &X86::GR64_NOSPRegClass;
     // NOSP does not contain RIP, so no special case here.
     return &X86::GR32_NOSPRegClass;
   case 2: // NOREX GPRs.
+    if (Subtarget.isTarget64BitWine32())
+      return &X86::MIXED_ADDR_ACCESS_NOREXRegClass;
     if (Subtarget.isTarget64BitLP64())
       return &X86::GR64_NOREXRegClass;
     return &X86::GR32_NOREXRegClass;
   case 3: // NOREX GPRs except the stack pointer (for encoding reasons).
+    if (Subtarget.isTarget64BitWine32())
+      return &X86::MIXED_ADDR_ACCESS_NOREX_NOSPRegClass;
     if (Subtarget.isTarget64BitLP64())
       return &X86::GR64_NOREX_NOSPRegClass;
     // NOSP does not contain RIP, so no special case here.
@@ -356,6 +365,16 @@
         return CSR_32_AllRegs_SSE_SaveList;
       return CSR_32_AllRegs_SaveList;
     }
+  case CallingConv::X86_64_C32:
+    if (Is64Bit)
+      return CallsEHReturn ? CSR_6432EHRet_SaveList : CSR_6432_SaveList;
+    break;
+  case CallingConv::X86_StdCall:
+  case CallingConv::X86_FastCall:
+  case CallingConv::X86_ThisCall:
+    if (Subtarget.isTarget64BitWine32())
+      return CallsEHReturn ? CSR_6432EHRet_SaveList : CSR_6432_SaveList;
+    break;
   default:
     break;
   }
@@ -466,6 +485,16 @@
         return CSR_32_AllRegs_SSE_RegMask;
       return CSR_32_AllRegs_RegMask;
     }
+  case CallingConv::X86_64_C32:
+    if (Is64Bit)
+      return CSR_6432_RegMask;
+    break;
+  case CallingConv::X86_StdCall:
+  case CallingConv::X86_FastCall:
+  case CallingConv::X86_ThisCall:
+    if (Subtarget.isTarget64BitWine32())
+      return CSR_6432_RegMask;
+    break;
   default:
     break;
   }
@@ -747,6 +776,20 @@
   }
 }
 
+bool X86RegisterInfo::shouldCoalesce(MachineInstr *MI,
+                                     const TargetRegisterClass *SrcRC,
+                                     unsigned SubReg,
+                                     const TargetRegisterClass *DstRC,
+                                     unsigned DstSubReg,
+                                     const TargetRegisterClass *NewRC,
+                                     LiveIntervals &LIS) const {
+  // MIXED_ADDR_ACCESS should never be used outside of getPointerRegClass().
+  return NewRC != &X86::MIXED_ADDR_ACCESSRegClass &&
+         NewRC != &X86::MIXED_ADDR_ACCESS_NOREXRegClass &&
+         NewRC != &X86::MIXED_ADDR_ACCESS_NOSPRegClass &&
+         NewRC != &X86::MIXED_ADDR_ACCESS_NOREX_NOSPRegClass;
+}
+
 unsigned X86RegisterInfo::getFrameRegister(const MachineFunction &MF) const {
   const X86FrameLowering *TFI = getFrameLowering(MF);
   return TFI->hasFP(MF) ? FramePtr : StackPtr;
@@ -756,7 +799,7 @@
 X86RegisterInfo::getPtrSizedFrameRegister(const MachineFunction &MF) const {
   const X86Subtarget &Subtarget = MF.getSubtarget<X86Subtarget>();
   unsigned FrameReg = getFrameRegister(MF);
-  if (Subtarget.isTarget64BitILP32())
+  if (Subtarget.isTarget64BitILP32() || Subtarget.isTarget64BitWine32())
     FrameReg = getX86SubSuperRegister(FrameReg, 32);
   return FrameReg;
 }
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86RegisterInfo.h llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86RegisterInfo.h
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86RegisterInfo.h	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86RegisterInfo.h	2019-05-19 11:21:51.795903000 +0000
@@ -128,6 +128,12 @@
                            int SPAdj, unsigned FIOperandNum,
                            RegScavenger *RS = nullptr) const override;
 
+  bool shouldCoalesce(MachineInstr *MI,
+                      const TargetRegisterClass *SrcRC, unsigned SubReg,
+                      const TargetRegisterClass *DstRC, unsigned DstSubReg,
+                      const TargetRegisterClass *NewRC,
+                      LiveIntervals &LIS) const override;
+
   // Debug information queries.
   unsigned getFrameRegister(const MachineFunction &MF) const override;
   unsigned getPtrSizedFrameRegister(const MachineFunction &MF) const;
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86RegisterInfo.td llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86RegisterInfo.td
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86RegisterInfo.td	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86RegisterInfo.td	2019-05-19 11:21:51.795903000 +0000
@@ -495,6 +495,20 @@
 def LOW32_ADDR_ACCESS_RBP : RegisterClass<"X86", [i32], 32,
                                           (add LOW32_ADDR_ACCESS, RBP)>;
 
+// Register classes to support mixed 32-bit and 64-bit pointers in a 64-bit
+// environment.
+
+let isAllocatable = 0 in {
+  def MIXED_ADDR_ACCESS : RegisterClass<"X86", [i32, i64], 32,
+                                        (interleave GR32, GR64)>;
+  def MIXED_ADDR_ACCESS_NOREX : RegisterClass<"X86", [i32, i64], 32,
+                                           (interleave GR32_NOREX, GR64_NOREX)>;
+  def MIXED_ADDR_ACCESS_NOSP : RegisterClass<"X86", [i32, i64], 32,
+                                             (interleave GR32_NOSP, GR64_NOSP)>;
+  def MIXED_ADDR_ACCESS_NOREX_NOSP : RegisterClass<"X86", [i32, i64], 32,
+                                (interleave GR32_NOREX_NOSP, GR64_NOREX_NOSP)>;
+}
+
 // A class to support the 'A' assembler constraint: [ER]AX then [ER]DX.
 def GR32_AD : RegisterClass<"X86", [i32], 32, (add EAX, EDX)>;
 def GR64_AD : RegisterClass<"X86", [i64], 64, (add RAX, RDX)>;
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86Subtarget.h llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86Subtarget.h
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86Subtarget.h	2019-05-19 11:25:23.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86Subtarget.h	2019-05-19 11:21:51.795903000 +0000
@@ -529,6 +529,12 @@
                            !TargetTriple.isOSNaCl());
   }
 
+  /// Is this x86_64 with a hybrid ILP32/LP64 programming model (for building
+  /// Wine capable of running 32-bit apps on 64-bit)?
+  bool isTarget64BitWine32() const {
+    return In64BitMode && TargetTriple.getEnvironment() == Triple::Wine32;
+  }
+
   PICStyles::Style getPICStyle() const { return PICStyle; }
   void setPICStyle(PICStyles::Style Style)  { PICStyle = Style; }
 
@@ -780,6 +786,18 @@
     default:
       return false;
     }
+  }
+
+  bool isCallingConv6432Interop(CallingConv::ID CC) const {
+    switch (CC) {
+    case CallingConv::X86_64_C32:
+    case CallingConv::X86_FastCall:
+    case CallingConv::X86_StdCall:
+    case CallingConv::X86_ThisCall:
+      return isTarget64BitWine32();
+    default:
+      return false;
+    }
   }
 
   /// Classify a global variable reference for the current subtarget according
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Target/X86/X86TargetMachine.cpp llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86TargetMachine.cpp
--- llvm-toolchain-7-7.0.1/lib/Target/X86/X86TargetMachine.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Target/X86/X86TargetMachine.cpp	2019-05-19 11:21:51.795903000 +0000
@@ -124,6 +124,11 @@
        (TT.getEnvironment() == Triple::GNUX32 || TT.isOSNaCl())) ||
       !TT.isArch64Bit())
     Ret += "-p:32:32";
+  // On Wine32, add an address space for (ab)using 32-bit pointers.
+  // Put the stack in this address space as well, since we'll be calling
+  // 32-bit functions that expect a 32-bit stack.
+  if (TT.isArch64Bit() && TT.getEnvironment() == Triple::Wine32)
+    Ret += "-p32:32:32-A32";
 
   // Some ABIs align 64 bit integers and doubles to 64 bits, others to 32.
   if (TT.isArch64Bit() || TT.isOSWindows() || TT.isOSNaCl())
@@ -518,4 +523,6 @@
   const Triple &TT = TM->getTargetTriple();
   if (!TT.isOSDarwin() && !TT.isOSWindows())
     addPass(createCFIInstrInserter());
+  if (TT.getEnvironment() == Triple::Wine32)
+    addPass(createX866432InteropThunkInserter());
 }
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp llvm-toolchain-7-7.0.1.patched/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
--- llvm-toolchain-7-7.0.1/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp	2019-05-19 11:21:51.795903000 +0000
@@ -645,8 +645,8 @@
                                         GlobalValue::LinkageTypes NewFLink,
                                         FunctionType *NewFT) {
   FunctionType *FT = F->getFunctionType();
-  Function *NewF = Function::Create(NewFT, NewFLink, NewFName,
-                                    F->getParent());
+  Function *NewF = Function::Create(NewFT, NewFLink, F->getAddressSpace(),
+                                    NewFName, F->getParent());
   NewF->copyAttributesFrom(F);
   NewF->removeAttributes(
       AttributeList::ReturnIndex,
@@ -819,7 +819,8 @@
       // easily identify cases of mismatching ABIs.
       if (getInstrumentedABI() == IA_Args && !IsZeroArgsVoidRet) {
         FunctionType *NewFT = getArgsFunctionType(FT);
-        Function *NewF = Function::Create(NewFT, F.getLinkage(), "", &M);
+        Function *NewF = Function::Create(NewFT, F.getLinkage(),
+                                          F.getAddressSpace(), "", &M);
         NewF->copyAttributesFrom(&F);
         NewF->removeAttributes(
             AttributeList::ReturnIndex,
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Transforms/Utils/BuildLibCalls.cpp llvm-toolchain-7-7.0.1.patched/lib/Transforms/Utils/BuildLibCalls.cpp
--- llvm-toolchain-7-7.0.1/lib/Transforms/Utils/BuildLibCalls.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Transforms/Utils/BuildLibCalls.cpp	2019-05-19 11:21:51.795903000 +0000
@@ -754,7 +754,10 @@
 
 Value *llvm::castToCStr(Value *V, IRBuilder<> &B) {
   unsigned AS = V->getType()->getPointerAddressSpace();
-  return B.CreateBitCast(V, B.getInt8PtrTy(AS), "cstr");
+  V = B.CreateBitCast(V, B.getInt8PtrTy(AS), "cstr");
+  if (AS != 0)
+    V = B.CreateAddrSpaceCast(V, B.getInt8PtrTy(), "cstr.as");
+  return V;
 }
 
 Value *llvm::emitStrLen(Value *Ptr, IRBuilder<> &B, const DataLayout &DL,
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Transforms/Utils/CloneFunction.cpp llvm-toolchain-7-7.0.1.patched/lib/Transforms/Utils/CloneFunction.cpp
--- llvm-toolchain-7-7.0.1/lib/Transforms/Utils/CloneFunction.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Transforms/Utils/CloneFunction.cpp	2019-05-19 11:21:51.795903000 +0000
@@ -235,8 +235,8 @@
                                     ArgTypes, F->getFunctionType()->isVarArg());
 
   // Create the new function...
-  Function *NewF =
-      Function::Create(FTy, F->getLinkage(), F->getName(), F->getParent());
+  Function *NewF = Function::Create(FTy, F->getLinkage(), F->getAddressSpace(),
+                                    F->getName(), F->getParent());
 
   // Loop over the arguments, copying the names of the mapped arguments over...
   Function::arg_iterator DestI = NewF->arg_begin();
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Transforms/Utils/CloneModule.cpp llvm-toolchain-7-7.0.1.patched/lib/Transforms/Utils/CloneModule.cpp
--- llvm-toolchain-7-7.0.1/lib/Transforms/Utils/CloneModule.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Transforms/Utils/CloneModule.cpp	2019-05-19 11:21:51.795903000 +0000
@@ -74,8 +74,9 @@
 
   // Loop over the functions in the module, making external functions as before
   for (const Function &I : M) {
-    Function *NF = Function::Create(cast<FunctionType>(I.getValueType()),
-                                    I.getLinkage(), I.getName(), New.get());
+    Function *NF =
+        Function::Create(cast<FunctionType>(I.getValueType()), I.getLinkage(),
+                         I.getAddressSpace(), I.getName(), New.get());
     NF->copyAttributesFrom(&I);
     VMap[&I] = NF;
   }
@@ -91,8 +92,8 @@
       GlobalValue *GV;
       if (I->getValueType()->isFunctionTy())
         GV = Function::Create(cast<FunctionType>(I->getValueType()),
-                              GlobalValue::ExternalLinkage, I->getName(),
-                              New.get());
+                              GlobalValue::ExternalLinkage,
+                              I->getAddressSpace(), I->getName(), New.get());
       else
         GV = new GlobalVariable(
             *New, I->getValueType(), false, GlobalValue::ExternalLinkage,
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Transforms/Utils/CodeExtractor.cpp llvm-toolchain-7-7.0.1.patched/lib/Transforms/Utils/CodeExtractor.cpp
--- llvm-toolchain-7-7.0.1/lib/Transforms/Utils/CodeExtractor.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Transforms/Utils/CodeExtractor.cpp	2019-05-19 11:21:51.795903000 +0000
@@ -670,10 +670,9 @@
                                     AllowVarArgs && oldFunction->isVarArg());
 
   // Create the new function
-  Function *newFunction = Function::Create(funcType,
-                                           GlobalValue::InternalLinkage,
-                                           oldFunction->getName() + "_" +
-                                           header->getName(), M);
+  Function *newFunction = Function::Create(
+      funcType, GlobalValue::InternalLinkage, oldFunction->getAddressSpace(),
+      oldFunction->getName() + "_" + header->getName(), M);
   // If the old function is no-throw, so is the new one.
   if (oldFunction->doesNotThrow())
     newFunction->setDoesNotThrow();
@@ -719,6 +718,7 @@
       case Attribute::NoReturn:
       case Attribute::None:
       case Attribute::NonNull:
+      case Attribute::ThunkData:
       case Attribute::ReadNone:
       case Attribute::ReadOnly:
       case Attribute::Returned:
diff -rN --unified llvm-toolchain-7-7.0.1/lib/Transforms/Utils/SimplifyLibCalls.cpp llvm-toolchain-7-7.0.1.patched/lib/Transforms/Utils/SimplifyLibCalls.cpp
--- llvm-toolchain-7-7.0.1/lib/Transforms/Utils/SimplifyLibCalls.cpp	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/lib/Transforms/Utils/SimplifyLibCalls.cpp	2019-05-19 11:21:51.795903000 +0000
@@ -796,12 +796,14 @@
     // First, see if we can fold either argument to a constant.
     Value *LHSV = nullptr;
     if (auto *LHSC = dyn_cast<Constant>(LHS)) {
-      LHSC = ConstantExpr::getBitCast(LHSC, IntType->getPointerTo());
+      LHSC = ConstantExpr::getBitCast(LHSC, IntType->getPointerTo(
+          LHSC->getType()->getPointerAddressSpace()));
       LHSV = ConstantFoldLoadFromConstPtr(LHSC, IntType, DL);
     }
     Value *RHSV = nullptr;
     if (auto *RHSC = dyn_cast<Constant>(RHS)) {
-      RHSC = ConstantExpr::getBitCast(RHSC, IntType->getPointerTo());
+      RHSC = ConstantExpr::getBitCast(RHSC, IntType->getPointerTo(
+          RHSC->getType()->getPointerAddressSpace()));
       RHSV = ConstantFoldLoadFromConstPtr(RHSC, IntType, DL);
     }
 
diff -rN --unified llvm-toolchain-7-7.0.1/polly/lib/External/isl/config.guess llvm-toolchain-7-7.0.1.patched/polly/lib/External/isl/config.guess
--- llvm-toolchain-7-7.0.1/polly/lib/External/isl/config.guess	2018-12-16 12:05:58.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/polly/lib/External/isl/config.guess	2019-05-19 11:21:51.795903000 +0000
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2018 Free Software Foundation, Inc.
+#   Copyright 1992-2016 Free Software Foundation, Inc.
 
-timestamp='2018-02-24'
+timestamp='2016-10-02'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -15,7 +15,7 @@
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, see <https://www.gnu.org/licenses/>.
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
@@ -27,7 +27,7 @@
 # Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
-# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 #
 # Please send patches to <config-patches@gnu.org>.
 
@@ -39,7 +39,7 @@
 
 Output the configuration name of the system \`$me' is run on.
 
-Options:
+Operation modes:
   -h, --help         print this help, then exit
   -t, --time-stamp   print date of last modification, then exit
   -v, --version      print version number, then exit
@@ -50,7 +50,7 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2018 Free Software Foundation, Inc.
+Copyright 1992-2016 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -107,9 +107,9 @@
 dummy=$tmp/dummy ;
 tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
 case $CC_FOR_BUILD,$HOST_CC,$CC in
- ,,)    echo "int x;" > "$dummy.c" ;
+ ,,)    echo "int x;" > $dummy.c ;
 	for c in cc gcc c89 c99 ; do
-	  if ($c -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
+	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
 	     CC_FOR_BUILD="$c"; break ;
 	  fi ;
 	done ;
@@ -132,14 +132,14 @@
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
-case "$UNAME_SYSTEM" in
+case "${UNAME_SYSTEM}" in
 Linux|GNU|GNU/*)
 	# If the system lacks a compiler, then just pick glibc.
 	# We could probably try harder.
 	LIBC=gnu
 
-	eval "$set_cc_for_build"
-	cat <<-EOF > "$dummy.c"
+	eval $set_cc_for_build
+	cat <<-EOF > $dummy.c
 	#include <features.h>
 	#if defined(__UCLIBC__)
 	LIBC=uclibc
@@ -149,20 +149,13 @@
 	LIBC=gnu
 	#endif
 	EOF
-	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`"
-
-	# If ldd exists, use it to detect musl libc.
-	if command -v ldd >/dev/null && \
-		ldd --version 2>&1 | grep -q ^musl
-	then
-	    LIBC=musl
-	fi
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
 	;;
 esac
 
 # Note: order is significant - the case branches are not exclusive.
 
-case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     *:NetBSD:*:*)
 	# NetBSD (nbsd) targets should (where applicable) match one or
 	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
@@ -176,30 +169,30 @@
 	# portion of the name.  We always set it to "unknown".
 	sysctl="sysctl -n hw.machine_arch"
 	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
-	    "/sbin/$sysctl" 2>/dev/null || \
-	    "/usr/sbin/$sysctl" 2>/dev/null || \
+	    /sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || \
 	    echo unknown)`
-	case "$UNAME_MACHINE_ARCH" in
+	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
 	    earmv*)
-		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
-		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
-		machine="${arch}${endian}"-unknown
+		arch=`echo ${UNAME_MACHINE_ARCH} | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo ${UNAME_MACHINE_ARCH} | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
 		;;
-	    *) machine="$UNAME_MACHINE_ARCH"-unknown ;;
+	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently (or will in the future) and ABI.
-	case "$UNAME_MACHINE_ARCH" in
+	case "${UNAME_MACHINE_ARCH}" in
 	    earm*)
 		os=netbsdelf
 		;;
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
-		eval "$set_cc_for_build"
+		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
 			| grep -q __ELF__
 		then
@@ -215,10 +208,10 @@
 		;;
 	esac
 	# Determine ABI tags.
-	case "$UNAME_MACHINE_ARCH" in
+	case "${UNAME_MACHINE_ARCH}" in
 	    earm*)
 		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
-		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
+		abi=`echo ${UNAME_MACHINE_ARCH} | sed -e "$expr"`
 		;;
 	esac
 	# The OS release
@@ -226,55 +219,46 @@
 	# thus, need a distinct triplet. However, they do not need
 	# kernel version information, so it can be replaced with a
 	# suitable tag, in the style of linux-gnu.
-	case "$UNAME_VERSION" in
+	case "${UNAME_VERSION}" in
 	    Debian*)
 		release='-gnu'
 		;;
 	    *)
-		release=`echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2`
+		release=`echo ${UNAME_RELEASE} | sed -e 's/[-_].*//' | cut -d. -f1,2`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "$machine-${os}${release}${abi}"
+	echo "${machine}-${os}${release}${abi}"
 	exit ;;
     *:Bitrig:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
-	echo "$UNAME_MACHINE_ARCH"-unknown-bitrig"$UNAME_RELEASE"
+	echo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}
 	exit ;;
     *:OpenBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
-	echo "$UNAME_MACHINE_ARCH"-unknown-openbsd"$UNAME_RELEASE"
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
 	exit ;;
     *:LibertyBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
-	echo "$UNAME_MACHINE_ARCH"-unknown-libertybsd"$UNAME_RELEASE"
-	exit ;;
-    *:MidnightBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-midnightbsd"$UNAME_RELEASE"
+	echo ${UNAME_MACHINE_ARCH}-unknown-libertybsd${UNAME_RELEASE}
 	exit ;;
     *:ekkoBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-ekkobsd"$UNAME_RELEASE"
+	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
 	exit ;;
     *:SolidBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-solidbsd"$UNAME_RELEASE"
+	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
 	exit ;;
     macppc:MirBSD:*:*)
-	echo powerpc-unknown-mirbsd"$UNAME_RELEASE"
+	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
 	exit ;;
     *:MirBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-mirbsd"$UNAME_RELEASE"
+	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
 	exit ;;
     *:Sortix:*:*)
-	echo "$UNAME_MACHINE"-unknown-sortix
+	echo ${UNAME_MACHINE}-unknown-sortix
 	exit ;;
-    *:Redox:*:*)
-	echo "$UNAME_MACHINE"-unknown-redox
-	exit ;;
-    mips:OSF1:*.*)
-        echo mips-dec-osf1
-        exit ;;
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
@@ -326,19 +310,28 @@
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo "$UNAME_MACHINE"-dec-osf"`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`"
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
 	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
 	exitcode=$?
 	trap '' 0
 	exit $exitcode ;;
+    Alpha\ *:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# Should we change UNAME_MACHINE based on the output of uname instead
+	# of the specific Alpha model?
+	echo alpha-pc-interix
+	exit ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit ;;
     Amiga*:UNIX_System_V:4.0:*)
 	echo m68k-unknown-sysv4
 	exit ;;
     *:[Aa]miga[Oo][Ss]:*:*)
-	echo "$UNAME_MACHINE"-unknown-amigaos
+	echo ${UNAME_MACHINE}-unknown-amigaos
 	exit ;;
     *:[Mm]orph[Oo][Ss]:*:*)
-	echo "$UNAME_MACHINE"-unknown-morphos
+	echo ${UNAME_MACHINE}-unknown-morphos
 	exit ;;
     *:OS/390:*:*)
 	echo i370-ibm-openedition
@@ -350,7 +343,7 @@
 	echo powerpc-ibm-os400
 	exit ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
-	echo arm-acorn-riscix"$UNAME_RELEASE"
+	echo arm-acorn-riscix${UNAME_RELEASE}
 	exit ;;
     arm*:riscos:*:*|arm*:RISCOS:*:*)
 	echo arm-unknown-riscos
@@ -377,19 +370,19 @@
 	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
     s390x:SunOS:*:*)
-	echo "$UNAME_MACHINE"-ibm-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
+	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
     sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
     i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
-	echo i386-pc-auroraux"$UNAME_RELEASE"
+	echo i386-pc-auroraux${UNAME_RELEASE}
 	exit ;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
-	eval "$set_cc_for_build"
+	eval $set_cc_for_build
 	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
@@ -402,13 +395,13 @@
 		SUN_ARCH=x86_64
 	    fi
 	fi
-	echo "$SUN_ARCH"-pc-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
     sun4*:SunOS:*:*)
 	case "`/usr/bin/arch -k`" in
@@ -417,25 +410,25 @@
 		;;
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos"`echo "$UNAME_RELEASE"|sed -e 's/-/_/'`"
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
 	exit ;;
     sun3*:SunOS:*:*)
-	echo m68k-sun-sunos"$UNAME_RELEASE"
+	echo m68k-sun-sunos${UNAME_RELEASE}
 	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
+	test "x${UNAME_RELEASE}" = x && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
-		echo m68k-sun-sunos"$UNAME_RELEASE"
+		echo m68k-sun-sunos${UNAME_RELEASE}
 		;;
 	    sun4)
-		echo sparc-sun-sunos"$UNAME_RELEASE"
+		echo sparc-sun-sunos${UNAME_RELEASE}
 		;;
 	esac
 	exit ;;
     aushp:SunOS:*:*)
-	echo sparc-auspex-sunos"$UNAME_RELEASE"
+	echo sparc-auspex-sunos${UNAME_RELEASE}
 	exit ;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
@@ -446,44 +439,44 @@
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
+	echo m68k-atari-mint${UNAME_RELEASE}
 	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
+	echo m68k-atari-mint${UNAME_RELEASE}
 	exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
+	echo m68k-atari-mint${UNAME_RELEASE}
 	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-	echo m68k-milan-mint"$UNAME_RELEASE"
+	echo m68k-milan-mint${UNAME_RELEASE}
 	exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-	echo m68k-hades-mint"$UNAME_RELEASE"
+	echo m68k-hades-mint${UNAME_RELEASE}
 	exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-	echo m68k-unknown-mint"$UNAME_RELEASE"
+	echo m68k-unknown-mint${UNAME_RELEASE}
 	exit ;;
     m68k:machten:*:*)
-	echo m68k-apple-machten"$UNAME_RELEASE"
+	echo m68k-apple-machten${UNAME_RELEASE}
 	exit ;;
     powerpc:machten:*:*)
-	echo powerpc-apple-machten"$UNAME_RELEASE"
+	echo powerpc-apple-machten${UNAME_RELEASE}
 	exit ;;
     RISC*:Mach:*:*)
 	echo mips-dec-mach_bsd4.3
 	exit ;;
     RISC*:ULTRIX:*:*)
-	echo mips-dec-ultrix"$UNAME_RELEASE"
+	echo mips-dec-ultrix${UNAME_RELEASE}
 	exit ;;
     VAX*:ULTRIX*:*:*)
-	echo vax-dec-ultrix"$UNAME_RELEASE"
+	echo vax-dec-ultrix${UNAME_RELEASE}
 	exit ;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
-	echo clipper-intergraph-clix"$UNAME_RELEASE"
+	echo clipper-intergraph-clix${UNAME_RELEASE}
 	exit ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
-	eval "$set_cc_for_build"
-	sed 's/^	//' << EOF > "$dummy.c"
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
 #ifdef __cplusplus
 #include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
@@ -492,23 +485,23 @@
 #endif
 	#if defined (host_mips) && defined (MIPSEB)
 	#if defined (SYSTYPE_SYSV)
-	  printf ("mips-mips-riscos%ssysv\\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
 	#endif
 	#if defined (SYSTYPE_SVR4)
-	  printf ("mips-mips-riscos%ssvr4\\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
 	#endif
 	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
-	  printf ("mips-mips-riscos%sbsd\\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
 	#endif
 	#endif
 	  exit (-1);
 	}
 EOF
-	$CC_FOR_BUILD -o "$dummy" "$dummy.c" &&
-	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
-	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
 	    { echo "$SYSTEM_NAME"; exit; }
-	echo mips-mips-riscos"$UNAME_RELEASE"
+	echo mips-mips-riscos${UNAME_RELEASE}
 	exit ;;
     Motorola:PowerMAX_OS:*:*)
 	echo powerpc-motorola-powermax
@@ -534,17 +527,17 @@
     AViiON:dgux:*:*)
 	# DG/UX returns AViiON for all architectures
 	UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ "$UNAME_PROCESSOR" = mc88100 ] || [ "$UNAME_PROCESSOR" = mc88110 ]
+	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
 	then
-	    if [ "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx ] || \
-	       [ "$TARGET_BINARY_INTERFACE"x = x ]
+	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
+	       [ ${TARGET_BINARY_INTERFACE}x = x ]
 	    then
-		echo m88k-dg-dgux"$UNAME_RELEASE"
+		echo m88k-dg-dgux${UNAME_RELEASE}
 	    else
-		echo m88k-dg-dguxbcs"$UNAME_RELEASE"
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
 	    fi
 	else
-	    echo i586-dg-dgux"$UNAME_RELEASE"
+	    echo i586-dg-dgux${UNAME_RELEASE}
 	fi
 	exit ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
@@ -561,7 +554,7 @@
 	echo m68k-tektronix-bsd
 	exit ;;
     *:IRIX*:*:*)
-	echo mips-sgi-irix"`echo "$UNAME_RELEASE"|sed -e 's/-/_/g'`"
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
 	exit ;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
 	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
@@ -573,14 +566,14 @@
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
-		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
-	echo "$UNAME_MACHINE"-ibm-aix"$IBM_REV"
+	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
 	exit ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		eval "$set_cc_for_build"
-		sed 's/^		//' << EOF > "$dummy.c"
+		eval $set_cc_for_build
+		sed 's/^		//' << EOF >$dummy.c
 		#include <sys/systemcfg.h>
 
 		main()
@@ -591,7 +584,7 @@
 			exit(0);
 			}
 EOF
-		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
+		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
 		then
 			echo "$SYSTEM_NAME"
 		else
@@ -605,7 +598,7 @@
 	exit ;;
     *:AIX:*:[4567])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
-	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
+	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
@@ -614,18 +607,18 @@
 		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
 			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
-		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
-	echo "$IBM_ARCH"-ibm-aix"$IBM_REV"
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
 	exit ;;
     *:AIX:*:*)
 	echo rs6000-ibm-aix
 	exit ;;
-    ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
 	echo romp-ibm-bsd4.4
 	exit ;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
-	echo romp-ibm-bsd"$UNAME_RELEASE"   # 4.3 with uname added to
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
 	exit ;;                             # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
 	echo rs6000-bull-bosx
@@ -640,28 +633,28 @@
 	echo m68k-hp-bsd4.4
 	exit ;;
     9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
-	case "$UNAME_MACHINE" in
-	    9000/31?)            HP_ARCH=m68000 ;;
-	    9000/[34]??)         HP_ARCH=m68k ;;
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	case "${UNAME_MACHINE}" in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
 		if [ -x /usr/bin/getconf ]; then
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
 		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
-		    case "$sc_cpu_version" in
+		    case "${sc_cpu_version}" in
 		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
 		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
 		      532)                      # CPU_PA_RISC2_0
-			case "$sc_kernel_bits" in
+			case "${sc_kernel_bits}" in
 			  32) HP_ARCH=hppa2.0n ;;
 			  64) HP_ARCH=hppa2.0w ;;
 			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
 			esac ;;
 		    esac
 		fi
-		if [ "$HP_ARCH" = "" ]; then
-		    eval "$set_cc_for_build"
-		    sed 's/^		//' << EOF > "$dummy.c"
+		if [ "${HP_ARCH}" = "" ]; then
+		    eval $set_cc_for_build
+		    sed 's/^		//' << EOF >$dummy.c
 
 		#define _HPUX_SOURCE
 		#include <stdlib.h>
@@ -694,13 +687,13 @@
 		    exit (0);
 		}
 EOF
-		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=`"$dummy"`
+		    (CCOPTS="" $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ "$HP_ARCH" = hppa2.0w ]
+	if [ ${HP_ARCH} = hppa2.0w ]
 	then
-	    eval "$set_cc_for_build"
+	    eval $set_cc_for_build
 
 	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
 	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
@@ -719,15 +712,15 @@
 		HP_ARCH=hppa64
 	    fi
 	fi
-	echo "$HP_ARCH"-hp-hpux"$HPUX_REV"
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
 	exit ;;
     ia64:HP-UX:*:*)
-	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
-	echo ia64-hp-hpux"$HPUX_REV"
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux${HPUX_REV}
 	exit ;;
     3050*:HI-UX:*:*)
-	eval "$set_cc_for_build"
-	sed 's/^	//' << EOF > "$dummy.c"
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
 	#include <unistd.h>
 	int
 	main ()
@@ -752,11 +745,11 @@
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
+	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
 		{ echo "$SYSTEM_NAME"; exit; }
 	echo unknown-hitachi-hiuxwe2
 	exit ;;
-    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
 	echo hppa1.1-hp-bsd
 	exit ;;
     9000/8??:4.3bsd:*:*)
@@ -765,7 +758,7 @@
     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
 	echo hppa1.0-hp-mpeix
 	exit ;;
-    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
 	echo hppa1.1-hp-osf
 	exit ;;
     hp8??:OSF1:*:*)
@@ -773,9 +766,9 @@
 	exit ;;
     i*86:OSF1:*:*)
 	if [ -x /usr/sbin/sysversion ] ; then
-	    echo "$UNAME_MACHINE"-unknown-osf1mk
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
 	else
-	    echo "$UNAME_MACHINE"-unknown-osf1
+	    echo ${UNAME_MACHINE}-unknown-osf1
 	fi
 	exit ;;
     parisc*:Lites*:*:*)
@@ -800,109 +793,127 @@
 	echo c4-convex-bsd
 	exit ;;
     CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*[A-Z]90:*:*:*)
-	echo "$UNAME_MACHINE"-cray-unicos"$UNAME_RELEASE" \
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
 	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
 	      -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*TS:*:*:*)
-	echo t90-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*T3E:*:*:*)
-	echo alphaev5-cray-unicosmk"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     *:UNICOS/mp:*:*)
-	echo craynv-cray-unicosmp"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
 	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
 	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
-	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
 	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     5000:UNIX_System_V:4.*:*)
 	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
-	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
 	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
-	echo "$UNAME_MACHINE"-pc-bsdi"$UNAME_RELEASE"
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
 	exit ;;
     sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi"$UNAME_RELEASE"
+	echo sparc-unknown-bsdi${UNAME_RELEASE}
 	exit ;;
     *:BSD/OS:*:*)
-	echo "$UNAME_MACHINE"-unknown-bsdi"$UNAME_RELEASE"
+	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
 	exit ;;
     *:FreeBSD:*:*)
 	UNAME_PROCESSOR=`/usr/bin/uname -p`
-	case "$UNAME_PROCESSOR" in
+	case ${UNAME_PROCESSOR} in
 	    amd64)
-		UNAME_PROCESSOR=x86_64 ;;
-	    i386)
-		UNAME_PROCESSOR=i586 ;;
+		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    *)
+		echo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
 	esac
-	echo "$UNAME_PROCESSOR"-unknown-freebsd"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
 	exit ;;
     i*:CYGWIN*:*)
-	echo "$UNAME_MACHINE"-pc-cygwin
+	echo ${UNAME_MACHINE}-pc-cygwin
 	exit ;;
     *:MINGW64*:*)
-	echo "$UNAME_MACHINE"-pc-mingw64
+	echo ${UNAME_MACHINE}-pc-mingw64
 	exit ;;
     *:MINGW*:*)
-	echo "$UNAME_MACHINE"-pc-mingw32
+	echo ${UNAME_MACHINE}-pc-mingw32
 	exit ;;
     *:MSYS*:*)
-	echo "$UNAME_MACHINE"-pc-msys
+	echo ${UNAME_MACHINE}-pc-msys
+	exit ;;
+    i*:windows32*:*)
+	# uname -m includes "-pc" on this system.
+	echo ${UNAME_MACHINE}-mingw32
 	exit ;;
     i*:PW*:*)
-	echo "$UNAME_MACHINE"-pc-pw32
+	echo ${UNAME_MACHINE}-pc-pw32
 	exit ;;
     *:Interix*:*)
-	case "$UNAME_MACHINE" in
+	case ${UNAME_MACHINE} in
 	    x86)
-		echo i586-pc-interix"$UNAME_RELEASE"
+		echo i586-pc-interix${UNAME_RELEASE}
 		exit ;;
 	    authenticamd | genuineintel | EM64T)
-		echo x86_64-unknown-interix"$UNAME_RELEASE"
+		echo x86_64-unknown-interix${UNAME_RELEASE}
 		exit ;;
 	    IA64)
-		echo ia64-unknown-interix"$UNAME_RELEASE"
+		echo ia64-unknown-interix${UNAME_RELEASE}
 		exit ;;
 	esac ;;
+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
+	echo i${UNAME_MACHINE}-pc-mks
+	exit ;;
+    8664:Windows_NT:*)
+	echo x86_64-pc-mks
+	exit ;;
+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+	# UNAME_MACHINE based on the output of uname instead of i386?
+	echo i586-pc-interix
+	exit ;;
     i*:UWIN*:*)
-	echo "$UNAME_MACHINE"-pc-uwin
+	echo ${UNAME_MACHINE}-pc-uwin
 	exit ;;
     amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
 	echo x86_64-unknown-cygwin
 	exit ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin
+	exit ;;
     prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo "`echo "$UNAME_MACHINE"|sed -e 's,[-/].*$,,'`-unknown-$LIBC`echo "$UNAME_RELEASE"|sed -e 's,/.*$,,'`"
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo "$UNAME_MACHINE-unknown-`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`-$LIBC"
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
 	exit ;;
     i*86:Minix:*:*)
-	echo "$UNAME_MACHINE"-pc-minix
+	echo ${UNAME_MACHINE}-pc-minix
 	exit ;;
     aarch64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     aarch64_be:Linux:*:*)
 	UNAME_MACHINE=aarch64_be
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
@@ -916,63 +927,63 @@
 	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
 	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     arc:Linux:*:* | arceb:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     arm*:Linux:*:*)
-	eval "$set_cc_for_build"
+	eval $set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	else
 	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 		| grep -q __ARM_PCS_VFP
 	    then
-		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabi
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
 	    else
-		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabihf
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
 	    fi
 	fi
 	exit ;;
     avr32*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     cris:Linux:*:*)
-	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     crisv32:Linux:*:*)
-	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     e2k:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     frv:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     hexagon:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:Linux:*:*)
-	echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     ia64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     k1om:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m32r*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m68*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
-	eval "$set_cc_for_build"
-	sed 's/^	//' << EOF > "$dummy.c"
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
 	#undef CPU
 	#undef ${UNAME_MACHINE}
 	#undef ${UNAME_MACHINE}el
@@ -986,74 +997,70 @@
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU'`"
-	test "x$CPU" != x && { echo "$CPU-unknown-linux-$LIBC"; exit; }
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
     mips64el:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     openrisc*:Linux:*:*)
-	echo or1k-unknown-linux-"$LIBC"
+	echo or1k-unknown-linux-${LIBC}
 	exit ;;
     or32:Linux:*:* | or1k*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-"$LIBC"
+	echo sparc-unknown-linux-${LIBC}
 	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-"$LIBC"
+	echo hppa64-unknown-linux-${LIBC}
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-"$LIBC" ;;
-	  PA8*) echo hppa2.0-unknown-linux-"$LIBC" ;;
-	  *)    echo hppa-unknown-linux-"$LIBC" ;;
+	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
+	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
+	  *)    echo hppa-unknown-linux-${LIBC} ;;
 	esac
 	exit ;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-"$LIBC"
+	echo powerpc64-unknown-linux-${LIBC}
 	exit ;;
     ppc:Linux:*:*)
-	echo powerpc-unknown-linux-"$LIBC"
+	echo powerpc-unknown-linux-${LIBC}
 	exit ;;
     ppc64le:Linux:*:*)
-	echo powerpc64le-unknown-linux-"$LIBC"
+	echo powerpc64le-unknown-linux-${LIBC}
 	exit ;;
     ppcle:Linux:*:*)
-	echo powerpcle-unknown-linux-"$LIBC"
+	echo powerpcle-unknown-linux-${LIBC}
 	exit ;;
     riscv32:Linux:*:* | riscv64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo "$UNAME_MACHINE"-ibm-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
 	exit ;;
     sh64*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sh*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     tile*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     vax:Linux:*:*)
-	echo "$UNAME_MACHINE"-dec-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
 	exit ;;
     x86_64:Linux:*:*)
-	if objdump -f /bin/sh | grep -q elf32-x86-64; then
-	    echo "$UNAME_MACHINE"-pc-linux-"$LIBC"x32
-	else
-	    echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
-	fi
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     xtensa*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
@@ -1067,34 +1074,34 @@
 	# I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
 	# Use sysv4.2uw... so that sysv4* matches it.
-	echo "$UNAME_MACHINE"-pc-sysv4.2uw"$UNAME_VERSION"
+	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
 	exit ;;
     i*86:OS/2:*:*)
 	# If we were able to find `uname', then EMX Unix compatibility
 	# is probably installed.
-	echo "$UNAME_MACHINE"-pc-os2-emx
+	echo ${UNAME_MACHINE}-pc-os2-emx
 	exit ;;
     i*86:XTS-300:*:STOP)
-	echo "$UNAME_MACHINE"-unknown-stop
+	echo ${UNAME_MACHINE}-unknown-stop
 	exit ;;
     i*86:atheos:*:*)
-	echo "$UNAME_MACHINE"-unknown-atheos
+	echo ${UNAME_MACHINE}-unknown-atheos
 	exit ;;
     i*86:syllable:*:*)
-	echo "$UNAME_MACHINE"-pc-syllable
+	echo ${UNAME_MACHINE}-pc-syllable
 	exit ;;
     i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
-	echo i386-unknown-lynxos"$UNAME_RELEASE"
+	echo i386-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     i*86:*DOS:*:*)
-	echo "$UNAME_MACHINE"-pc-msdosdjgpp
+	echo ${UNAME_MACHINE}-pc-msdosdjgpp
 	exit ;;
-    i*86:*:4.*:*)
-	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
+	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo "$UNAME_MACHINE"-univel-sysv"$UNAME_REL"
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
 	else
-		echo "$UNAME_MACHINE"-pc-sysv"$UNAME_REL"
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
 	fi
 	exit ;;
     i*86:*:5:[678]*)
@@ -1104,12 +1111,12 @@
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
-	echo "$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}{$UNAME_VERSION}"
+	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
 	exit ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
-		echo "$UNAME_MACHINE"-pc-isc"$UNAME_REL"
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
 		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
@@ -1119,9 +1126,9 @@
 			&& UNAME_MACHINE=i686
 		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
-		echo "$UNAME_MACHINE"-pc-sco"$UNAME_REL"
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
 	else
-		echo "$UNAME_MACHINE"-pc-sysv32
+		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
 	exit ;;
     pc:*:*:*)
@@ -1141,9 +1148,9 @@
 	exit ;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
-	  echo i860-stardent-sysv"$UNAME_RELEASE" # Stardent Vistra i860-SVR4
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
-	  echo i860-unknown-sysv"$UNAME_RELEASE"  # Unknown i860-SVR4
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
 	fi
 	exit ;;
     mini*:CTIX:SYS*5:*)
@@ -1163,9 +1170,9 @@
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
+	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
+	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	  && { echo i486-ncr-sysv4; exit; } ;;
@@ -1174,28 +1181,28 @@
 	test -r /etc/.relid \
 	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	    && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
+	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; }
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
-	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
-	echo m68k-unknown-lynxos"$UNAME_RELEASE"
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
 	exit ;;
     TSUNAMI:LynxOS:2.*:*)
-	echo sparc-unknown-lynxos"$UNAME_RELEASE"
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     rs6000:LynxOS:2.*:*)
-	echo rs6000-unknown-lynxos"$UNAME_RELEASE"
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
-	echo powerpc-unknown-lynxos"$UNAME_RELEASE"
+	echo powerpc-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     SM[BE]S:UNIX_SV:*:*)
-	echo mips-dde-sysv"$UNAME_RELEASE"
+	echo mips-dde-sysv${UNAME_RELEASE}
 	exit ;;
     RM*:ReliantUNIX-*:*:*)
 	echo mips-sni-sysv4
@@ -1206,7 +1213,7 @@
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
-		echo "$UNAME_MACHINE"-sni-sysv4
+		echo ${UNAME_MACHINE}-sni-sysv4
 	else
 		echo ns32k-sni-sysv
 	fi
@@ -1226,23 +1233,23 @@
 	exit ;;
     i*86:VOS:*:*)
 	# From Paul.Green@stratus.com.
-	echo "$UNAME_MACHINE"-stratus-vos
+	echo ${UNAME_MACHINE}-stratus-vos
 	exit ;;
     *:VOS:*:*)
 	# From Paul.Green@stratus.com.
 	echo hppa1.1-stratus-vos
 	exit ;;
     mc68*:A/UX:*:*)
-	echo m68k-apple-aux"$UNAME_RELEASE"
+	echo m68k-apple-aux${UNAME_RELEASE}
 	exit ;;
     news*:NEWS-OS:6*:*)
 	echo mips-sony-newsos6
 	exit ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
-		echo mips-nec-sysv"$UNAME_RELEASE"
+		echo mips-nec-sysv${UNAME_RELEASE}
 	else
-		echo mips-unknown-sysv"$UNAME_RELEASE"
+		echo mips-unknown-sysv${UNAME_RELEASE}
 	fi
 	exit ;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
@@ -1261,56 +1268,49 @@
 	echo x86_64-unknown-haiku
 	exit ;;
     SX-4:SUPER-UX:*:*)
-	echo sx4-nec-superux"$UNAME_RELEASE"
+	echo sx4-nec-superux${UNAME_RELEASE}
 	exit ;;
     SX-5:SUPER-UX:*:*)
-	echo sx5-nec-superux"$UNAME_RELEASE"
+	echo sx5-nec-superux${UNAME_RELEASE}
 	exit ;;
     SX-6:SUPER-UX:*:*)
-	echo sx6-nec-superux"$UNAME_RELEASE"
+	echo sx6-nec-superux${UNAME_RELEASE}
 	exit ;;
     SX-7:SUPER-UX:*:*)
-	echo sx7-nec-superux"$UNAME_RELEASE"
+	echo sx7-nec-superux${UNAME_RELEASE}
 	exit ;;
     SX-8:SUPER-UX:*:*)
-	echo sx8-nec-superux"$UNAME_RELEASE"
+	echo sx8-nec-superux${UNAME_RELEASE}
 	exit ;;
     SX-8R:SUPER-UX:*:*)
-	echo sx8r-nec-superux"$UNAME_RELEASE"
+	echo sx8r-nec-superux${UNAME_RELEASE}
 	exit ;;
     SX-ACE:SUPER-UX:*:*)
-	echo sxace-nec-superux"$UNAME_RELEASE"
+	echo sxace-nec-superux${UNAME_RELEASE}
 	exit ;;
     Power*:Rhapsody:*:*)
-	echo powerpc-apple-rhapsody"$UNAME_RELEASE"
+	echo powerpc-apple-rhapsody${UNAME_RELEASE}
 	exit ;;
     *:Rhapsody:*:*)
-	echo "$UNAME_MACHINE"-apple-rhapsody"$UNAME_RELEASE"
+	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
 	exit ;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	eval "$set_cc_for_build"
+	eval $set_cc_for_build
 	if test "$UNAME_PROCESSOR" = unknown ; then
 	    UNAME_PROCESSOR=powerpc
 	fi
-	if test "`echo "$UNAME_RELEASE" | sed -e 's/\..*//'`" -le 10 ; then
+	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
 	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
 		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
-		       grep IS_64BIT_ARCH >/dev/null
+		    (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    grep IS_64BIT_ARCH >/dev/null
 		then
 		    case $UNAME_PROCESSOR in
 			i386) UNAME_PROCESSOR=x86_64 ;;
 			powerpc) UNAME_PROCESSOR=powerpc64 ;;
 		    esac
 		fi
-		# On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
-		if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
-		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
-		       grep IS_PPC >/dev/null
-		then
-		    UNAME_PROCESSOR=powerpc
-		fi
 	    fi
 	elif test "$UNAME_PROCESSOR" = i386 ; then
 	    # Avoid executing cc on OS X 10.9, as it ships with a stub
@@ -1321,7 +1321,7 @@
 	    # that Apple uses in portable devices.
 	    UNAME_PROCESSOR=x86_64
 	fi
-	echo "$UNAME_PROCESSOR"-apple-darwin"$UNAME_RELEASE"
+	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
@@ -1329,25 +1329,19 @@
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
-	echo "$UNAME_PROCESSOR"-"$UNAME_MACHINE"-nto-qnx"$UNAME_RELEASE"
+	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
 	exit ;;
     *:QNX:*:4*)
 	echo i386-pc-qnx
 	exit ;;
-    NEO-*:NONSTOP_KERNEL:*:*)
-	echo neo-tandem-nsk"$UNAME_RELEASE"
+    NEO-?:NONSTOP_KERNEL:*:*)
+	echo neo-tandem-nsk${UNAME_RELEASE}
 	exit ;;
     NSE-*:NONSTOP_KERNEL:*:*)
-	echo nse-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
-    NSR-*:NONSTOP_KERNEL:*:*)
-	echo nsr-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
-    NSV-*:NONSTOP_KERNEL:*:*)
-	echo nsv-tandem-nsk"$UNAME_RELEASE"
+	echo nse-tandem-nsk${UNAME_RELEASE}
 	exit ;;
-    NSX-*:NONSTOP_KERNEL:*:*)
-	echo nsx-tandem-nsk"$UNAME_RELEASE"
+    NSR-?:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk${UNAME_RELEASE}
 	exit ;;
     *:NonStop-UX:*:*)
 	echo mips-compaq-nonstopux
@@ -1356,7 +1350,7 @@
 	echo bs2000-siemens-sysv
 	exit ;;
     DS/*:UNIX_System_V:*:*)
-	echo "$UNAME_MACHINE"-"$UNAME_SYSTEM"-"$UNAME_RELEASE"
+	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
 	exit ;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
@@ -1367,7 +1361,7 @@
 	else
 	    UNAME_MACHINE="$cputype"
 	fi
-	echo "$UNAME_MACHINE"-unknown-plan9
+	echo ${UNAME_MACHINE}-unknown-plan9
 	exit ;;
     *:TOPS-10:*:*)
 	echo pdp10-unknown-tops10
@@ -1388,14 +1382,14 @@
 	echo pdp10-unknown-its
 	exit ;;
     SEI:*:*:SEIUX)
-	echo mips-sei-seiux"$UNAME_RELEASE"
+	echo mips-sei-seiux${UNAME_RELEASE}
 	exit ;;
     *:DragonFly:*:*)
-	echo "$UNAME_MACHINE"-unknown-dragonfly"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
+	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
 	exit ;;
     *:*VMS:*:*)
 	UNAME_MACHINE=`(uname -p) 2>/dev/null`
-	case "$UNAME_MACHINE" in
+	case "${UNAME_MACHINE}" in
 	    A*) echo alpha-dec-vms ; exit ;;
 	    I*) echo ia64-dec-vms ; exit ;;
 	    V*) echo vax-dec-vms ; exit ;;
@@ -1404,44 +1398,32 @@
 	echo i386-pc-xenix
 	exit ;;
     i*86:skyos:*:*)
-	echo "$UNAME_MACHINE"-pc-skyos"`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`"
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE} | sed -e 's/ .*$//'`
 	exit ;;
     i*86:rdos:*:*)
-	echo "$UNAME_MACHINE"-pc-rdos
+	echo ${UNAME_MACHINE}-pc-rdos
 	exit ;;
     i*86:AROS:*:*)
-	echo "$UNAME_MACHINE"-pc-aros
+	echo ${UNAME_MACHINE}-pc-aros
 	exit ;;
     x86_64:VMkernel:*:*)
-	echo "$UNAME_MACHINE"-unknown-esx
+	echo ${UNAME_MACHINE}-unknown-esx
 	exit ;;
     amd64:Isilon\ OneFS:*:*)
 	echo x86_64-unknown-onefs
 	exit ;;
 esac
 
-echo "$0: unable to guess system type" >&2
-
-case "$UNAME_MACHINE:$UNAME_SYSTEM" in
-    mips:Linux | mips64:Linux)
-	# If we got here on MIPS GNU/Linux, output extra information.
-	cat >&2 <<EOF
-
-NOTE: MIPS GNU/Linux systems require a C compiler to fully recognize
-the system type. Please install a C compiler and try again.
-EOF
-	;;
-esac
-
 cat >&2 <<EOF
+$0: unable to guess system type
 
 This script (version $timestamp), has failed to recognize the
-operating system you are using. If your script is old, overwrite *all*
-copies of config.guess and config.sub with the latest versions from:
+operating system you are using. If your script is old, overwrite
+config.guess and config.sub with the latest versions from:
 
-  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 and
-  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
 If $0 has already been updated, send the following data and any
 information you think might be pertinent to config-patches@gnu.org to
@@ -1464,16 +1446,16 @@
 /usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
 /usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
 
-UNAME_MACHINE = "$UNAME_MACHINE"
-UNAME_RELEASE = "$UNAME_RELEASE"
-UNAME_SYSTEM  = "$UNAME_SYSTEM"
-UNAME_VERSION = "$UNAME_VERSION"
+UNAME_MACHINE = ${UNAME_MACHINE}
+UNAME_RELEASE = ${UNAME_RELEASE}
+UNAME_SYSTEM  = ${UNAME_SYSTEM}
+UNAME_VERSION = ${UNAME_VERSION}
 EOF
 
 exit 1
 
 # Local variables:
-# eval: (add-hook 'write-file-functions 'time-stamp)
+# eval: (add-hook 'write-file-hooks 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
diff -rN --unified llvm-toolchain-7-7.0.1/polly/lib/External/isl/config.sub llvm-toolchain-7-7.0.1.patched/polly/lib/External/isl/config.sub
--- llvm-toolchain-7-7.0.1/polly/lib/External/isl/config.sub	2018-12-16 12:05:58.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/polly/lib/External/isl/config.sub	2019-05-19 11:21:51.795903000 +0000
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright 1992-2018 Free Software Foundation, Inc.
+#   Copyright 1992-2016 Free Software Foundation, Inc.
 
-timestamp='2018-02-22'
+timestamp='2016-11-04'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -15,7 +15,7 @@
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, see <https://www.gnu.org/licenses/>.
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
@@ -33,7 +33,7 @@
 # Otherwise, we print the canonical config type on stdout and succeed.
 
 # You can get the latest version of this script from:
-# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
@@ -57,7 +57,7 @@
 
 Canonicalize a configuration name.
 
-Options:
+Operation modes:
   -h, --help         print this help, then exit
   -t, --time-stamp   print date of last modification, then exit
   -v, --version      print version number, then exit
@@ -67,7 +67,7 @@
 version="\
 GNU config.sub ($timestamp)
 
-Copyright 1992-2018 Free Software Foundation, Inc.
+Copyright 1992-2016 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -94,7 +94,7 @@
 
     *local*)
        # First pass through any local machine types.
-       echo "$1"
+       echo $1
        exit ;;
 
     * )
@@ -112,7 +112,7 @@
 
 # Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
 # Here we must recognize all the valid KERNEL-OS combinations.
-maybe_os=`echo "$1" | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
   linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
@@ -120,16 +120,16 @@
   kopensolaris*-gnu* | cloudabi*-eabi* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
-    basic_machine=`echo "$1" | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
   android-linux)
     os=-linux-android
-    basic_machine=`echo "$1" | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`-unknown
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`-unknown
     ;;
   *)
-    basic_machine=`echo "$1" | sed 's/-[^-]*$//'`
-    if [ "$basic_machine" != "$1" ]
-    then os=`echo "$1" | sed 's/.*-/-/'`
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
     else os=; fi
     ;;
 esac
@@ -178,44 +178,44 @@
 		;;
 	-sco6)
 		os=-sco5v6
-		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco5)
 		os=-sco3.2v5
-		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco4)
 		os=-sco3.2v4
-		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2.[4-9]*)
 		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
-		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2v[4-9]*)
 		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco5v6*)
 		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco*)
 		os=-sco3.2v2
-		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-udk*)
-		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-isc)
 		os=-isc2.2
-		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-clix*)
 		basic_machine=clipper-intergraph
 		;;
 	-isc*)
-		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-lynx*178)
 		os=-lynxos178
@@ -227,7 +227,10 @@
 		os=-lynxos
 		;;
 	-ptx*)
-		basic_machine=`echo "$1" | sed -e 's/86-.*/86-sequent/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
 		;;
 	-psos*)
 		os=-psos
@@ -260,7 +263,7 @@
 	| fido | fr30 | frv | ft32 \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| hexagon \
-	| i370 | i860 | i960 | ia16 | ia64 \
+	| i370 | i860 | i960 | ia64 \
 	| ip2k | iq2000 \
 	| k1om \
 	| le32 | le64 \
@@ -296,7 +299,7 @@
 	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
 	| open8 | or1k | or1knd | or32 \
-	| pdp10 | pj | pjl \
+	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pru \
 	| pyramid \
@@ -312,7 +315,7 @@
 	| ubicom32 \
 	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
 	| visium \
-	| wasm32 \
+	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
 	| z8k | z80)
 		basic_machine=$basic_machine-unknown
@@ -333,7 +336,7 @@
 		basic_machine=$basic_machine-unknown
 		os=-none
 		;;
-	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65)
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
 		;;
 	ms1)
 		basic_machine=mt-unknown
@@ -362,7 +365,7 @@
 	  ;;
 	# Object if more than one company name word.
 	*-*-*)
-		echo Invalid configuration \`"$1"\': machine \`"$basic_machine"\' not recognized 1>&2
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
 		;;
 	# Recognize the basic CPU types with company name.
@@ -385,7 +388,7 @@
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| hexagon-* \
-	| i*86-* | i860-* | i960-* | ia16-* | ia64-* \
+	| i*86-* | i860-* | i960-* | ia64-* \
 	| ip2k-* | iq2000-* \
 	| k1om-* \
 	| le32-* | le64-* \
@@ -443,7 +446,6 @@
 	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
 	| vax-* \
 	| visium-* \
-	| wasm32-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* \
 	| xstormy16-* | xtensa*-* \
@@ -457,7 +459,7 @@
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
 	386bsd)
-		basic_machine=i386-pc
+		basic_machine=i386-unknown
 		os=-bsd
 		;;
 	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
@@ -491,7 +493,7 @@
 		basic_machine=x86_64-pc
 		;;
 	amd64-*)
-		basic_machine=x86_64-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	amdahl)
 		basic_machine=580-amdahl
@@ -536,7 +538,7 @@
 		os=-linux
 		;;
 	blackfin-*)
-		basic_machine=bfin-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
 		os=-linux
 		;;
 	bluegene*)
@@ -544,13 +546,13 @@
 		os=-cnk
 		;;
 	c54x-*)
-		basic_machine=tic54x-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=tic54x-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	c55x-*)
-		basic_machine=tic55x-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=tic55x-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	c6x-*)
-		basic_machine=tic6x-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=tic6x-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	c90)
 		basic_machine=c90-cray
@@ -639,7 +641,7 @@
 		basic_machine=rs6000-bull
 		os=-bosx
 		;;
-	dpx2*)
+	dpx2* | dpx2*-bull)
 		basic_machine=m68k-bull
 		os=-sysv3
 		;;
@@ -648,7 +650,7 @@
 		os=$os"spe"
 		;;
 	e500v[12]-*)
-		basic_machine=powerpc-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
 		os=$os"spe"
 		;;
 	ebmon29k)
@@ -740,6 +742,9 @@
 	hp9k8[0-9][0-9] | hp8[0-9][0-9])
 		basic_machine=hppa1.0-hp
 		;;
+	hppa-next)
+		os=-nextstep3
+		;;
 	hppaosf)
 		basic_machine=hppa1.1-hp
 		os=-osf
@@ -752,26 +757,26 @@
 		basic_machine=i370-ibm
 		;;
 	i*86v32)
-		basic_machine=`echo "$1" | sed -e 's/86.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv32
 		;;
 	i*86v4*)
-		basic_machine=`echo "$1" | sed -e 's/86.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv4
 		;;
 	i*86v)
-		basic_machine=`echo "$1" | sed -e 's/86.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv
 		;;
 	i*86sol2)
-		basic_machine=`echo "$1" | sed -e 's/86.*/86-pc/'`
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-solaris2
 		;;
 	i386mach)
 		basic_machine=i386-mach
 		os=-mach
 		;;
-	vsta)
+	i386-vsta | vsta)
 		basic_machine=i386-unknown
 		os=-vsta
 		;;
@@ -790,16 +795,19 @@
 		os=-sysv
 		;;
 	leon-*|leon[3-9]-*)
-		basic_machine=sparc-`echo "$basic_machine" | sed 's/-.*//'`
+		basic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`
 		;;
 	m68knommu)
 		basic_machine=m68k-unknown
 		os=-linux
 		;;
 	m68knommu-*)
-		basic_machine=m68k-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
 		os=-linux
 		;;
+	m88k-omron*)
+		basic_machine=m88k-omron
+		;;
 	magnum | m3230)
 		basic_machine=mips-mips
 		os=-sysv
@@ -831,10 +839,10 @@
 		os=-mint
 		;;
 	mips3*-*)
-		basic_machine=`echo "$basic_machine" | sed -e 's/mips3/mips64/'`
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
 	mips3*)
-		basic_machine=`echo "$basic_machine" | sed -e 's/mips3/mips64/'`-unknown
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
 	monitor)
 		basic_machine=m68k-rom68k
@@ -853,7 +861,7 @@
 		os=-msdos
 		;;
 	ms1-*)
-		basic_machine=`echo "$basic_machine" | sed -e 's/ms1-/mt-/'`
+		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
 		;;
 	msys)
 		basic_machine=i686-pc
@@ -895,7 +903,7 @@
 		basic_machine=v70-nec
 		os=-sysv
 		;;
-	next | m*-next)
+	next | m*-next )
 		basic_machine=m68k-next
 		case $os in
 		    -nextstep* )
@@ -940,12 +948,6 @@
 	nsr-tandem)
 		basic_machine=nsr-tandem
 		;;
-	nsv-tandem)
-		basic_machine=nsv-tandem
-		;;
-	nsx-tandem)
-		basic_machine=nsx-tandem
-		;;
 	op50n-* | op60c-*)
 		basic_machine=hppa1.1-oki
 		os=-proelf
@@ -978,7 +980,7 @@
 		os=-linux
 		;;
 	parisc-*)
-		basic_machine=hppa-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
 		os=-linux
 		;;
 	pbd)
@@ -994,7 +996,7 @@
 		basic_machine=i386-pc
 		;;
 	pc98-*)
-		basic_machine=i386-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentium | p5 | k5 | k6 | nexgen | viac3)
 		basic_machine=i586-pc
@@ -1009,16 +1011,16 @@
 		basic_machine=i786-pc
 		;;
 	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
-		basic_machine=i586-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumpro-* | p6-* | 6x86-* | athlon-*)
-		basic_machine=i686-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
-		basic_machine=i686-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentium4-*)
-		basic_machine=i786-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pn)
 		basic_machine=pn-gould
@@ -1028,23 +1030,23 @@
 	ppc | ppcbe)	basic_machine=powerpc-unknown
 		;;
 	ppc-* | ppcbe-*)
-		basic_machine=powerpc-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ppcle | powerpclittle)
 		basic_machine=powerpcle-unknown
 		;;
 	ppcle-* | powerpclittle-*)
-		basic_machine=powerpcle-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ppc64)	basic_machine=powerpc64-unknown
 		;;
-	ppc64-*) basic_machine=powerpc64-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ppc64le | powerpc64little)
 		basic_machine=powerpc64le-unknown
 		;;
 	ppc64le-* | powerpc64little-*)
-		basic_machine=powerpc64le-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ps2)
 		basic_machine=i386-ibm
@@ -1098,10 +1100,17 @@
 	sequent)
 		basic_machine=i386-sequent
 		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
 	sh5el)
 		basic_machine=sh5le-unknown
 		;;
-	simso-wrs)
+	sh64)
+		basic_machine=sh64-unknown
+		;;
+	sparclite-wrs | simso-wrs)
 		basic_machine=sparclite-wrs
 		os=-vxworks
 		;;
@@ -1120,7 +1129,7 @@
 		os=-sysv4
 		;;
 	strongarm-* | thumb-*)
-		basic_machine=arm-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		basic_machine=arm-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	sun2)
 		basic_machine=m68000-sun
@@ -1242,9 +1251,6 @@
 		basic_machine=hppa1.1-winbond
 		os=-proelf
 		;;
-	x64)
-		basic_machine=x86_64-pc
-		;;
 	xbox)
 		basic_machine=i686-pc
 		os=-mingw32
@@ -1253,12 +1259,20 @@
 		basic_machine=xps100-honeywell
 		;;
 	xscale-* | xscalee[bl]-*)
-		basic_machine=`echo "$basic_machine" | sed 's/^xscale/arm/'`
+		basic_machine=`echo $basic_machine | sed 's/^xscale/arm/'`
 		;;
 	ymp)
 		basic_machine=ymp-cray
 		os=-unicos
 		;;
+	z8k-*-coff)
+		basic_machine=z8k-unknown
+		os=-sim
+		;;
+	z80-*-coff)
+		basic_machine=z80-unknown
+		os=-sim
+		;;
 	none)
 		basic_machine=none-none
 		os=-none
@@ -1287,6 +1301,10 @@
 	vax)
 		basic_machine=vax-dec
 		;;
+	pdp10)
+		# there are many clones, so DEC is not a safe bet
+		basic_machine=pdp10-unknown
+		;;
 	pdp11)
 		basic_machine=pdp11-dec
 		;;
@@ -1296,6 +1314,9 @@
 	sh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)
 		basic_machine=sh-unknown
 		;;
+	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
+		basic_machine=sparc-sun
+		;;
 	cydra)
 		basic_machine=cydra-cydrome
 		;;
@@ -1315,7 +1336,7 @@
 		# Make sure to match an already-canonicalized machine name.
 		;;
 	*)
-		echo Invalid configuration \`"$1"\': machine \`"$basic_machine"\' not recognized 1>&2
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
 		;;
 esac
@@ -1323,10 +1344,10 @@
 # Here we canonicalize certain aliases for manufacturers.
 case $basic_machine in
 	*-digital*)
-		basic_machine=`echo "$basic_machine" | sed 's/digital.*/dec/'`
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
 		;;
 	*-commodore*)
-		basic_machine=`echo "$basic_machine" | sed 's/commodore.*/cbm/'`
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
 		;;
 	*)
 		;;
@@ -1337,8 +1358,8 @@
 if [ x"$os" != x"" ]
 then
 case $os in
-	# First match some system type aliases that might get confused
-	# with valid system types.
+	# First match some system type aliases
+	# that might get confused with valid system types.
 	# -solaris* is a basic system type, with this one exception.
 	-auroraux)
 		os=-auroraux
@@ -1349,19 +1370,18 @@
 	-solaris)
 		os=-solaris2
 		;;
+	-svr4*)
+		os=-sysv4
+		;;
 	-unixware*)
 		os=-sysv4.2uw
 		;;
 	-gnu/linux*)
 		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
 		;;
-	# es1800 is here to avoid being matched by es* (a different OS)
-	-es1800*)
-		os=-ose
-		;;
-	# Now accept the basic system types.
+	# First accept the basic system types.
 	# The portable systems comes first.
-	# Each alternative MUST end in a * to match a version number.
+	# Each alternative MUST END IN A *, to match a version number.
 	# -sysv* is not here because it comes later, after sysvr4.
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
 	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
@@ -1371,26 +1391,25 @@
 	      | -aos* | -aros* | -cloudabi* | -sortix* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -knetbsd* | -mirbsd* | -netbsd* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
 	      | -bitrig* | -openbsd* | -solidbsd* | -libertybsd* \
 	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
 	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -chorusos* | -chorusrdb* | -cegcc* | -glidix* \
+	      | -chorusos* | -chorusrdb* | -cegcc* \
 	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
 	      | -midipix* | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
 	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
 	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
-	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* \
+	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
-	      | -morphos* | -superux* | -rtmk* | -windiss* \
+	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
 	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* \
-	      | -onefs* | -tirtos* | -phoenix* | -fuchsia* | -redox* | -bme* \
-	      | -midnightbsd*)
+	      | -onefs* | -tirtos* | -phoenix* | -fuchsia*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1407,12 +1426,12 @@
 	-nto*)
 		os=`echo $os | sed -e 's|nto|nto-qnx|'`
 		;;
-	-sim | -xray | -os68k* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* \
+	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
 	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
 		;;
 	-mac*)
-		os=`echo "$os" | sed -e 's|mac|macos|'`
+		os=`echo $os | sed -e 's|mac|macos|'`
 		;;
 	-linux-dietlibc)
 		os=-linux-dietlibc
@@ -1421,10 +1440,10 @@
 		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
 	-sunos5*)
-		os=`echo "$os" | sed -e 's|sunos5|solaris2|'`
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
 		;;
 	-sunos6*)
-		os=`echo "$os" | sed -e 's|sunos6|solaris3|'`
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
 		;;
 	-opened*)
 		os=-openedition
@@ -1435,6 +1454,12 @@
 	-wince*)
 		os=-wince
 		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
 	-utek*)
 		os=-bsd
 		;;
@@ -1459,7 +1484,7 @@
 	-nova*)
 		os=-rtmk-nova
 		;;
-	-ns2)
+	-ns2 )
 		os=-nextstep2
 		;;
 	-nsk*)
@@ -1481,7 +1506,7 @@
 	-oss*)
 		os=-sysv3
 		;;
-	-svr4*)
+	-svr4)
 		os=-sysv4
 		;;
 	-svr3)
@@ -1496,28 +1521,24 @@
 	-ose*)
 		os=-ose
 		;;
+	-es1800*)
+		os=-ose
+		;;
+	-xenix)
+		os=-xenix
+		;;
 	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
 		os=-mint
 		;;
+	-aros*)
+		os=-aros
+		;;
 	-zvmoe)
 		os=-zvmoe
 		;;
 	-dicos*)
 		os=-dicos
 		;;
-	-pikeos*)
-		# Until real need of OS specific support for
-		# particular features comes up, bare metal
-		# configurations are quite functional.
-		case $basic_machine in
-		    arm*)
-			os=-eabi
-			;;
-		    *)
-			os=-elf
-			;;
-		esac
-		;;
 	-nacl*)
 		;;
 	-ios)
@@ -1527,7 +1548,7 @@
 	*)
 		# Get rid of the `-' at the beginning of $os.
 		os=`echo $os | sed 's/[^-]*-//'`
-		echo Invalid configuration \`"$1"\': system \`"$os"\' not recognized 1>&2
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
 		exit 1
 		;;
 esac
@@ -1617,12 +1638,12 @@
 	sparc-* | *-sun)
 		os=-sunos4.1.1
 		;;
-	pru-*)
-		os=-elf
-		;;
 	*-be)
 		os=-beos
 		;;
+	*-haiku)
+		os=-haiku
+		;;
 	*-ibm)
 		os=-aix
 		;;
@@ -1662,7 +1683,7 @@
 	m88k-omron*)
 		os=-luna
 		;;
-	*-next)
+	*-next )
 		os=-nextstep
 		;;
 	*-sequent)
@@ -1677,6 +1698,9 @@
 	i370-*)
 		os=-mvs
 		;;
+	*-next)
+		os=-nextstep3
+		;;
 	*-gould)
 		os=-sysv
 		;;
@@ -1786,15 +1810,15 @@
 				vendor=stratus
 				;;
 		esac
-		basic_machine=`echo "$basic_machine" | sed "s/unknown/$vendor/"`
+		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
 		;;
 esac
 
-echo "$basic_machine$os"
+echo $basic_machine$os
 exit
 
 # Local variables:
-# eval: (add-hook 'write-file-functions 'time-stamp)
+# eval: (add-hook 'write-file-hooks 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
diff -rN --unified llvm-toolchain-7-7.0.1/polly/lib/External/ppcg/config.guess llvm-toolchain-7-7.0.1.patched/polly/lib/External/ppcg/config.guess
--- llvm-toolchain-7-7.0.1/polly/lib/External/ppcg/config.guess	2018-12-16 12:05:58.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/polly/lib/External/ppcg/config.guess	2019-05-19 11:21:51.795903000 +0000
@@ -1,14 +1,12 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-#   2011, 2012 Free Software Foundation, Inc.
+#   Copyright 1992-2016 Free Software Foundation, Inc.
 
-timestamp='2012-02-10'
+timestamp='2016-10-02'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -22,19 +20,17 @@
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner.  Please send patches (context
-# diff format) to <config-patches@gnu.org> and include a ChangeLog
-# entry.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 #
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+#
+# Please send patches to <config-patches@gnu.org>.
+
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
@@ -54,9 +50,7 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-Free Software Foundation, Inc.
+Copyright 1992-2016 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -138,6 +132,27 @@
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+case "${UNAME_SYSTEM}" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	eval $set_cc_for_build
+	cat <<-EOF > $dummy.c
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
+	;;
+esac
+
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
@@ -153,19 +168,29 @@
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
 	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    /sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || \
+	    echo unknown)`
 	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
+	    earmv*)
+		arch=`echo ${UNAME_MACHINE_ARCH} | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo ${UNAME_MACHINE_ARCH} | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
+		;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
+	# to ELF recently (or will in the future) and ABI.
 	case "${UNAME_MACHINE_ARCH}" in
+	    earm*)
+		os=netbsdelf
+		;;
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
@@ -182,6 +207,13 @@
 		os=netbsd
 		;;
 	esac
+	# Determine ABI tags.
+	case "${UNAME_MACHINE_ARCH}" in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo ${UNAME_MACHINE_ARCH} | sed -e "$expr"`
+		;;
+	esac
 	# The OS release
 	# Debian GNU/NetBSD machines have a different userland, and
 	# thus, need a distinct triplet. However, they do not need
@@ -192,18 +224,26 @@
 		release='-gnu'
 		;;
 	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		release=`echo ${UNAME_RELEASE} | sed -e 's/[-_].*//' | cut -d. -f1,2`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
+	echo "${machine}-${os}${release}${abi}"
+	exit ;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}
 	exit ;;
     *:OpenBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
 	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
 	exit ;;
+    *:LibertyBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-libertybsd${UNAME_RELEASE}
+	exit ;;
     *:ekkoBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
 	exit ;;
@@ -216,6 +256,9 @@
     *:MirBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
 	exit ;;
+    *:Sortix:*:*)
+	echo ${UNAME_MACHINE}-unknown-sortix
+	exit ;;
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
@@ -232,42 +275,42 @@
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV4.5 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "LCA4 (21066/21068)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV5 (21164)")
-		UNAME_MACHINE="alphaev5" ;;
+		UNAME_MACHINE=alphaev5 ;;
 	    "EV5.6 (21164A)")
-		UNAME_MACHINE="alphaev56" ;;
+		UNAME_MACHINE=alphaev56 ;;
 	    "EV5.6 (21164PC)")
-		UNAME_MACHINE="alphapca56" ;;
+		UNAME_MACHINE=alphapca56 ;;
 	    "EV5.7 (21164PC)")
-		UNAME_MACHINE="alphapca57" ;;
+		UNAME_MACHINE=alphapca57 ;;
 	    "EV6 (21264)")
-		UNAME_MACHINE="alphaev6" ;;
+		UNAME_MACHINE=alphaev6 ;;
 	    "EV6.7 (21264A)")
-		UNAME_MACHINE="alphaev67" ;;
+		UNAME_MACHINE=alphaev67 ;;
 	    "EV6.8CB (21264C)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8AL (21264B)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8CX (21264D)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.9A (21264/EV69A)")
-		UNAME_MACHINE="alphaev69" ;;
+		UNAME_MACHINE=alphaev69 ;;
 	    "EV7 (21364)")
-		UNAME_MACHINE="alphaev7" ;;
+		UNAME_MACHINE=alphaev7 ;;
 	    "EV7.9 (21364A)")
-		UNAME_MACHINE="alphaev79" ;;
+		UNAME_MACHINE=alphaev79 ;;
 	esac
 	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
 	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
 	exitcode=$?
 	trap '' 0
@@ -302,7 +345,7 @@
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
 	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
 	echo arm-unknown-riscos
 	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
@@ -340,16 +383,16 @@
 	exit ;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
 	eval $set_cc_for_build
-	SUN_ARCH="i386"
+	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
 	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
 	    then
-		SUN_ARCH="x86_64"
+		SUN_ARCH=x86_64
 	    fi
 	fi
 	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
@@ -374,7 +417,7 @@
 	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	test "x${UNAME_RELEASE}" = x && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
 		echo m68k-sun-sunos${UNAME_RELEASE}
@@ -560,8 +603,9 @@
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if [ -x /usr/bin/lslpp ] ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
@@ -598,13 +642,13 @@
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
 		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
 		    case "${sc_cpu_version}" in
-		      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-		      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
 		      532)                      # CPU_PA_RISC2_0
 			case "${sc_kernel_bits}" in
-			  32) HP_ARCH="hppa2.0n" ;;
-			  64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+			  32) HP_ARCH=hppa2.0n ;;
+			  64) HP_ARCH=hppa2.0w ;;
+			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
 			esac ;;
 		    esac
 		fi
@@ -643,11 +687,11 @@
 		    exit (0);
 		}
 EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    (CCOPTS="" $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ ${HP_ARCH} = "hppa2.0w" ]
+	if [ ${HP_ARCH} = hppa2.0w ]
 	then
 	    eval $set_cc_for_build
 
@@ -660,12 +704,12 @@
 	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
 	    # => hppa64-hp-hpux11.23
 
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
 		grep -q __LP64__
 	    then
-		HP_ARCH="hppa2.0w"
+		HP_ARCH=hppa2.0w
 	    else
-		HP_ARCH="hppa64"
+		HP_ARCH=hppa64
 	    fi
 	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
@@ -770,14 +814,14 @@
 	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
 	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
 	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     5000:UNIX_System_V:4.*:*)
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
 	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
@@ -801,10 +845,13 @@
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
 	exit ;;
+    *:MINGW64*:*)
+	echo ${UNAME_MACHINE}-pc-mingw64
+	exit ;;
     *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit ;;
-    i*:MSYS*:*)
+    *:MSYS*:*)
 	echo ${UNAME_MACHINE}-pc-msys
 	exit ;;
     i*:windows32*:*)
@@ -852,21 +899,21 @@
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
 	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
 	exit ;;
     aarch64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     aarch64_be:Linux:*:*)
 	UNAME_MACHINE=aarch64_be
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
@@ -879,59 +926,60 @@
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
 	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     arm*:Linux:*:*)
 	eval $set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	else
 	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 		| grep -q __ARM_PCS_VFP
 	    then
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
 	    else
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabihf
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
 	    fi
 	fi
 	exit ;;
     avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     cris:Linux:*:*)
-	echo ${UNAME_MACHINE}-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     crisv32:Linux:*:*)
-	echo ${UNAME_MACHINE}-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
+	exit ;;
+    e2k:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     frv:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     hexagon:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:Linux:*:*)
-	LIBC=gnu
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
-	echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    k1om:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
 	eval $set_cc_for_build
@@ -950,54 +998,69 @@
 	#endif
 EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
-    or32:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+    mips64el:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-${LIBC}
+	exit ;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-gnu
+	echo sparc-unknown-linux-${LIBC}
 	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
+	echo hppa64-unknown-linux-${LIBC}
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
+	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
+	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
+	  *)    echo hppa-unknown-linux-${LIBC} ;;
 	esac
 	exit ;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
+	echo powerpc64-unknown-linux-${LIBC}
 	exit ;;
     ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
+	echo powerpc-unknown-linux-${LIBC}
+	exit ;;
+    ppc64le:Linux:*:*)
+	echo powerpc64le-unknown-linux-${LIBC}
+	exit ;;
+    ppcle:Linux:*:*)
+	echo powerpcle-unknown-linux-${LIBC}
+	exit ;;
+    riscv32:Linux:*:* | riscv64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
+	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
 	exit ;;
     sh64*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     tile*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-gnu
+	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
 	exit ;;
     x86_64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     xtensa*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
@@ -1073,7 +1136,7 @@
 	# uname -m prints for DJGPP always 'pc', but it prints nothing about
 	# the processor, so we play safe by assuming i586.
 	# Note: whatever this is, it MUST be the same as what config.sub
-	# prints for the "djgpp" host, or else GDB configury will decide that
+	# prints for the "djgpp" host, or else GDB configure will decide that
 	# this is a cross-build.
 	echo i586-pc-msdosdjgpp
 	exit ;;
@@ -1201,6 +1264,9 @@
     BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
 	echo i586-pc-haiku
 	exit ;;
+    x86_64:Haiku:*:*)
+	echo x86_64-unknown-haiku
+	exit ;;
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
 	exit ;;
@@ -1219,6 +1285,9 @@
     SX-8R:SUPER-UX:*:*)
 	echo sx8r-nec-superux${UNAME_RELEASE}
 	exit ;;
+    SX-ACE:SUPER-UX:*:*)
+	echo sxace-nec-superux${UNAME_RELEASE}
+	exit ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
 	exit ;;
@@ -1227,24 +1296,36 @@
 	exit ;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    i386)
-		eval $set_cc_for_build
-		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		      grep IS_64BIT_ARCH >/dev/null
-		  then
-		      UNAME_PROCESSOR="x86_64"
-		  fi
-		fi ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
+	eval $set_cc_for_build
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
+	fi
+	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		    (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
+	fi
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
-	if test "$UNAME_PROCESSOR" = "x86"; then
+	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
@@ -1256,7 +1337,7 @@
     NEO-?:NONSTOP_KERNEL:*:*)
 	echo neo-tandem-nsk${UNAME_RELEASE}
 	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
+    NSE-*:NONSTOP_KERNEL:*:*)
 	echo nse-tandem-nsk${UNAME_RELEASE}
 	exit ;;
     NSR-?:NONSTOP_KERNEL:*:*)
@@ -1275,7 +1356,7 @@
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
-	if test "$cputype" = "386"; then
+	if test "$cputype" = 386; then
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
@@ -1317,7 +1398,7 @@
 	echo i386-pc-xenix
 	exit ;;
     i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE} | sed -e 's/ .*$//'`
 	exit ;;
     i*86:rdos:*:*)
 	echo ${UNAME_MACHINE}-pc-rdos
@@ -1328,174 +1409,25 @@
     x86_64:VMkernel:*:*)
 	echo ${UNAME_MACHINE}-unknown-esx
 	exit ;;
-esac
-
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-	"4"
-#else
-	""
-#endif
-	); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
-	{ echo "$SYSTEM_NAME"; exit; }
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
+    amd64:Isilon\ OneFS:*:*)
+	echo x86_64-unknown-onefs
 	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit ;;
-    c34*)
-	echo c34-convex-bsd
-	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
+esac
 
 cat >&2 <<EOF
 $0: unable to guess system type
 
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
+This script (version $timestamp), has failed to recognize the
+operating system you are using. If your script is old, overwrite
+config.guess and config.sub with the latest versions from:
 
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 and
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches@gnu.org> in order to provide the needed
-information to handle your system.
+If $0 has already been updated, send the following data and any
+information you think might be pertinent to config-patches@gnu.org to
+provide the necessary information to handle your system.
 
 config.guess timestamp = $timestamp
 
diff -rN --unified llvm-toolchain-7-7.0.1/polly/lib/External/ppcg/config.sub llvm-toolchain-7-7.0.1.patched/polly/lib/External/ppcg/config.sub
--- llvm-toolchain-7-7.0.1/polly/lib/External/ppcg/config.sub	2018-12-16 12:05:58.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/polly/lib/External/ppcg/config.sub	2019-05-19 11:21:51.795903000 +0000
@@ -1,24 +1,18 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-#   2011, 2012 Free Software Foundation, Inc.
-
-timestamp='2012-04-18'
-
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+#   Copyright 1992-2016 Free Software Foundation, Inc.
+
+timestamp='2016-11-04'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, see <http://www.gnu.org/licenses/>.
@@ -26,11 +20,12 @@
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 
 
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted GNU ChangeLog entry.
+# Please send patches to <config-patches@gnu.org>.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
@@ -38,7 +33,7 @@
 # Otherwise, we print the canonical config type on stdout and succeed.
 
 # You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
@@ -58,8 +53,7 @@
 me=`echo "$0" | sed -e 's,.*/,,'`
 
 usage="\
-Usage: $0 [OPTION] CPU-MFR-OPSYS
-       $0 [OPTION] ALIAS
+Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS
 
 Canonicalize a configuration name.
 
@@ -73,9 +67,7 @@
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-Free Software Foundation, Inc.
+Copyright 1992-2016 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -123,9 +115,9 @@
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
-  linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
-  knetbsd*-gnu* | netbsd*-gnu* | \
-  kopensolaris*-gnu* | \
+  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \
+  kopensolaris*-gnu* | cloudabi*-eabi* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
@@ -156,7 +148,7 @@
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray | -microblaze)
+	-apple | -axis | -knuth | -cray | -microblaze*)
 		os=
 		basic_machine=$1
 		;;
@@ -259,21 +251,25 @@
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
 	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
-        | be32 | be64 \
+	| arc | arceb \
+	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
+	| avr | avr32 \
+	| ba \
+	| be32 | be64 \
 	| bfin \
-	| c4x | clipper \
+	| c4x | c8051 | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| epiphany \
-	| fido | fr30 | frv \
+	| e2k | epiphany \
+	| fido | fr30 | frv | ft32 \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| hexagon \
 	| i370 | i860 | i960 | ia64 \
 	| ip2k | iq2000 \
+	| k1om \
 	| le32 | le64 \
 	| lm32 \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
-	| maxq | mb | microblaze | mcore | mep | metag \
+	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
@@ -287,26 +283,30 @@
 	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa32r6 | mipsisa32r6el \
 	| mipsisa64 | mipsisa64el \
 	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64r6 | mipsisa64r6el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipsr5900 | mipsr5900el \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
 	| moxie \
 	| mt \
 	| msp430 \
 	| nds32 | nds32le | nds32be \
-	| nios | nios2 \
+	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
-	| open8 \
-	| or32 \
+	| open8 | or1k | or1knd | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
+	| pru \
 	| pyramid \
+	| riscv32 | riscv64 \
 	| rl78 | rx \
 	| score \
-	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
+	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[234]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
 	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
@@ -314,6 +314,7 @@
 	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
 	| ubicom32 \
 	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| visium \
 	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
 	| z8k | z80)
@@ -328,7 +329,10 @@
 	c6x)
 		basic_machine=tic6x-unknown
 		;;
-	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | picochip)
+	leon|leon[3-9])
+		basic_machine=sparc-$basic_machine
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
 		basic_machine=$basic_machine-unknown
 		os=-none
 		;;
@@ -370,26 +374,29 @@
 	| aarch64-* | aarch64_be-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
+	| ba-* \
 	| be32-* | be64-* \
 	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* \
-	| clipper-* | craynv-* | cydra-* \
+	| c8051-* | clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
-	| elxsi-* \
+	| e2k-* | elxsi-* \
 	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| hexagon-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
 	| ip2k-* | iq2000-* \
+	| k1om-* \
 	| le32-* | le64-* \
 	| lm32-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* | microblaze-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| microblaze-* | microblazeel-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
@@ -403,28 +410,34 @@
 	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa32r6-* | mipsisa32r6el-* \
 	| mipsisa64-* | mipsisa64el-* \
 	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64r6-* | mipsisa64r6el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipsr5900-* | mipsr5900el-* \
 	| mipstx39-* | mipstx39el-* \
 	| mmix-* \
 	| mt-* \
 	| msp430-* \
 	| nds32-* | nds32le-* | nds32be-* \
-	| nios-* | nios2-* \
+	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
 	| open8-* \
+	| or1k*-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
+	| pru-* \
 	| pyramid-* \
+	| riscv32-* | riscv64-* \
 	| rl78-* | romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
 	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx*-* \
 	| tahoe-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tile*-* \
@@ -432,6 +445,7 @@
 	| ubicom32-* \
 	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
 	| vax-* \
+	| visium-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* \
 	| xstormy16-* | xtensa*-* \
@@ -508,6 +522,9 @@
 		basic_machine=i386-pc
 		os=-aros
 		;;
+	asmjs)
+		basic_machine=asmjs-unknown
+		;;
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
@@ -628,6 +645,14 @@
 		basic_machine=m68k-bull
 		os=-sysv3
 		;;
+	e500v[12])
+		basic_machine=powerpc-unknown
+		os=$os"spe"
+		;;
+	e500v[12]-*)
+		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=$os"spe"
+		;;
 	ebmon29k)
 		basic_machine=a29k-amd
 		os=-ebmon
@@ -769,6 +794,9 @@
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	leon-*|leon[3-9]-*)
+		basic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`
+		;;
 	m68knommu)
 		basic_machine=m68k-unknown
 		os=-linux
@@ -788,11 +816,15 @@
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
-	microblaze)
+	microblaze*)
 		basic_machine=microblaze-xilinx
 		;;
+	mingw64)
+		basic_machine=x86_64-pc
+		os=-mingw64
+		;;
 	mingw32)
-		basic_machine=i386-pc
+		basic_machine=i686-pc
 		os=-mingw32
 		;;
 	mingw32ce)
@@ -820,6 +852,10 @@
 		basic_machine=powerpc-unknown
 		os=-morphos
 		;;
+	moxiebox)
+		basic_machine=moxie-unknown
+		os=-moxiebox
+		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
@@ -828,7 +864,7 @@
 		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
 		;;
 	msys)
-		basic_machine=i386-pc
+		basic_machine=i686-pc
 		os=-msys
 		;;
 	mvs)
@@ -996,7 +1032,7 @@
 	ppc-* | ppcbe-*)
 		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	ppcle | powerpclittle | ppc-le | powerpc-little)
+	ppcle | powerpclittle)
 		basic_machine=powerpcle-unknown
 		;;
 	ppcle-* | powerpclittle-*)
@@ -1006,7 +1042,7 @@
 		;;
 	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+	ppc64le | powerpc64little)
 		basic_machine=powerpc64le-unknown
 		;;
 	ppc64le-* | powerpc64little-*)
@@ -1019,7 +1055,11 @@
 		basic_machine=i586-unknown
 		os=-pw32
 		;;
-	rdos)
+	rdos | rdos64)
+		basic_machine=x86_64-pc
+		os=-rdos
+		;;
+	rdos32)
 		basic_machine=i386-pc
 		os=-rdos
 		;;
@@ -1346,29 +1386,30 @@
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
 	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
-	      | -sym* | -kopensolaris* \
+	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* | -aros* \
+	      | -aos* | -aros* | -cloudabi* | -sortix* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
-	      | -openbsd* | -solidbsd* \
+	      | -bitrig* | -openbsd* | -solidbsd* | -libertybsd* \
 	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
 	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
 	      | -chorusos* | -chorusrdb* | -cegcc* \
 	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -linux-android* \
-	      | -linux-newlib* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -midipix* | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
+	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* \
+	      | -onefs* | -tirtos* | -phoenix* | -fuchsia*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1492,9 +1533,6 @@
 	-aros*)
 		os=-aros
 		;;
-	-kaos*)
-		os=-kaos
-		;;
 	-zvmoe)
 		os=-zvmoe
 		;;
@@ -1503,6 +1541,8 @@
 		;;
 	-nacl*)
 		;;
+	-ios)
+		;;
 	-none)
 		;;
 	*)
@@ -1543,6 +1583,9 @@
 	c4x-* | tic4x-*)
 		os=-coff
 		;;
+	c8051-*)
+		os=-elf
+		;;
 	hexagon-*)
 		os=-elf
 		;;
diff -rN --unified llvm-toolchain-7-7.0.1/test/Assembler/call-nonzero-program-addrspace-2.ll llvm-toolchain-7-7.0.1.patched/test/Assembler/call-nonzero-program-addrspace-2.ll
--- llvm-toolchain-7-7.0.1/test/Assembler/call-nonzero-program-addrspace-2.ll	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/Assembler/call-nonzero-program-addrspace-2.ll	2019-05-19 11:21:52.895903000 +0000
@@ -1,11 +1,22 @@
-; RUN: llvm-as %s -data-layout=P200 -o /dev/null
 ; RUN: not llvm-as %s -o /dev/null 2>&1 | FileCheck %s
+; RUN: llvm-as %s -data-layout=P42 -o - | llvm-dis - -o - | FileCheck %s -check-prefix PROGAS42
 
 ; Check that numbered variables in a nonzero program address space 200 can be used in a call instruction
 
-define i8 @test_unnamed(i8(i32)*, i8(i32) addrspace(200)*) {
-  %first = call i8 %0(i32 0) ; this is fine
-  %second = call i8 %1(i32 0) ; this is also fine if it's the program AS
-  ; CHECK: call-nonzero-program-addrspace-2.ll:[[@LINE-1]]:21: error: '%1' defined with type 'i8 (i32) addrspace(200)*'
+define i8 @test_unnamed(i8(i32)*, i8(i32) addrspace(42)*) {
+  ; Calls with explicit address spaces are fine:
+  call addrspace(0) i8 %0(i32 0)
+  call addrspace(42) i8 %1(i32 0)
+  ; this call is fine if the program address space is 42
+  call i8 %1(i32 0)
+  ; CHECK: call-nonzero-program-addrspace-2.ll:[[@LINE-1]]:11: error: '%1' defined with type 'i8 (i32) addrspace(42)*' but expected 'i8 (i32)*'
   ret i8 0
 }
+
+; PROGAS42:       target datalayout = "P42"
+; PROGAS42:       define i8 @test_unnamed(i8 (i32)*, i8 (i32) addrspace(42)*) addrspace(42) {
+; PROGAS42-NEXT:    %3 = call addrspace(0) i8 %0(i32 0)
+; PROGAS42-NEXT:    %4 = call addrspace(42) i8 %1(i32 0)
+; PROGAS42-NEXT:    %5 = call addrspace(42) i8 %1(i32 0)
+; PROGAS42-NEXT:    ret i8 0
+; PROGAS42-NEXT:  }
diff -rN --unified llvm-toolchain-7-7.0.1/test/Assembler/call-nonzero-program-addrspace.ll llvm-toolchain-7-7.0.1.patched/test/Assembler/call-nonzero-program-addrspace.ll
--- llvm-toolchain-7-7.0.1/test/Assembler/call-nonzero-program-addrspace.ll	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/Assembler/call-nonzero-program-addrspace.ll	2019-05-19 11:21:52.895903000 +0000
@@ -1,13 +1,23 @@
-; RUN: llvm-as %s -data-layout=P200 -o /dev/null
 ; RUN: not llvm-as %s -o /dev/null 2>&1 | FileCheck %s
+; RUN: llvm-as %s -data-layout=P42 -o - | llvm-dis - -o - | FileCheck %s -check-prefix PROGAS42
 
-; Check that variables in a nonzero program address space 200 can be used in a call instruction
+; Check that variables in a nonzero program address space 42 can be used in a call instruction
 
-define i8 @test(i8(i32)* %fnptr0, i8(i32) addrspace(200)* %fnptr200) {
-  %first = call i8 %fnptr0(i32 0) ; this is fine
-  %second = call i8 %fnptr200(i32 0) ; this is also fine if it's the program AS
-  ; CHECK: call-nonzero-program-addrspace.ll:[[@LINE-1]]:21: error: '%fnptr200' defined with type 'i8 (i32) addrspace(200)*'
+define i8 @test(i8(i32)* %fnptr0, i8(i32) addrspace(42)* %fnptr42) {
+  %explicit_as_0 = call addrspace(0) i8 %fnptr0(i32 0)
+  %explicit_as_42 = call addrspace(42) i8 %fnptr42(i32 0)
+  ; Calling %fnptr42 without an explicit addrspace() in the call instruction is only okay if the program AS is 42
+  %call_no_as = call i8 %fnptr42(i32 0)
+  ; CHECK: call-nonzero-program-addrspace.ll:[[@LINE-1]]:25: error: '%fnptr42' defined with type 'i8 (i32) addrspace(42)*' but expected 'i8 (i32)*'
   ret i8 0
 }
 
-declare i32 @__gxx_personality_v0(...)
+; PROGAS42:       target datalayout = "P42"
+; PROGAS42:       define i8 @test(i8 (i32)* %fnptr0, i8 (i32) addrspace(42)* %fnptr42) addrspace(42) {
+; Print addrspace(0) since the program address space is non-zero:
+; PROGAS42-NEXT:    %explicit_as_0 = call addrspace(0) i8 %fnptr0(i32 0)
+; Also print addrspace(42) since we always print non-zero addrspace:
+; PROGAS42-NEXT:    %explicit_as_42 = call addrspace(42) i8 %fnptr42(i32 0)
+; PROGAS42-NEXT:    %call_no_as = call addrspace(42) i8 %fnptr42(i32 0)
+; PROGAS42-NEXT:    ret i8 0
+; PROGAS42-NEXT:  }
diff -rN --unified llvm-toolchain-7-7.0.1/test/Assembler/invoke-nonzero-program-addrspace.ll llvm-toolchain-7-7.0.1.patched/test/Assembler/invoke-nonzero-program-addrspace.ll
--- llvm-toolchain-7-7.0.1/test/Assembler/invoke-nonzero-program-addrspace.ll	2018-12-16 12:02:52.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/Assembler/invoke-nonzero-program-addrspace.ll	2019-05-19 11:21:52.895903000 +0000
@@ -1,12 +1,15 @@
-; RUN: llvm-as %s -data-layout=P200 -o /dev/null
 ; RUN: not llvm-as %s -o /dev/null 2>&1 | FileCheck %s
+; RUN: llvm-as %s -data-layout=P200 -o - | llvm-dis - -o - | FileCheck %s -check-prefix PROGAS200
+
 
 ; Check that variables in a nonzero program address space 200 can be used in a invoke instruction
 
-define i8 @test_invoke(i8(i32)* %fnptr0, i8(i32) addrspace(200)* %fnptr200) personality i32 (...)* @__gxx_personality_v0 {
-  %first = invoke i8 %fnptr0(i32 0) to label %ok unwind label %lpad ; this is fine
-  %second = invoke i8 %fnptr200(i32 0) to label %ok unwind label %lpad ; this is also fine if it's the program AS
-  ; CHECK: invoke-nonzero-program-addrspace.ll:[[@LINE-1]]:23: error: '%fnptr200' defined with type 'i8 (i32) addrspace(200)*'
+define i8 @test_invoke(i8(i32)* %fnptr0, i8(i32) addrspace(200)* %fnptr200) personality i32 (...) addrspace(200)* @__gxx_personality_v0 {
+  %explicit_as_0 = invoke addrspace(0) i8 %fnptr0(i32 0) to label %ok unwind label %lpad
+  %explicit_as_42 = invoke addrspace(200) i8 %fnptr200(i32 0) to label %ok unwind label %lpad
+  ; The following is only okay if the program address space is 200:
+  %no_as = invoke i8 %fnptr200(i32 0) to label %ok unwind label %lpad
+  ; CHECK: invoke-nonzero-program-addrspace.ll:[[@LINE-1]]:22: error: '%fnptr200' defined with type 'i8 (i32) addrspace(200)*' but expected 'i8 (i32)*'
 ok:
   ret i8 0
 lpad:
@@ -16,3 +19,12 @@
 }
 
 declare i32 @__gxx_personality_v0(...)
+
+
+; PROGAS200:  target datalayout = "P200"
+; PROGAS200:  define i8 @test_invoke(i8 (i32)* %fnptr0, i8 (i32) addrspace(200)* %fnptr200) addrspace(200) personality i32 (...) addrspace(200)* @__gxx_personality_v0 {
+; PROGAS200:    %explicit_as_0 = invoke addrspace(0) i8 %fnptr0(i32 0)
+; PROGAS200:    %explicit_as_42 = invoke addrspace(200) i8 %fnptr200(i32 0)
+; PROGAS200:    %no_as = invoke addrspace(200) i8 %fnptr200(i32 0)
+; PROGAS200:    ret i8 0
+; PROGAS200:  }
diff -rN --unified llvm-toolchain-7-7.0.1/test/Bitcode/function-address-space-fwd-decl.ll llvm-toolchain-7-7.0.1.patched/test/Bitcode/function-address-space-fwd-decl.ll
--- llvm-toolchain-7-7.0.1/test/Bitcode/function-address-space-fwd-decl.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/Bitcode/function-address-space-fwd-decl.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,39 @@
+; Verify that forward declarations from call instructions work even with non-zero AS
+; RUN: llvm-as %s -o - | llvm-dis - | FileCheck %s
+
+define void @call_named() {
+entry:
+  %0 = tail call addrspace(40) i32 @named(i16* null)
+  ; CHECK: %0 = tail call addrspace(40) i32 @named(i16* null)
+  ret void
+}
+
+define void @call_numbered() {
+entry:
+  %0 = tail call addrspace(40) i32 @0(i16* null)
+  ; CHECK: %0 = tail call addrspace(40) i32 @0(i16* null)
+  ret void
+}
+
+
+define i32 @invoked() personality i8* null {
+entry:
+  %0 = invoke addrspace(40) i32 @foo() to label %l1 unwind label %lpad
+  ; CHECK: invoke addrspace(40) i32 @foo()
+l1:
+  br label %return
+lpad:
+  %1 = landingpad { i8*, i32 }
+    catch i8* null
+    catch i8* null
+  ret i32 0
+return:
+  ret i32 0
+}
+
+declare i32 @foo() addrspace(40)
+; CHECK: declare i32 @foo() addrspace(40)
+declare i32 @named(i16* nocapture) addrspace(40)
+; CHECK: declare i32 @named(i16* nocapture) addrspace(40)
+declare i32 @0(i16*) addrspace(40)
+; CHECK: declare i32 @0(i16*) addrspace(40)
diff -rN --unified llvm-toolchain-7-7.0.1/test/Bitcode/function-default-address-spaces.ll llvm-toolchain-7-7.0.1.patched/test/Bitcode/function-default-address-spaces.ll
--- llvm-toolchain-7-7.0.1/test/Bitcode/function-default-address-spaces.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/Bitcode/function-default-address-spaces.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,35 @@
+; RUN: llvm-as %s  -o - | llvm-dis - | FileCheck %s -check-prefixes CHECK,PROG-AS0
+; RUN: llvm-as -data-layout "P200" %s  -o - | llvm-dis | FileCheck %s -check-prefixes CHECK,PROG-AS200
+; RUN: not llvm-as -data-layout "P123456789" %s -o /dev/null 2>&1 | FileCheck %s -check-prefix BAD-DATALAYOUT
+; BAD-DATALAYOUT: LLVM ERROR: Invalid address space, must be a 24-bit integer
+
+; PROG-AS0-NOT: target datalayout
+; PROG-AS200: target datalayout = "P200"
+
+; Check that a function declaration without an address space (i.e. AS0) does not
+; have the addrspace() attribute printed if it is address space zero and it is
+; equal to the program address space.
+
+; PROG-AS0: define void @no_as() {
+; PROG-AS200: define void @no_as() addrspace(200) {
+define void @no_as() {
+  ret void
+}
+
+; A function with an explicit addrspace should only have the addrspace printed
+; if it is non-zero or if the module has a nonzero datalayout
+; PROG-AS0: define void @explit_as0()  {
+; PROG-AS200: define void @explit_as0() addrspace(0) {
+define void @explit_as0() addrspace(0) {
+  ret void
+}
+
+; CHECK: define void @explit_as200() addrspace(200) {
+define void @explit_as200() addrspace(200) {
+  ret void
+}
+
+; CHECK: define void @explicit_as3() addrspace(3) {
+define void @explicit_as3() addrspace(3) {
+  ret void
+}
diff -rN --unified llvm-toolchain-7-7.0.1/test/Bitcode/function-nonzero-address-spaces-types.ll llvm-toolchain-7-7.0.1.patched/test/Bitcode/function-nonzero-address-spaces-types.ll
--- llvm-toolchain-7-7.0.1/test/Bitcode/function-nonzero-address-spaces-types.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/Bitcode/function-nonzero-address-spaces-types.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,23 @@
+; Verify that we accept calls to variables in the program AS:
+; RUN: llvm-as -data-layout "P40" %s -o - | llvm-dis - | FileCheck %s
+; CHECK: target datalayout = "P40"
+
+; We should get a sensible error for a non-program address call:
+; RUN: not llvm-as -data-layout "P39" %s -o /dev/null 2>&1 | FileCheck %s -check-prefix ERR-AS39
+; ERR-AS39: error: '%0' defined with type 'i16 (i16) addrspace(40)*' but expected 'i16 (i16) addrspace(39)*'
+
+; And also if we don't set a custom program address space:
+; RUN: not llvm-as %s -o /dev/null 2>&1 | FileCheck %s -check-prefix ERR-AS0
+; ERR-AS0: error: '%0' defined with type 'i16 (i16) addrspace(40)*' but expected 'i16 (i16)*'
+
+%fun1 = type i16 (i16)
+%funptr1 = type %fun1 addrspace(40)*
+
+@fun_ptr = global %funptr1 @fun
+
+define i16 @fun(i16 %arg) addrspace(40) {
+entry:
+  %0 = load %funptr1, %funptr1* @fun_ptr
+  %result = call i16 %0(i16 %arg)
+  ret i16 %result
+}
diff -rN --unified llvm-toolchain-7-7.0.1/test/Bitcode/function-nonzero-address-spaces.ll llvm-toolchain-7-7.0.1.patched/test/Bitcode/function-nonzero-address-spaces.ll
--- llvm-toolchain-7-7.0.1/test/Bitcode/function-nonzero-address-spaces.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/Bitcode/function-nonzero-address-spaces.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,29 @@
+; Verify that we accept calls to variables in the program AS:
+; RUN: llvm-as -data-layout "P40" %s -o - | llvm-dis - | FileCheck %s
+; CHECK: target datalayout = "P40"
+
+; We should get a sensible error for a non-program address call:
+; RUN: not llvm-as -data-layout "P39" %s -o /dev/null 2>&1 | FileCheck %s -check-prefix ERR-AS39
+; ERR-AS39: error: '%fnptr' defined with type 'void (i16) addrspace(40)*' but expected 'void (i16) addrspace(39)*'
+
+; And also if we don't set a custom program address space:
+; RUN: not llvm-as %s -o /dev/null 2>&1 | FileCheck %s -check-prefix ERR-AS0
+; ERR-AS0: error: '%fnptr' defined with type 'void (i16) addrspace(40)*' but expected 'void (i16)*'
+
+define void @f_named(i16 %n, void (i16) addrspace(40)* %f) addrspace(40) {
+entry:
+  %f.addr = alloca void (i16) addrspace(40)*, align 1
+  store void (i16) addrspace(40)* %f, void (i16) addrspace(40)** %f.addr
+  %fnptr = load void (i16) addrspace(40)*, void (i16) addrspace(40)** %f.addr
+  call void %fnptr(i16 8)
+  ret void
+}
+
+define void @f_numbered(i16 %n, void (i16) addrspace(40)* %f) addrspace(40){
+entry:
+  %f.addr = alloca void (i16) addrspace(40)*, align 1
+  store void (i16) addrspace(40)* %f, void (i16) addrspace(40)** %f.addr
+  %0 = load void (i16) addrspace(40)*, void (i16) addrspace(40)** %f.addr
+  call void %0(i16 8)
+  ret void
+}
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/calling-conv-32bit-interop.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/calling-conv-32bit-interop.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/calling-conv-32bit-interop.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/calling-conv-32bit-interop.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,232 @@
+; RUN: llc < %s -mtriple=x86_64-apple-darwin17-wine32 | FileCheck %s -check-prefixes=CHECK,CHECK-SDAG
+; RUN: llc < %s -mtriple=x86_64-apple-darwin17-wine32 -fast-isel | FileCheck %s -check-prefixes=CHECK,CHECK-FAST
+
+%struct.__thunk_data = type { i64, i64, i64 }
+
+define x86_64_c32cc i64 @foo(%struct.__thunk_data addrspace(32)* thunkdata %td, i32 %a, i64 %b, i8 addrspace(32)* %c, ...) {
+; CHECK-LABEL: _foo:
+  %1 = load i8, i8 addrspace(32)* %c
+; CHECK: movl 32(%esp), %eax
+  %2 = zext i8 %1 to i32
+; CHECK-NEXT: movzbl (%eax), %eax
+  %3 = add i32 %2, %a
+; CHECK-NEXT: addl 20(%esp), %eax
+  %4 = sext i32 %3 to i64
+; CHECK-NEXT: cltq
+  %5 = sub i64 %4, %b
+; CHECK-NEXT: subq 24(%esp), %rax
+  ret i64 %5
+; CHECK-NEXT: movq %rax, %rdx
+; CHECK-NEXT: shrq $32, %rdx
+; CHECK: retq{{$}}
+}
+
+define i64 @call_foo() {
+; CHECK-LABEL: _call_foo:
+  %td = alloca %struct.__thunk_data, align 8, addrspace(32)
+; CHECK: subl $56, %esp
+  %1 = call x86_64_c32cc i64 (%struct.__thunk_data addrspace(32)*, i32, i64, i8 addrspace(32)*, ...) @foo(%struct.__thunk_data addrspace(32)* %td, i32 0, i64 0, i8 addrspace(32)* null)
+; CHECK-NOT: movb $0, %al
+; CHECK-DAG: movl $0, 12(%esp)
+; CHECK-DAG: movq $0, 16(%esp)
+; CHECK-DAG: movl $0, 24(%esp)
+; CHECK-DAG: leal 32(%rsp), %eax
+; CHECK-NOT: movb $0, %al
+; CHECK: callq _foo
+  %2 = add i64 %1, 10
+; CHECK: shlq $32, %rdx
+; CHECK-SDAG: leaq 10(%rax,%rdx), %rax
+; CHECK-FAST: orq %rdx, %rax
+; CHECK-FAST: addq $10, %rax
+  ret i64 %2
+; CHECK: addl $56, %esp
+; CHECK: retq
+}
+
+define x86_stdcallcc i64 @bar(%struct.__thunk_data addrspace(32)* thunkdata %td, i32 %a, i64 %b, i8 addrspace(32)* %c) {
+; CHECK-LABEL: _bar:
+  %1 = load i8, i8 addrspace(32)* %c
+; CHECK: movl 32(%esp), %eax
+  %2 = zext i8 %1 to i32
+; CHECK-NEXT: movzbl (%eax), %eax
+  %3 = add i32 %2, %a
+; CHECK-NEXT: addl 20(%esp), %eax
+  %4 = sext i32 %3 to i64
+; CHECK-NEXT: cltq
+  %5 = sub i64 %4, %b
+; CHECK-NEXT: subq 24(%esp), %rax
+  ret i64 %5
+; CHECK-NEXT: movq %rax, %rdx
+; CHECK-NEXT: shrq $32, %rdx
+; CHECK: retq{{$}}
+}
+
+define void @call_bar() {
+; CHECK-LABEL: _call_bar:
+  %td = alloca %struct.__thunk_data, align 8, addrspace(32)
+; CHECK: subl $56, %esp
+  %1 = call x86_stdcallcc i64 @bar(%struct.__thunk_data addrspace(32)* %td, i32 0, i64 0, i8 addrspace(32)* null)
+; CHECK-DAG: movl $0, 12(%esp)
+; CHECK-DAG: movq $0, 16(%esp)
+; CHECK-DAG: movl $0, 24(%esp)
+; CHECK-DAG: leal 32(%rsp), %eax
+; CHECK: callq _bar
+; CHECK: addl $56, %esp
+; CHECK: retq
+  ret void
+}
+
+define x86_fastcallcc i64 @baz(%struct.__thunk_data addrspace(32)* thunkdata %td, i32 inreg %a, i64 inreg %b, i8 addrspace(32)* %c) {
+; CHECK-LABEL: _baz:
+  %1 = load i8, i8 addrspace(32)* %c
+; CHECK: movl 28(%esp), %eax
+  %2 = zext i8 %1 to i32
+; CHECK-NEXT: movzbl (%eax), %eax
+  %3 = add i32 %2, %a
+; CHECK-NEXT: addl %ecx, %eax
+  %4 = sext i32 %3 to i64
+; CHECK-NEXT: cltq
+  %5 = sub i64 %4, %b
+; CHECK-NEXT: subq 20(%esp), %rax
+  ret i64 %5
+; CHECK-NEXT: movq %rax, %rdx
+; CHECK-NEXT: shrq $32, %rdx
+; CHECK: retq{{$}}
+}
+
+define void @call_baz() {
+; CHECK-LABEL: _call_baz:
+  %td = alloca %struct.__thunk_data, align 8, addrspace(32)
+; CHECK: subl $56, %esp
+  %1 = call x86_fastcallcc i64 @baz(%struct.__thunk_data addrspace(32)* %td, i32 inreg 0, i64 inreg 0, i8 addrspace(32)* null)
+; CHECK-DAG: xorl %ecx, %ecx
+; CHECK-DAG: movq $0, 12(%esp)
+; CHECK-DAG: movl $0, 20(%esp)
+; CHECK-DAG: leal 32(%rsp), %eax
+; CHECK: callq _baz
+; CHECK: addl $56, %esp
+; CHECK: retq
+  ret void
+}
+
+%s = type { i64 }
+
+define x86_thiscallcc void @quux(%struct.__thunk_data addrspace(32)* thunkdata %td, %s addrspace(32)* sret %sret, i32 inreg %a, i64 %b, i8 addrspace(32)* %c) #1 {
+; CHECK-LABEL: _quux:
+; CHECK: movl 20(%esp), %eax
+  %1 = load i8, i8 addrspace(32)* %c
+; CHECK: movl 32(%esp), %edx
+  %2 = zext i8 %1 to i32
+; CHECK: movzbl (%edx), %edx
+  %3 = add i32 %2, %a
+; CHECK-NEXT: addl %ecx, %edx
+  %4 = sext i32 %3 to i64
+; CHECK-NEXT: movslq %edx, %rcx
+  %5 = sub i64 %4, %b
+; CHECK-NEXT: subq 24(%esp), %rcx
+  %6 = getelementptr inbounds %s, %s addrspace(32)* %sret, i32 0, i32 0
+  store i64 %5, i64 addrspace(32)* %6
+  ret void
+; CHECK-NEXT: movq %rcx, (%eax)
+; CHECK: retq{{$}}
+}
+
+define void @call_quux() {
+; CHECK-LABEL: _call_quux:
+  %td = alloca %struct.__thunk_data, align 8, addrspace(32)
+  %sr = alloca %s, align 8, addrspace(32)
+; CHECK: subl $72, %esp
+  call x86_thiscallcc void @quux(%struct.__thunk_data addrspace(32)* %td, %s addrspace(32)* sret %sr, i32 inreg 0, i64 0, i8 addrspace(32)* null)
+; CHECK: leal 40(%rsp), %eax
+; CHECK: movl %eax, 12(%esp)
+; CHECK-DAG: xorl %ecx, %ecx
+; CHECK-DAG: movq $0, 16(%esp)
+; CHECK-DAG: movl $0, 24(%esp)
+; CHECK-DAG: leal 48(%rsp), %eax
+; CHECK: callq _quux
+; CHECK: addl $72, %esp
+; CHECK: retq
+  ret void
+}
+
+module asm "___i386_on_x86_64_thunk_baz:
+  lretl"
+
+; Check that thunks are generated and that they have the correct form.
+; Every thunk must be immediately preceded by a magic number. The
+; extra goop is to ensure that the magic number directly abuts the thunk, and
+; that the thunk and the magic number are on the same page.
+; CHECK: .p2align 5, 0x90
+; CHECK: .quad _foo-[[PB:.*]]
+; CHECK: .quad 8595522607861216050
+; CHECK-LABEL: ___i386_on_x86_64_thunk_foo:
+; CHECK:         movl %edi, %edi
+; CHECK-NEXT:    callq [[PB]]
+; CHECK:       [[PB]]:
+; CHECK-NEXT:    popl %eax
+; CHECK:         pushq %rax
+; CHECK-NEXT:    pushq %rax
+; CHECK-NEXT:    leal [[FOO64:[^-]*]]-[[PB]](%rax), %eax
+; CHECK-NEXT:    xchgl %eax, (%rsp)
+; CHECK-NEXT:    movl L___i386_on_x86_64_cs64$non_lazy_ptr-[[PB]](%rax), %eax
+; CHECK-NEXT:    movw (%rax), %ax
+; CHECK-NEXT:    movw %ax, 4(%rsp)
+; CHECK-NEXT:    lcalll *(%rsp)
+; CHECK-NEXT:    retq
+; CHECK:       [[FOO64]]:
+; CHECK:         popq %rax
+; CHECK-NEXT:    movq %rax, (%esp)
+; CHECK-NEXT:    callq _foo
+; CHECK-NEXT:    lretl
+
+; CHECK: .p2align 5, 0x90
+; CHECK: .quad _bar-[[PB:.*]]
+; CHECK: .quad 8595522607861216050
+; CHECK-LABEL: ___i386_on_x86_64_thunk_bar:
+; CHECK:         movl %edi, %edi
+; CHECK-NEXT:    callq [[PB]]
+; CHECK:       [[PB]]:
+; CHECK-NEXT:    popl %eax
+; CHECK:         pushq %rax
+; CHECK-NEXT:    pushq %rax
+; CHECK-NEXT:    leal [[BAR64:[^-]*]]-[[PB]](%rax), %eax
+; CHECK-NEXT:    xchgl %eax, (%rsp)
+; CHECK-NEXT:    movl L___i386_on_x86_64_cs64$non_lazy_ptr-[[PB]](%rax), %eax
+; CHECK-NEXT:    movw (%rax), %ax
+; CHECK-NEXT:    movw %ax, 4(%rsp)
+; CHECK-NEXT:    lcalll *(%rsp)
+; CHECK-NEXT:    retq $16
+; CHECK:       [[BAR64]]:
+; CHECK:         popq %rax
+; CHECK-NEXT:    movq %rax, (%esp)
+; CHECK-NEXT:    callq _bar
+; CHECK-NEXT:    lretl
+
+; Check that thunks *aren't* generated if we already defined them in inline
+; assembly.
+; CHECK-NOT: ___i386_on_x86_64_thunk_baz:
+
+; CHECK: .p2align 5, 0x90
+; CHECK: .quad _quux-[[PB:.*]]
+; CHECK: .quad 8595522607861216050
+; CHECK-LABEL: ___wine32_thunk_quux:
+; CHECK:         movl %edi, %edi
+; CHECK-NEXT:    callq [[PB]]
+; CHECK:       [[PB]]:
+; CHECK-NEXT:    popl %eax
+; CHECK:         pushq %rax
+; CHECK-NEXT:    pushq %rax
+; CHECK-NEXT:    leal [[QUUX64:[^-]*]]-[[PB]](%rax), %eax
+; CHECK-NEXT:    xchgl %eax, (%rsp)
+; CHECK-NEXT:    movl L___wine32_cs64$non_lazy_ptr-[[PB]](%rax), %eax
+; CHECK-NEXT:    movw (%rax), %ax
+; CHECK-NEXT:    movw %ax, 4(%rsp)
+; CHECK-NEXT:    lcalll *(%rsp)
+; CHECK-NEXT:    retq $16
+; CHECK:       [[QUUX64]]:
+; CHECK:         popq %rax
+; CHECK-NEXT:    movq %rax, (%esp)
+; CHECK-NEXT:    callq _quux
+; CHECK-NEXT:    lretl
+
+attributes #1 = { "thunk-prefix"="__wine32_" "thunk-cs64-name"="__wine32_cs64" }
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/ms-hotpatch-attr.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/ms-hotpatch-attr.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/ms-hotpatch-attr.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/ms-hotpatch-attr.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,27 @@
+; RUN: llc < %s -march=x86 -filetype=asm | FileCheck -check-prefix=CHECK-32 %s
+; RUN: llc < %s -march=x86-64 -filetype=asm | FileCheck -check-prefix=CHECK-64 %s
+; RUN: llc < %s -mtriple=i386-windows-msvc -filetype=asm | FileCheck -check-prefix=MSVC-32 %s
+; RUN: llc < %s -mtriple=x86_64-windows-msvc -filetype=asm | FileCheck -check-prefix=MSVC-64 %s
+
+; CHECK-32: .space 64,204
+; CHECK-32: .p2align 4, 0x90
+; CHECK-32-LABEL: foo:
+; CHECK-32: movl %edi, %edi
+; CHECK-32-NEXT: pushl %ebp
+; CHECK-32-NEXT: movl %esp, %ebp
+; CHECK-64: .space 128,204
+; CHECK-64: .p2align 4, 0x90
+; CHECK-64-LABEL: foo:
+; CHECK-64: xchgw %ax, %ax
+; MSVC-32-NOT: .space 64,204
+; MSVC-32-LABEL: _foo:
+; MSVC-32: movl %edi, %edi
+; MSVC-32-NEXT: pushl %ebp
+; MSVC-32-NEXT: movl %esp, %ebp
+; MSVC-64-NOT: .space 128,204
+; MSVC-64-LABEL: foo:
+; MSVC-64: xchgw %ax, %ax
+define void @foo() nounwind "patchable-function"="ms-hotpatch" {
+entry:
+  ret void
+}
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-addrspacecast.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-addrspacecast.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-addrspacecast.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-addrspacecast.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,16 @@
+; RUN: llc -mtriple=x86_64-pc-linux-wine32 < %s | FileCheck %s
+
+define i32 @foo(i32* %a, i32 addrspace(32)* %b) {
+  %x = addrspacecast i32* %a to i32 addrspace(32)*
+  %y = addrspacecast i32 addrspace(32)* %b to i32*
+  %1 = load i32, i32 addrspace(32)* %x
+  %2 = load i32, i32* %y
+  %3 = add i32 %1, %2
+  ret i32 %3
+}
+
+; CHECK-LABEL: foo:
+; CHECK:         movl %esi, %{{e?}}[[R2:.*]]{{d?}}
+; CHECK:         movl (%edi), %eax
+; CHECK-NEXT:    addl (%{{r?}}[[R2]]), %eax
+; CHECK-NEXT:    retq
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-arg-simple.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-arg-simple.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-arg-simple.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-arg-simple.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,22 @@
+; RUN: llc -mtriple=x86_64-pc-linux-wine32 < %s | FileCheck %s
+
+; CHECK-LABEL: foo
+; CHECK: movl %esi, (%edi)
+
+define void @foo(i32 addrspace(32)* nocapture %out, i32 %in) nounwind {
+entry:
+  store i32 %in, i32 addrspace(32)* %out, align 4
+  ret void
+}
+
+; CHECK-LABEL: bar
+; CHECK: movl (%esi), %eax
+; CHECK: movl %eax, (%rdi)
+
+define void @bar(i32* nocapture %pOut, i32 addrspace(32)* nocapture %pIn) nounwind {
+entry:
+  %0 = load i32, i32 addrspace(32)* %pIn, align 4
+  store i32 %0, i32* %pOut, align 4
+  ret void
+}
+
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-base-pointer-and-cmpxchg.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-base-pointer-and-cmpxchg.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-base-pointer-and-cmpxchg.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-base-pointer-and-cmpxchg.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,45 @@
+; RUN: llc -mtriple=x86_64-apple-macosx-wine32 -mattr=+cx16 -x86-use-base-pointer=true -stackrealign -stack-alignment=32  %s -o - | FileCheck --check-prefix=CHECK --check-prefix=USE_BASE %s
+; RUN: llc -mtriple=x86_64-apple-macosx-wine32 -mattr=+cx16 -x86-use-base-pointer=false -stackrealign -stack-alignment=32  %s -o - | FileCheck --check-prefix=CHECK --check-prefix=DONT_USE_BASE %s
+
+; This function uses dynamic allocated stack to force the use
+; of a frame pointer.
+; The inline asm clobbers a bunch of registers to make sure
+; the frame pointer will need to be used (for spilling in that case).
+;
+; Then, we check that when we use rbx as the base pointer,
+; we do not use cmpxchg, since using that instruction requires
+; to clobbers rbx to set the arguments of the instruction and when
+; rbx is used as the base pointer, RA cannot fix the code for us.
+;
+; CHECK-LABEL: cmp_and_swap16:
+; Check that we actually use rbx.
+; USE_BASE: movl %esp, %ebx
+;
+; Make sure the base pointer is saved before the rbx argument for
+; cmpxchg16b is set.
+;
+; Because of how the test is written, we spill SAVE_rbx.
+; However, it would have been perfectly fine to just keep it in register.
+; USE_BASE: movq %rbx, [[SAVE_rbx_SLOT:[0-9]*\(%[er]bx\)]]
+;
+; SAVE_rbx must be in register before we clobber rbx.
+; It is fine to use any register but rbx and the ones defined and use
+; by cmpxchg (%rax, %rcx, %rdx).
+; USE_BASE: movq [[SAVE_rbx_SLOT]], [[SAVE_rbx:%r([sd]i|bp|[0-9]+)]]
+;
+; USE_BASE: movq {{[^ ]+}}, %rbx
+; USE_BASE-NEXT: cmpxchg16b
+; USE_BASE-NEXT: movq [[SAVE_rbx]], %rbx
+;
+; DONT_USE_BASE-NOT: movq %rsp, %rbx
+; DONT_USE_BASE-NOT: movl %esp, %ebx
+; DONT_USE_BASE: cmpxchg
+define i1 @cmp_and_swap16(i128 %a, i128 %b, i128 addrspace(32)* %addr, i32 %n) {
+  %dummy = alloca i32, i32 %n, addrspace(32)
+tail call void asm sideeffect "nop", "~{rax},~{rcx},~{rdx},~{rsi},~{rdi},~{rbp},~{r8},~{r9},~{r10},~{r11},~{r12},~{r13},~{r14},~{r15}"()
+  %cmp = cmpxchg i128 addrspace(32)* %addr, i128 %a, i128 %b seq_cst seq_cst
+  %res = extractvalue { i128, i1 } %cmp, 1
+  %idx = getelementptr i32, i32 addrspace(32)* %dummy, i32 5
+  store i32 %n, i32 addrspace(32)* %idx
+  ret i1 %res
+}
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-call-frame-opt.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-call-frame-opt.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-call-frame-opt.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-call-frame-opt.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,34 @@
+; RUN: llc < %s | FileCheck %s
+target datalayout = "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-apple-macosx10.12.0-wine32"
+
+; Test that call frame optimization doesn't crash on this input.
+
+@DXTraceW.format.5 = external dso_local constant [31 x i16], align 16
+
+; Function Attrs: nounwind ssp uwtable
+define x86_stdcallcc i32 @DXTraceW(i8* %strFile, i32 %dwLine, i32 returned %hr, i16* %strMsg) local_unnamed_addr #0 {
+entry:
+  call x86_64_c32cc void ({ [6 x i64] } addrspace(32)*, i16*, i16*, ...) @wsprintfW({ [6 x i64] } addrspace(32)* thunkdata undef, i16* undef, i16* getelementptr inbounds ([31 x i16], [31 x i16]* @DXTraceW.format.5, i64 0, i64 0), i8* %strFile, i32 %dwLine, i16* %strMsg, i16* undef, i32 %hr) #2
+  ; CHECK: movq    28(%ebp), %[[STRMSG:.*]]
+  ; CHECK: movl    36(%ebp), %[[HR:.*]]
+  ; CHECK: movq    44(%ebp), %[[STRFILE:.*]]
+  ; CHECK: movl    40(%ebp), %[[DWLINE:.*]]
+  ; CHECK: movl    %[[DWLINE]], 56(%esp)
+  ; CHECK: movq    %[[STRFILE]], 40(%esp)
+  ; CHECK: movl    %[[HR]], 36(%esp)
+  ; CHECK: movq    %[[STRMSG]], 28(%esp)
+  ; CHECK: leaq    _DXTraceW.format.5(%rip), %[[FORMAT:.*]]
+  ; CHECK: movq    %[[FORMAT]], 20(%esp)
+  ; CHECK: callq   _wsprintfW
+  unreachable
+}
+
+declare hidden x86_64_c32cc void @wsprintfW({ [6 x i64] } addrspace(32)* thunkdata, i16*, i16*, ...) local_unnamed_addr
+; CHECK-NOT: _winethunk_wsprintfW
+; CHECK-NOT: ___i386_on_x86_64_thunk_wsprintfW
+; CHECK-NOT: ___i386_on_x86_64_cs64
+
+attributes #0 = { nounwind ssp uwtable "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "stack-protector-buffer-size"="8" "thunk-cs32-name"="wine_32on64_cs32" "thunk-cs64-name"="wine_32on64_cs64" "thunk-prefix"="wine" }
+attributes #2 = { nounwind }
+
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-function_pointer-2.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-function_pointer-2.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-function_pointer-2.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-function_pointer-2.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,31 @@
+; RUN: llc < %s -mtriple=x86_64-apple-darwin17-wine32 | FileCheck %s
+; RUN: llc < %s -mtriple=x86_64-apple-darwin17-wine32 -fast-isel | FileCheck %s
+
+; Test call function pointer with function argument
+;
+; void bar (void * h, void (*foo) (void *))
+;    {
+;      foo (h);
+;      foo (h);
+;    }
+
+%baz = type { [6 x i64] }
+
+define void @bar(i8 addrspace(32)* %h, void (%baz addrspace(32)*, i8 addrspace(32)*) addrspace(32)* nocapture %foo) nounwind {
+entry:
+  %td = alloca %baz, align 8, addrspace(32)
+  tail call x86_64_c32cc addrspace(32) void %foo(%baz addrspace(32)* thunkdata %td, i8 addrspace(32)* %h) nounwind
+; CHECK-LABEL: _bar:
+; CHECK: movq	%rsi, 8(%eax)
+; CHECK: callq	___i386_on_x86_64_invoke32_0
+  tail call addrspace(32) void %foo(%baz addrspace(32)* thunkdata %td, i8 addrspace(32)* %h) nounwind
+; CHECK: movl	%esi, %eax
+; CHECK: jmpq	*%rax
+  ret void
+}
+
+; CHECK-LABEL: ___i386_on_x86_64_invoke32_0:
+; CHECK: movq ___i386_on_x86_64_cs64@GOTPCREL(%rip), %r9
+; CHECK-NEXT: cmpw (%r9), %r8w
+; CHECK: movq ___i386_on_x86_64_cs32@GOTPCREL(%rip), %r9
+; CHECK-NEXT: movw (%r9), %r9w
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-function_pointer-3.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-function_pointer-3.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-function_pointer-3.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-function_pointer-3.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,41 @@
+; RUN: llc < %s -mtriple=x86_64-linux-wine32 | FileCheck %s
+; RUN: llc < %s -mtriple=x86_64-linux-wine32 -fast-isel | FileCheck %s
+
+; Test calling function pointer passed in struct
+
+;    The function argument `h' in
+
+;    struct foo {
+;      void (* __ptr32 f) (void);
+;      int i;
+;    };
+;    void
+;    bar (struct foo h)
+;    {
+;      h.f ();
+;    }
+
+;    is passed in the 64-bit %rdi register.  The `f' field is in the lower 32
+;    bits of %rdi register and the `i' field is in the upper 32 bits of %rdi
+;    register.
+
+%foo = type { [6 x i64] }
+
+define void @bar(i64 %h.coerce) #1 {
+entry:
+  %td = alloca %foo, align 8, addrspace(32)
+  %h.sroa.0.0.extract.trunc = trunc i64 %h.coerce to i32
+  %0 = inttoptr i32 %h.sroa.0.0.extract.trunc to void (%foo addrspace(32)*) addrspace(32)*
+  tail call x86_64_c32cc addrspace(32) void %0(%foo addrspace(32)* thunkdata %td) nounwind
+; CHECK-LABEL: bar:
+; CHECK: movq	%rdi, 8(%eax)
+; CHECK: callq	__wine32_invoke32_0
+  ret void
+}
+
+; CHECK-LABEL: __wine32_invoke32_0:
+; CHECK: cmpw __wine32_cs64, %r8w
+; CHECK: movw __wine32_cs32, %r9w
+; CHECK: callq *8(%rbx)
+
+attributes #1 = { nounwind "thunk-prefix"="__wine32_" "thunk-cs32-name"="__wine32_cs32" "thunk-cs64-name"="__wine32_cs64" }
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-function_pointer-4.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-function_pointer-4.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-function_pointer-4.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-function_pointer-4.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,78 @@
+; RUN: llc < %s -mtriple=x86_64-linux-wine32 -relocation-model=pic  | FileCheck %s
+; RUN: llc < %s -mtriple=x86_64-linux-wine32 -relocation-model=pic -fast-isel | FileCheck %s
+
+; Test for 32-bit function pointers with 32-bit calling conventions
+
+%struct.__thunk_data = type { i64, i64, i64, i64, i64, i64 }
+
+@foo = external global void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i64) addrspace(32)*
+@bar = external global void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i64) addrspace(32)*
+@baz = external global void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i32, i64) addrspace(32)*
+@quux = external global void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i64) addrspace(32)*
+
+define void @test(i8 addrspace(32)* %h) nounwind uwtable {
+entry:
+  %td = alloca %struct.__thunk_data, align 8, addrspace(32)
+  %0 = load void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i64) addrspace(32)*, void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i64) addrspace(32)** @foo, align 4
+; CHECK:      movq	foo@GOTPCREL(%rip), %rax
+; CHECK-NEXT: movl	(%rax), %{{[er]}}[[REG:[a-z]*|[0-9]+]]{{d?}}
+  tail call x86_64_c32cc addrspace(32) void %0(%struct.__thunk_data addrspace(32)* thunkdata %td, i8 addrspace(32)* %h, i64 0) nounwind
+; CHECK: movl	%edi, (%esp)
+; CHECK: movq	$0, 4(%esp)
+; CHECK: movq	%r[[REG]], 8(%eax)
+; CHECK: callq	__i386_on_x86_64_invoke32_0
+  %1 = load void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i64) addrspace(32)*, void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i64) addrspace(32)** @bar, align 4
+; CHECK:      movq	bar@GOTPCREL(%rip), %rax
+; CHECK-NEXT: movl	(%rax), %{{[er]}}[[REG2:[a-z]*|[0-9]+]]{{d?}}
+  tail call x86_stdcallcc addrspace(32) void %1(%struct.__thunk_data addrspace(32)* thunkdata %td, i8 addrspace(32)* %h, i64 0) nounwind
+; The callee will pop only 12 bytes from the stack. Make sure the stack
+; gets readjusted after the call.
+; CHECK: movl	%edi, (%esp)
+; CHECK: movq	$0, 4(%esp)
+; CHECK: movq	%r[[REG2]], 8(%eax)
+; CHECK: callq	__i386_on_x86_64_invoke32_12
+; CHECK: subl	$12, %esp
+  %2 = load void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i32, i64) addrspace(32)*, void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i32, i64) addrspace(32)** @baz, align 4
+; CHECK: movq	baz@GOTPCREL(%rip), %rax
+; CHECK: movl	(%rax), %{{[er]}}[[REG3:[a-z]*|[0-9]+]]{{d?}}
+  tail call x86_fastcallcc addrspace(32) void %2(%struct.__thunk_data addrspace(32)* thunkdata %td, i8 addrspace(32)* inreg %h, i32 inreg 0, i64 0) nounwind
+; CHECK: movq	$0, (%esp)
+; CHECK: xorl	%edx, %edx
+; CHECK: movl	%edi, %ecx
+; CHECK: movq	%r[[REG3]], 8(%eax)
+; CHECK: callq  __i386_on_x86_64_invoke32_8
+; CHECK: subl	$8, %esp
+  %3 = load void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i64) addrspace(32)*, void (%struct.__thunk_data addrspace(32)*, i8 addrspace(32)*, i64) addrspace(32)** @quux, align 4
+; CHECK: movq	quux@GOTPCREL(%rip), %rax
+; CHECK: movl	(%rax), %{{[er]}}[[REG4:[a-z]*|[0-9]+]]{{d?}}
+  tail call x86_thiscallcc addrspace(32) void %3(%struct.__thunk_data addrspace(32)* thunkdata %td, i8 addrspace(32)* inreg %h, i64 0) nounwind
+; CHECK: movq	$0, (%esp)
+; CHECK: movl	%edi, %ecx
+; CHECK: movq	%r[[REG4]], 8(%eax)
+; CHECK: callq  __i386_on_x86_64_invoke32_8
+; We should only have to pop 64 bytes, since the callee popped 8 bytes.
+; CHECK: addl	$64, %esp
+  ret void
+}
+
+; CHECK-LABEL: __i386_on_x86_64_invoke32_0:
+; CHECK: jmpq *%r8
+; CHECK: movq __i386_on_x86_64_cs64@GOTPCREL(%rip), %r9
+; CHECK-NEXT: cmpw (%r9), %r8w
+; CHECK: movq __i386_on_x86_64_cs32@GOTPCREL(%rip), %r9
+; CHECK-NEXT: movw (%r9), %r9w
+; Should really be 'popl', since this is 32-bit code, but we can't use that
+; in 64-bit mode.
+; CHECK: popq (%rbx)
+; CHECK: popq 4(%rbx)
+; CHECK: callq *8(%rbx)
+; CHECK: pushq 4(%rbx)
+; CHECK: pushq (%rbx)
+; CHECK: lretl
+; CHECK-LABEL: __i386_on_x86_64_invoke32_12:
+; CHECK: callq *%r8
+; CHECK: retq $12
+; CHECK-LABEL: __i386_on_x86_64_invoke32_8:
+; CHECK: callq *%r8
+; CHECK: retq $8
+; CHECK-NOT: __i386_on_x86_64_invoke32_8:
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-global-initializer.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-global-initializer.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-global-initializer.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-global-initializer.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,11 @@
+; RUN: llc < %s | FileCheck %s
+target datalayout = "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-apple-macosx10.13.0-wine32"
+
+@output_makefile_name = internal unnamed_addr addrspace(32) global i8* addrspacecast (i8 addrspace(32)* getelementptr inbounds ([9 x i8], [9 x i8] addrspace(32)* @.str.46, i32 0, i32 0) to i8*), align 8
+@.str.46 = private unnamed_addr addrspace(32) constant [9 x i8] c"Makefile\00", align 1
+
+; CHECK: _output_makefile_name:
+; CHECK: .quad	[[STR:.*]]
+; CHECK: [[STR]]:
+; CHECK: .asciz	"Makefile"
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-global-string.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-global-string.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-global-string.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-global-string.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,25 @@
+; RUN: llc < %s | FileCheck %s
+target datalayout = "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-apple-macosx10.13.0-wine32"
+
+@.str = private unnamed_addr addrspace(32) constant [4 x i8] c"foo\00", align 1
+
+; Function Attrs: nounwind ssp uwtable
+define i32 @main() local_unnamed_addr #0 {
+  %call1 = tail call i32 @res_9_query(i8* addrspacecast (i8 addrspace(32)* getelementptr inbounds ([4 x i8], [4 x i8] addrspace(32)* @.str, i32 0, i32 0) to i8*), i32 1, i32 0, i8* null, i32 0) #2
+  ret i32 0
+}
+
+; CHECK-LABEL: _main:
+; CHECK: leal	[[STR:.*]](%rip), %edi
+; CHECK: callq	_res_9_query
+
+; CHECK: [[STR]]:
+; CHECK:   .asciz "foo"
+
+declare i32 @res_9_query(i8*, i32, i32, i8*, i32) local_unnamed_addr #1
+
+attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #2 = { nounwind }
+
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-h-register-store.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-h-register-store.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-h-register-store.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-h-register-store.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,29 @@
+; RUN: llc < %s -mtriple=x86_64-linux-wine32 | FileCheck %s
+; CHECK:      mov
+; CHECK:      movb %ah, (%esi)
+; CHECK:      mov
+; CHECK:      movb %ah, (%esi)
+; CHECK:      mov
+; CHECK:      movb %ah, (%esi)
+; CHECK-NOT:  mov
+
+; Use h-register extract and store.
+
+define void @foo16(i16 inreg %p, i8 addrspace(32)* inreg %z) nounwind {
+  %q = lshr i16 %p, 8
+  %t = trunc i16 %q to i8
+  store i8 %t, i8 addrspace(32)* %z
+  ret void
+}
+define void @foo32(i32 inreg %p, i8 addrspace(32)* inreg %z) nounwind {
+  %q = lshr i32 %p, 8
+  %t = trunc i32 %q to i8
+  store i8 %t, i8 addrspace(32)* %z
+  ret void
+}
+define void @foo64(i64 inreg %p, i8 addrspace(32)* inreg %z) nounwind {
+  %q = lshr i64 %p, 8
+  %t = trunc i64 %q to i8
+  store i8 %t, i8 addrspace(32)* %z
+  ret void
+}
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-lea-1.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-lea-1.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-lea-1.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-lea-1.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,16 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc < %s -mtriple=x86_64-linux-wine32 -O0 | FileCheck %s
+
+define void @foo(i32 addrspace(32)* addrspace(32)* %p) {
+; CHECK-LABEL: foo:
+; CHECK:       # %bb.0:
+; CHECK-NEXT:    leaq -{{[0-9]+}}(%esp), %rax
+; CHECK-NEXT:    addq $16, %rax
+; CHECK-NEXT:    movl %rax, (%edi)
+; CHECK-NEXT:    retq
+  %a = alloca i32, i32 10, addrspace(32)
+  %addr = getelementptr i32, i32 addrspace(32)* %a, i32 4
+  store i32 addrspace(32)* %addr, i32 addrspace(32)* addrspace(32)* %p
+  ret void
+}
+
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-memcmp-expansion.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-memcmp-expansion.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-memcmp-expansion.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-memcmp-expansion.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,40 @@
+; RUN: llc -O2 < %s | FileCheck %s
+target datalayout = "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-apple-macosx10.13.0-wine32"
+
+@.str.47 = private unnamed_addr addrspace(32) constant [4 x i8] c"../\00", align 1
+@.str.132 = private unnamed_addr addrspace(32) constant [51 x i8] c"#include directive with relative path not allowed\0A\00", align 1
+
+; Function Attrs: noreturn nounwind ssp uwtable
+declare void @fatal_error(i8* nocapture readonly %msg, ...) unnamed_addr #7
+
+; Function Attrs: nounwind ssp uwtable
+define internal fastcc void @add_dependency(i8* %name) unnamed_addr #0 {
+entry:
+  %call = tail call i32 @memcmp(i8* %name, i8 addrspace(32)* getelementptr inbounds ([4 x i8], [4 x i8] addrspace(32)* @.str.47, i32 0, i32 0), i64 3)
+  %tobool = icmp eq i32 %call, 0
+  br i1 %tobool, label %if.then, label %if.end
+
+if.then:                                          ; preds = %entry
+  tail call void (i8*, ...) @fatal_error(i8* addrspacecast (i8 addrspace(32)* getelementptr inbounds ([51 x i8], [51 x i8] addrspace(32)* @.str.132, i32 0, i32 0) to i8*))
+  unreachable
+
+if.end:                                           ; preds = %entry
+  ret void
+}
+
+; CHECK-LABEL: _add_dependency:
+; CHECK:      movzwl	(%rdi), %e[[A:.*]]
+; CHECK-NEXT: xorl		$11822, %e[[A]]
+; CHECK-NEXT: movzbl	2(%rdi), %e[[B:.*]]
+; CHECK-NEXT: xorl		$47, %e[[B]]
+; CHECK-NEXT: orw		%[[A]], %[[B]]
+; CHECK-NEXT: je
+
+; Function Attrs: nounwind readonly
+declare i32 @memcmp(i8* nocapture, i8 addrspace(32)* nocapture, i64) local_unnamed_addr #3
+
+attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #7 = { noreturn nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-memcpy-2.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-memcpy-2.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-memcpy-2.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-memcpy-2.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,82 @@
+; RUN: llc < %s | FileCheck %s
+target datalayout = "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-apple-macosx10.13.0-wine32"
+
+%struct.anon.6 = type { %struct.dds_pixel_format, i32, i32, i32, i32, i32, i32, %struct.anon.7 }
+%struct.dds_pixel_format = type { i32, i32, i32, i32, i32, i32, i32, i32 }
+%struct.anon.7 = type { i32, i32 }
+%struct._D3DXIMAGE_INFO = type { i32, i32, i32, i32, i32, i32, i32 }
+
+@.str.2 = external dso_local unnamed_addr constant [42 x i8], align 1
+@noimage = external dso_local constant [4 x i8], align 1
+@.str.15 = external dso_local unnamed_addr constant [61 x i8], align 1
+@test_dds_header_handling.tests = external dso_local unnamed_addr constant [62 x %struct.anon.6], align 16
+@.str.38 = external dso_local unnamed_addr constant [65 x i8], align 1
+@.str.39 = external dso_local unnamed_addr constant [35 x i8], align 1
+
+; Function Attrs: nounwind ssp uwtable
+define void @func_surface() local_unnamed_addr #0 {
+entry:
+  %tests.i.i = alloca [62 x %struct.anon.6], align 16, addrspace(32)
+  call void @winetest_set_location(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.2, i64 0, i64 0), i32 458) #3
+  %call137.i = call win64cc i32 @D3DXGetImageInfoFromFileInMemory(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @noimage, i64 0, i64 0), i32 4, %struct._D3DXIMAGE_INFO* undef) #3
+  call void (i32, i8*, ...) @winetest_ok(i32 undef, i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.15, i64 0, i64 0), i32 %call137.i, i32 -2005529767) #3
+  %call171.i = call win64cc i32 @D3DXGetImageInfoFromFileInMemory(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @noimage, i64 0, i64 0), i32 0, %struct._D3DXIMAGE_INFO* undef) #3
+  call void @winetest_set_location(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.2, i64 0, i64 0), i32 586) #3
+  call void @llvm.memcpy.p32i8.p0i8.i64(i8 addrspace(32)* align 16 undef, i8* align 16 bitcast ([62 x %struct.anon.6]* @test_dds_header_handling.tests to i8*), i64 3968, i1 false) #3
+  br i1 undef, label %if.then.i688.i, label %for.cond.preheader.i.i
+
+for.cond.preheader.i.i:                           ; preds = %entry
+  br label %for.body.i.i
+
+if.then.i688.i:                                   ; preds = %entry
+  unreachable
+
+for.body.i.i:                                     ; preds = %for.body.i.i, %for.cond.preheader.i.i
+  %indvars.iv.i.i = phi i64 [ 0, %for.cond.preheader.i.i ], [ %indvars.iv.next.i.i, %for.body.i.i ]
+  %i.0106.i.i = phi i32 [ 0, %for.cond.preheader.i.i ], [ %inc.i.i, %for.body.i.i ]
+  %0 = getelementptr inbounds [62 x %struct.anon.6], [62 x %struct.anon.6] addrspace(32)* %tests.i.i, i32 0, i32 %i.0106.i.i
+  %1 = bitcast %struct.anon.6 addrspace(32)* %0 to i8 addrspace(32)*
+  call void @llvm.memcpy.p0i8.p32i8.i64(i8* nonnull align 4 undef, i8 addrspace(32)* align 16 %1, i64 32, i1 false) #3
+  %call36.i.i = call win64cc i32 @D3DXGetImageInfoFromFileInMemory(i8* nonnull undef, i32 undef, %struct._D3DXIMAGE_INFO* undef) #3
+  call void @winetest_set_location(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.2, i64 0, i64 0), i32 416) #3
+  %hr41.i.i = getelementptr [62 x %struct.anon.6], [62 x %struct.anon.6]* @test_dds_header_handling.tests, i64 0, i64 %indvars.iv.i.i, i32 7, i32 0
+  %2 = load i32, i32* %hr41.i.i, align 8
+  %3 = trunc i64 %indvars.iv.i.i to i32
+  call void (i32, i8*, ...) @winetest_ok(i32 undef, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.38, i64 0, i64 0), i32 %3, i32 %call36.i.i, i32 %2) #3
+  call void (i32, i8*, ...) @winetest_ok(i32 undef, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.39, i64 0, i64 0), i32 %3, i32 undef, i32 undef) #3
+  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
+  %inc.i.i = add nuw nsw i32 %i.0106.i.i, 1
+  %cmp.i689.i = icmp ult i64 %indvars.iv.next.i.i, 62
+  br label %for.body.i.i
+}
+
+; CHECK:     movq	-56(%ebp), %{{r?}}[[PTR:[a-z0-9]*]]
+; CHECK:     movq	24(%{{e?}}[[PTR]]{{d?}},%[[IDX:.*]]), %[[TMP:.*]]
+; CHECK:     movq	%[[TMP]], {{.*}}
+; CHECK:     movq	16(%{{e?}}[[PTR]]{{d?}},%[[IDX]]), %[[TMP:.*]]
+; CHECK:     movq	%[[TMP]], {{.*}}
+; CHECK-DAG: movq	(%{{e?}}[[PTR]]{{d?}},%[[IDX]]), %[[TMP:.*]]
+; CHECK-DAG: movq	8(%{{e?}}[[PTR]]{{d?}},%[[IDX]]), %[[TMP2:.*]]
+; CHECK-DAG: movq	%[[TMP]], {{.*}}
+; CHECK-DAG: movq	%[[TMP2]], {{.*}}
+; CHECK:     callq	_D3DXGetImageInfoFromFileInMemory
+; CHECK:     addq	$64, %r13
+
+declare void @winetest_set_location(i8*, i32) local_unnamed_addr #1
+
+declare void @winetest_ok(i32, i8*, ...) local_unnamed_addr #1
+
+declare win64cc i32 @D3DXGetImageInfoFromFileInMemory(i8*, i32, %struct._D3DXIMAGE_INFO*) local_unnamed_addr #1
+
+; Function Attrs: argmemonly nounwind
+declare void @llvm.memcpy.p32i8.p0i8.i64(i8 addrspace(32)* nocapture writeonly, i8* nocapture readonly, i64, i1) #2
+
+; Function Attrs: argmemonly nounwind
+declare void @llvm.memcpy.p0i8.p32i8.i64(i8* nocapture writeonly, i8 addrspace(32)* nocapture readonly, i64, i1) #2
+
+attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #2 = { argmemonly nounwind }
+attributes #3 = { nounwind }
+
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-memcpy.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-memcpy.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-memcpy.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-memcpy.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,37 @@
+; RUN: llc < %s | FileCheck %s
+target datalayout = "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-apple-macosx10.13.0-wine32"
+
+define void @foo(i8 addrspace(32)* %a, i8* %b, i64 %c, i64 %d) {
+  %1 = getelementptr i8, i8 addrspace(32)* %a, i64 %c
+  call void @llvm.memset.p32i8.i64(i8 addrspace(32)* align 1 %1, i8 0, i64 %d, i1 false)
+  call void @llvm.memcpy.p32i8.p0i8.i64(i8 addrspace(32)* align 1 %a, i8* align 1 %b, i64 %c, i1 false)
+  ret void
+}
+
+; CHECK-LABEL: _foo:
+; CHECK:      pushq	%r15
+; CHECK:      pushq	%r14
+; CHECK:      pushq	%rbx
+; CHECK:      movq	%rdx, %r15
+; CHECK-NEXT: movq	%rsi, %r14
+; CHECK-NEXT: movl	%edi, %ebx
+; CHECK-NEXT: leal	(%rbx,%rdx), %edi
+; CHECK-NEXT: movq	%rcx, %rsi
+; CHECK-NEXT: callq	___bzero
+; CHECK-NEXT: movq	%rbx, %rdi
+; CHECK-NEXT: movq	%r14, %rsi
+; CHECK-NEXT: movq	%r15, %rdx
+; CHECK-NEXT: callq	_memcpy
+; CHECK-NEXT: popq	%rbx
+; CHECK-NEXT: popq	%r14
+; CHECK-NEXT: popq	%r15
+; CHECK-NEXT: retq
+
+; Function Attrs: argmemonly nounwind
+declare void @llvm.memset.p32i8.i64(i8 addrspace(32)* nocapture writeonly, i8, i64, i1) #3
+
+; Function Attrs: argmemonly nounwind
+declare void @llvm.memcpy.p32i8.p0i8.i64(i8 addrspace(32)* nocapture writeonly, i8* nocapture readonly, i64, i1) #3
+
+attributes #3 = { argmemonly nounwind }
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-movtopush64.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-movtopush64.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-movtopush64.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-movtopush64.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,38 @@
+; RUN: llc < %s -mtriple=x86_64-linux-wine32 | FileCheck %s
+
+declare void @bar(i32 addrspace(32)*, i32 addrspace(32)*, i32 addrspace(32)*, i32 addrspace(32)*, i32 addrspace(32)*, i64 addrspace(32)*, i64, i64, i64)
+
+; Function Attrs: nounwind uwtable
+define void @foo() {
+entry:
+  %i1 = alloca i32, align 4, addrspace(32)
+  %i2 = alloca i32, align 4, addrspace(32)
+  %i3 = alloca i32, align 4, addrspace(32)
+  %i4 = alloca i32, align 4, addrspace(32)
+  %i5 = alloca i32, align 4, addrspace(32)
+  %i6 = alloca i64, align 8, addrspace(32)
+  store i32 1, i32 addrspace(32)* %i1, align 4
+; CHECK: movl $1, 28(%esp)
+  store i32 2, i32 addrspace(32)* %i2, align 4
+; CHECK-NEXT: movl $2, 24(%esp)
+  store i32 3, i32 addrspace(32)* %i3, align 4
+; CHECK-NEXT: movl $3, 20(%esp)
+  store i32 4, i32 addrspace(32)* %i4, align 4
+; CHECK-NEXT: movl $4, 16(%esp)
+  store i32 5, i32 addrspace(32)* %i5, align 4
+; CHECK-NEXT: movl $5, 12(%esp)
+  store i64 6, i64 addrspace(32)* %i6, align 8
+; CHECK-NEXT: movq $6, 32(%esp)
+; CHECK-NEXT: subl $8, %esp
+; CHECK: leal 36(%rsp), %edi
+; CHECK-NEXT: leal 32(%rsp), %esi
+; CHECK-NEXT: leal 28(%rsp), %edx
+; CHECK-NEXT: leal 24(%rsp), %ecx
+; CHECK-NEXT: leal 20(%rsp), %r8d
+; CHECK-NEXT: leal 40(%rsp), %r9d
+; CHECK: pushq $0
+; CHECK: pushq $0
+; CHECK: pushq $0
+  call void @bar(i32 addrspace(32)* nonnull %i1, i32 addrspace(32)* nonnull %i2, i32 addrspace(32)* nonnull %i3, i32 addrspace(32)* nonnull %i4, i32 addrspace(32)* nonnull %i5, i64 addrspace(32)* nonnull %i6, i64 0, i64 0, i64 0)
+  ret void
+}
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-musttail-varargs.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-musttail-varargs.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-musttail-varargs.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-musttail-varargs.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,182 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -verify-machineinstrs < %s -enable-tail-merge=0 -mtriple=x86_64-linux-wine32 | FileCheck %s --check-prefix=LINUX
+; RUN: llc -verify-machineinstrs < %s -enable-tail-merge=0 -mtriple=x86_64-windows-wine32 | FileCheck %s --check-prefix=WINDOWS
+; REQUIRES: disabled
+
+; Test that we actually spill and reload all arguments in the variadic argument
+; pack. Doing a normal call will clobber all argument registers, and we will
+; spill around it. A simple adjustment should not require any XMM spills.
+
+declare void @llvm.va_start.p0i8(i8*) nounwind
+
+declare void(i8 addrspace(32)*, ...) addrspace(32)* @get_f(i8 addrspace(32)* %this)
+
+define void @f_thunk(i8 addrspace(32)* %this, ...) {
+  ; Use va_start so that we exercise the combination.
+; LINUX-LABEL: f_thunk:
+; LINUX:       # %bb.0:
+; LINUX-NEXT:    pushq %rbp
+; LINUX-NEXT:    .cfi_def_cfa_offset 16
+; LINUX-NEXT:    pushq %r15
+; LINUX-NEXT:    .cfi_def_cfa_offset 24
+; LINUX-NEXT:    pushq %r14
+; LINUX-NEXT:    .cfi_def_cfa_offset 32
+; LINUX-NEXT:    pushq %r13
+; LINUX-NEXT:    .cfi_def_cfa_offset 40
+; LINUX-NEXT:    pushq %r12
+; LINUX-NEXT:    .cfi_def_cfa_offset 48
+; LINUX-NEXT:    pushq %rbx
+; LINUX-NEXT:    .cfi_def_cfa_offset 56
+; LINUX-NEXT:    subq $344, %rsp # imm = 0x158
+; LINUX-NEXT:    .cfi_def_cfa_offset 400
+; LINUX-NEXT:    .cfi_offset %rbx, -56
+; LINUX-NEXT:    .cfi_offset %r12, -48
+; LINUX-NEXT:    .cfi_offset %r13, -40
+; LINUX-NEXT:    .cfi_offset %r14, -32
+; LINUX-NEXT:    .cfi_offset %r15, -24
+; LINUX-NEXT:    .cfi_offset %rbp, -16
+; LINUX-NEXT:    movq %r9, %r15
+; LINUX-NEXT:    movq %r8, %r12
+; LINUX-NEXT:    movq %rcx, %r13
+; LINUX-NEXT:    movq %rdx, %rbp
+; LINUX-NEXT:    movq %rsi, %rbx
+; LINUX-NEXT:    movl %edi, %r14d
+; LINUX-NEXT:    movb %al, {{[0-9]+}}(%esp) # 1-byte Spill
+; LINUX-NEXT:    testb %al, %al
+; LINUX-NEXT:    je .LBB0_2
+; LINUX-NEXT:  # %bb.1:
+; LINUX-NEXT:    movaps %xmm0, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movaps %xmm1, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movaps %xmm2, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movaps %xmm3, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movaps %xmm4, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movaps %xmm5, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movaps %xmm6, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movaps %xmm7, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:  .LBB0_2:
+; LINUX-NEXT:    movq %r15, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movq %r12, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movq %r13, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movq %rbp, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movq %rbx, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    leal {{[0-9]+}}(%rsp), %eax
+; LINUX-NEXT:    movl %eax, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    leal {{[0-9]+}}(%rsp), %eax
+; LINUX-NEXT:    movl %eax, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movabsq $206158430216, %rax # imm = 0x3000000008
+; LINUX-NEXT:    movq %rax, {{[0-9]+}}(%rsp)
+; LINUX-NEXT:    movl %r14d, %edi
+; LINUX-NEXT:    movaps %xmm7, {{[0-9]+}}(%rsp) # 16-byte Spill
+; LINUX-NEXT:    movaps %xmm6, {{[0-9]+}}(%rsp) # 16-byte Spill
+; LINUX-NEXT:    movaps %xmm5, {{[0-9]+}}(%rsp) # 16-byte Spill
+; LINUX-NEXT:    movaps %xmm4, {{[0-9]+}}(%rsp) # 16-byte Spill
+; LINUX-NEXT:    movaps %xmm3, {{[0-9]+}}(%rsp) # 16-byte Spill
+; LINUX-NEXT:    movaps %xmm2, {{[0-9]+}}(%rsp) # 16-byte Spill
+; LINUX-NEXT:    movaps %xmm1, {{[0-9]+}}(%rsp) # 16-byte Spill
+; LINUX-NEXT:    movaps %xmm0, {{[0-9]+}}(%rsp) # 16-byte Spill
+; LINUX-NEXT:    callq get_f
+; LINUX-NEXT:    movl %eax, %r11d
+; LINUX-NEXT:    movl %r14d, %edi
+; LINUX-NEXT:    movq %rbx, %rsi
+; LINUX-NEXT:    movq %rbp, %rdx
+; LINUX-NEXT:    movq %r13, %rcx
+; LINUX-NEXT:    movq %r12, %r8
+; LINUX-NEXT:    movq %r15, %r9
+; LINUX-NEXT:    movaps {{[0-9]+}}(%rsp), %xmm0 # 16-byte Reload
+; LINUX-NEXT:    movaps {{[0-9]+}}(%rsp), %xmm1 # 16-byte Reload
+; LINUX-NEXT:    movaps {{[0-9]+}}(%rsp), %xmm2 # 16-byte Reload
+; LINUX-NEXT:    movaps {{[0-9]+}}(%rsp), %xmm3 # 16-byte Reload
+; LINUX-NEXT:    movaps {{[0-9]+}}(%rsp), %xmm4 # 16-byte Reload
+; LINUX-NEXT:    movaps {{[0-9]+}}(%rsp), %xmm5 # 16-byte Reload
+; LINUX-NEXT:    movaps {{[0-9]+}}(%rsp), %xmm6 # 16-byte Reload
+; LINUX-NEXT:    movaps {{[0-9]+}}(%rsp), %xmm7 # 16-byte Reload
+; LINUX-NEXT:    movb {{[0-9]+}}(%rsp), %al # 1-byte Reload
+; LINUX-NEXT:    addq $344, %rsp # imm = 0x158
+; LINUX-NEXT:    .cfi_def_cfa_offset 56
+; LINUX-NEXT:    popq %rbx
+; LINUX-NEXT:    .cfi_def_cfa_offset 48
+; LINUX-NEXT:    popq %r12
+; LINUX-NEXT:    .cfi_def_cfa_offset 40
+; LINUX-NEXT:    popq %r13
+; LINUX-NEXT:    .cfi_def_cfa_offset 32
+; LINUX-NEXT:    popq %r14
+; LINUX-NEXT:    .cfi_def_cfa_offset 24
+; LINUX-NEXT:    popq %r15
+; LINUX-NEXT:    .cfi_def_cfa_offset 16
+; LINUX-NEXT:    popq %rbp
+; LINUX-NEXT:    .cfi_def_cfa_offset 8
+; LINUX-NEXT:    jmpq *%r11 # TAILCALL
+  %ap = alloca [4 x i8 addrspace(32)*], align 16
+  %ap_i8 = bitcast [4 x i8 addrspace(32)*]* %ap to i8*
+  call void @llvm.va_start(i8* %ap_i8)
+
+  %fptr = call void(i8 addrspace(32)*, ...) addrspace(32)*(i8 addrspace(32)*) @get_f(i8 addrspace(32)* %this)
+  musttail call void (i8*, ...) %fptr(i8 addrspace(32)* %this, ...)
+  ret void
+}
+
+; Save and restore 6 GPRs, 8 XMMs, and AL around the call.
+
+; No regparms on normal x86 conventions.
+
+; This thunk shouldn't require any spills and reloads, assuming the register
+; allocator knows what it's doing.
+
+define void @g_thunk(i8 addrspace(32)* %fptr_i8, ...) {
+; LINUX-LABEL: g_thunk:
+; LINUX:       # %bb.0:
+; LINUX-NEXT:    pushq %rax
+; LINUX-NEXT:    .cfi_def_cfa_offset 16
+; LINUX-NEXT:    movl %edi, %r11d
+; LINUX-NEXT:    addl $8, %esp
+; LINUX-NEXT:    .cfi_def_cfa_offset 8
+; LINUX-NEXT:    jmpq *%r11 # TAILCALL
+  %fptr = bitcast i8* %fptr_i8 to void (i8 addrspace(32)*, ...) addrspace(32)*
+  musttail call void (i8 addrspace(32)*, ...) %fptr(i8 addrspace(32)* %fptr_i8, ...)
+  ret void
+}
+
+; Do a simple multi-exit multi-bb test.
+
+%struct.Foo = type { i1, i8 addrspace(32)*, i8* }
+
+@g = external global i32
+
+define void @h_thunk(%struct.Foo addrspace(32)* %this, ...) {
+; LINUX-LABEL: h_thunk:
+; LINUX:       # %bb.0:
+; LINUX-NEXT:    pushq %rax
+; LINUX-NEXT:    .cfi_def_cfa_offset 16
+; LINUX-NEXT:    cmpb $1, (%edi)
+; LINUX-NEXT:    jne .LBB2_2
+; LINUX-NEXT:  # %bb.1: # %then
+; LINUX-NEXT:    movl 4(%edi), %r11d
+; LINUX-NEXT:    addq $8, %rsp
+; LINUX-NEXT:    .cfi_def_cfa_offset 8
+; LINUX-NEXT:    jmpq *%r11 # TAILCALL
+; LINUX-NEXT:  .LBB2_2: # %else
+; LINUX-NEXT:    .cfi_def_cfa_offset 16
+; LINUX-NEXT:    movq 8(%edi), %r11
+; LINUX-NEXT:    movl $42, {{.*}}(%rip)
+; LINUX-NEXT:    addq $8, %rsp
+; LINUX-NEXT:    .cfi_def_cfa_offset 8
+; LINUX-NEXT:    jmpq *%r11 # TAILCALL
+  %cond_p = getelementptr %struct.Foo, %struct.Foo addrspace(32)* %this, i32 0, i32 0
+  %cond = load i1, i1 addrspace(32)* %cond_p
+  br i1 %cond, label %then, label %else
+
+then:
+  %a_p = getelementptr %struct.Foo, %struct.Foo addrspace(32)* %this, i32 0, i32 1
+  %a_i8 = load i8 addrspace(32)*, i8 addrspace(32)* addrspace(32)* %a_p
+  %a = bitcast i8 addrspace(32)* %a_i8 to void (%struct.Foo addrspace(32)*, ...) addrspace(32)*
+  musttail call void (%struct.Foo addrspace(32)*, ...) %a(%struct.Foo addrspace(32)* %this, ...)
+  ret void
+
+else:
+  %b_p = getelementptr %struct.Foo, %struct.Foo addrspace(32)* %this, i32 0, i32 2
+  %b_i8 = load i8*, i8* addrspace(32)* %b_p
+  %b = bitcast i8* %b_i8 to void (%struct.Foo addrspace(32)*, ...)*
+  store i32 42, i32* @g
+  musttail call void (%struct.Foo addrspace(32)*, ...) %b(%struct.Foo addrspace(32)* %this, ...)
+  ret void
+}
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-regalloc-2.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-regalloc-2.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-regalloc-2.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-regalloc-2.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,26 @@
+; RUN: llc < %s | FileCheck %s
+target datalayout = "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-apple-macosx10.13.0-wine32"
+
+; Function Attrs: nounwind
+declare noalias i8* @malloc() local_unnamed_addr #2
+
+; Function Attrs: nounwind ssp uwtable
+define dso_local void @wpp_default_lookup() #1 {
+entry:
+  %call.i = tail call i8* @malloc() #2
+  store i8 0, i8* %call.i, align 1
+  br label %for.body46
+
+for.body46:                                       ; preds = %for.body46, %entry
+  br label %for.body46
+}
+
+; CHECK: pushq	%rbp
+; CHECK: movl	%esp, %ebp
+; CHECK: callq	_malloc
+; CHECK: movb	$0, (%rax)
+
+attributes #1 = { nounwind ssp "disable-tail-calls"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "stack-protector-buffer-size"="8" }
+attributes #2 = { nounwind }
+
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-regalloc.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-regalloc.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-regalloc.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-regalloc.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,23 @@
+; RUN: llc < %s | FileCheck %s
+target datalayout = "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-apple-macosx10.13.0-wine32"
+
+%struct.__va_list_tag = type { i32, i32, i8*, i8* }
+
+; Function Attrs: nounwind ssp uwtable
+define void @ppy_error(i8* %s, ...) local_unnamed_addr #0 {
+entry:
+  %ap = alloca [1 x %struct.__va_list_tag], align 16, addrspace(32)
+  ret void
+}
+
+; CHECK: movq	___stack_chk_guard@GOTPCREL(%rip), %[[PTR:.*]]
+; CHECK: movq	(%[[PTR]]), %[[VAL:.*]]
+; CHECK: movq	%[[VAL]], -8(%ebp)
+; CHECK: movq	___stack_chk_guard@GOTPCREL(%rip), %[[PTR:.*]]
+; CHECK: movq	(%[[PTR]]), %[[VAL:.*]]
+; CHECK: cmpq	-8(%ebp), %[[VAL]]
+; CHECK: jne
+
+attributes #0 = { nounwind ssp "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "stack-protector-buffer-size"="8" }
+
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-sret-return.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-sret-return.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-sret-return.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-sret-return.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,70 @@
+; RUN: llc -mtriple=x86_64-apple-darwin8-wine32 < %s | FileCheck %s
+; RUN: llc -mtriple=x86_64-pc-linux-wine32 < %s | FileCheck %s
+
+%struct.foo = type { [4 x i64] }
+
+@baz = external global %struct.foo addrspace(32)*
+
+; CHECK-LABEL: bar:
+; CHECK-DAG: movl %esi, -4(%esp)
+; FIXME: Operationally, it doesn't matter, since 32-bit loads and stores are
+; zero-extended anyway, but we could make this a byte shorter by emitting a
+; 32-bit move.
+; CHECK-DAG: movq %rdi, %rax
+
+define void @bar(%struct.foo* noalias sret  %agg.result, %struct.foo addrspace(32)* %d) nounwind  {
+entry:
+	%d_addr = alloca %struct.foo addrspace(32)*, addrspace(32)		; <%struct.foo**> [#uses=2]
+	%"alloca point" = bitcast i32 0 to i32		; <i32> [#uses=0]
+	store %struct.foo addrspace(32)* %d, %struct.foo addrspace(32)* addrspace(32)* %d_addr
+	%tmp = load %struct.foo addrspace(32)*, %struct.foo addrspace(32)* addrspace(32)* %d_addr, align 4		; <%struct.foo*> [#uses=1]
+    %memtmp = load %struct.foo addrspace(32)*, %struct.foo addrspace(32)** @baz, align 4
+	%tmp1 = getelementptr %struct.foo, %struct.foo* %agg.result, i32 0, i32 0		; <[4 x i64]*> [#uses=4]
+	%tmp2 = getelementptr %struct.foo, %struct.foo addrspace(32)* %tmp, i32 0, i32 0		; <[4 x i64]*> [#uses=4]
+	%tmp3 = getelementptr [4 x i64], [4 x i64]* %tmp1, i32 0, i32 0		; <i64*> [#uses=1]
+	%tmp4 = getelementptr [4 x i64], [4 x i64] addrspace(32)* %tmp2, i32 0, i32 0		; <i64*> [#uses=1]
+	%tmp5 = load i64, i64 addrspace(32)* %tmp4, align 8		; <i64> [#uses=1]
+	store i64 %tmp5, i64* %tmp3, align 8
+	%tmp6 = getelementptr [4 x i64], [4 x i64]* %tmp1, i32 0, i32 1		; <i64*> [#uses=1]
+	%tmp7 = getelementptr [4 x i64], [4 x i64] addrspace(32)* %tmp2, i32 0, i32 1		; <i64*> [#uses=1]
+	%tmp8 = load i64, i64 addrspace(32)* %tmp7, align 8		; <i64> [#uses=1]
+	store i64 %tmp8, i64* %tmp6, align 8
+	%tmp9 = getelementptr [4 x i64], [4 x i64]* %tmp1, i32 0, i32 2		; <i64*> [#uses=1]
+	%tmp10 = getelementptr [4 x i64], [4 x i64] addrspace(32)* %tmp2, i32 0, i32 2		; <i64*> [#uses=1]
+	%tmp11 = load i64, i64 addrspace(32)* %tmp10, align 8		; <i64> [#uses=1]
+	store i64 %tmp11, i64* %tmp9, align 8
+	%tmp12 = getelementptr [4 x i64], [4 x i64]* %tmp1, i32 0, i32 3		; <i64*> [#uses=1]
+	%tmp13 = getelementptr [4 x i64], [4 x i64] addrspace(32)* %tmp2, i32 0, i32 3		; <i64*> [#uses=1]
+	%tmp14 = load i64, i64 addrspace(32)* %tmp13, align 8		; <i64> [#uses=1]
+	store i64 %tmp14, i64* %tmp12, align 8
+	%tmp15 = getelementptr %struct.foo, %struct.foo addrspace(32)* %memtmp, i32 0, i32 0		; <[4 x i64]*> [#uses=4]
+	%tmp16 = getelementptr %struct.foo, %struct.foo* %agg.result, i32 0, i32 0		; <[4 x i64]*> [#uses=4]
+	%tmp17 = getelementptr [4 x i64], [4 x i64] addrspace(32)* %tmp15, i32 0, i32 0		; <i64*> [#uses=1]
+	%tmp18 = getelementptr [4 x i64], [4 x i64]* %tmp16, i32 0, i32 0		; <i64*> [#uses=1]
+	%tmp19 = load i64, i64* %tmp18, align 8		; <i64> [#uses=1]
+	store i64 %tmp19, i64 addrspace(32)* %tmp17, align 8
+	%tmp20 = getelementptr [4 x i64], [4 x i64] addrspace(32)* %tmp15, i32 0, i32 1		; <i64*> [#uses=1]
+	%tmp21 = getelementptr [4 x i64], [4 x i64]* %tmp16, i32 0, i32 1		; <i64*> [#uses=1]
+	%tmp22 = load i64, i64* %tmp21, align 8		; <i64> [#uses=1]
+	store i64 %tmp22, i64 addrspace(32)* %tmp20, align 8
+	%tmp23 = getelementptr [4 x i64], [4 x i64] addrspace(32)* %tmp15, i32 0, i32 2		; <i64*> [#uses=1]
+	%tmp24 = getelementptr [4 x i64], [4 x i64]* %tmp16, i32 0, i32 2		; <i64*> [#uses=1]
+	%tmp25 = load i64, i64* %tmp24, align 8		; <i64> [#uses=1]
+	store i64 %tmp25, i64 addrspace(32)* %tmp23, align 8
+	%tmp26 = getelementptr [4 x i64], [4 x i64] addrspace(32)* %tmp15, i32 0, i32 3		; <i64*> [#uses=1]
+	%tmp27 = getelementptr [4 x i64], [4 x i64]* %tmp16, i32 0, i32 3		; <i64*> [#uses=1]
+	%tmp28 = load i64, i64* %tmp27, align 8		; <i64> [#uses=1]
+	store i64 %tmp28, i64 addrspace(32)* %tmp26, align 8
+	br label %return
+
+return:		; preds = %entry
+	ret void
+}
+
+; CHECK-LABEL: foo:
+; CHECK: movl %edi, %eax
+
+define void @foo({ i64 } addrspace(32)* noalias nocapture sret %agg.result) nounwind {
+  store { i64 } { i64 0 }, { i64 } addrspace(32)* %agg.result
+  ret void
+}
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-stack-protector.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-stack-protector.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-stack-protector.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-stack-protector.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,23 @@
+; RUN: llc < %s | FileCheck %s
+; RUN: llc -fast-isel < %s | FileCheck %s
+
+target datalayout = "e-m:e-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-wine32"
+
+define void @foo() ssp {
+  %1 = alloca [1024 x i8], align 4, addrspace(32)
+  ret void
+; CHECK-LABEL: foo:
+; CHECK:      subl	$1032, %esp
+; CHECK:      leal	1024(%rsp), %eax
+; CHECK-NEXT: movq	%fs:40, %rcx
+; CHECK-NEXT: movq	%rcx, 1024(%esp)
+; CHECK-NEXT: movq	%fs:40, %rcx
+; CHECK:      cmpq	{{.*}}, %rcx
+; CHECK-NEXT: jne	[[CallStackCheckFailBlk:.*]]
+; CHECK:      addl	$1032, %esp
+; CHECK:      retq
+; CHECK: [[CallStackCheckFailBlk]]:
+; CHECK:      callq	__stack_chk_fail
+}
+
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-varargs-amd64.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-varargs-amd64.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-varargs-amd64.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-varargs-amd64.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,188 @@
+; RUN: llc < %s | FileCheck %s
+
+target datalayout = "e-m:e-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-wine32"
+
+%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
+%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
+%struct.__va_list_tag = type { i32, i32, i8*, i8* }
+
+@stderr = external dso_local global %struct._IO_FILE*, align 8
+@input_file_name = external hidden global i8*, align 8
+@.str.39 = external hidden unnamed_addr constant [4 x i8], align 1
+@input_line = external hidden global i32, align 4
+@.str.40 = external hidden unnamed_addr constant [4 x i8], align 1
+@.str.41 = external hidden unnamed_addr constant [9 x i8], align 1
+@.str.42 = external hidden unnamed_addr constant [17 x i8], align 1
+
+declare dso_local i32 @fprintf(%struct._IO_FILE*, i8*, ...) #1
+
+; Function Attrs: noreturn nounwind
+declare dso_local void @exit(i32) #2
+
+; Function Attrs: noinline nounwind optnone uwtable
+declare hidden i8* @xmalloc(i64) #3
+
+; Function Attrs: noinline nounwind optnone uwtable
+define hidden void @fatal_error(i8* %msg, ...) #3 {
+; CHECK-LABEL: fatal_error:
+entry:
+  %msg.addr = alloca i8*, align 8, addrspace(32)
+  %valist = alloca [1 x %struct.__va_list_tag], align 16, addrspace(32)
+  store i8* %msg, i8* addrspace(32)* %msg.addr, align 8
+  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag] addrspace(32)* %valist, i32 0, i32 0
+  %0 = addrspacecast %struct.__va_list_tag addrspace(32)* %arraydecay to %struct.__va_list_tag*
+  %1 = bitcast %struct.__va_list_tag* %0 to i8*
+  call void @llvm.va_start(i8* %1)
+; CHECK: leal -32(%rbp), %[[AP:.*]]
+; CHECK: leal -208(%rbp), %[[AP_END:.*]]
+; CHECK: movl %[[AP_END]], 16(%[[AP]])
+; CHECK: leal 16(%rbp), %[[ARGS:.*]]
+; CHECK: movl %[[ARGS]], 8(%[[AP]])
+; CHECK: movl $48, 4(%[[AP]])
+; CHECK: movl $8, (%[[AP]])
+  %2 = load i8*, i8** @input_file_name, align 8
+  %tobool = icmp ne i8* %2, null
+  br i1 %tobool, label %if.then, label %if.else
+
+if.then:                                          ; preds = %entry
+  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
+  %4 = load i8*, i8** @input_file_name, align 8
+  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.39, i32 0, i32 0), i8* %4)
+  %5 = load i32, i32* @input_line, align 4
+  %tobool1 = icmp ne i32 %5, 0
+  br i1 %tobool1, label %if.then2, label %if.end
+
+if.then2:                                         ; preds = %if.then
+  %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
+  %7 = load i32, i32* @input_line, align 4
+  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %6, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.40, i32 0, i32 0), i32 %7)
+  br label %if.end
+
+if.end:                                           ; preds = %if.then2, %if.then
+  %8 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
+  %call4 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %8, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.41, i32 0, i32 0))
+  br label %if.end6
+
+if.else:                                          ; preds = %entry
+  %9 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
+  %call5 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %9, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.42, i32 0, i32 0))
+  br label %if.end6
+
+if.end6:                                          ; preds = %if.else, %if.end
+  %10 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
+  %11 = load i8*, i8* addrspace(32)* %msg.addr, align 8
+  %arraydecay7 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag] addrspace(32)* %valist, i32 0, i32 0
+  %call8 = call i32 @vfprintf(%struct._IO_FILE* %10, i8* %11, %struct.__va_list_tag addrspace(32)* %arraydecay7)
+  %arraydecay9 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag] addrspace(32)* %valist, i32 0, i32 0
+  %12 = addrspacecast %struct.__va_list_tag addrspace(32)* %arraydecay9 to %struct.__va_list_tag*
+  %13 = bitcast %struct.__va_list_tag* %12 to i8*
+  call void @llvm.va_end(i8* %13)
+  call void @exit(i32 1) #6
+  unreachable
+
+return:                                           ; No predecessors!
+  ret void
+}
+
+; Function Attrs: nounwind
+declare void @llvm.va_start(i8*) #4
+
+declare dso_local i32 @vfprintf(%struct._IO_FILE*, i8*, %struct.__va_list_tag addrspace(32)*) #1
+
+; Function Attrs: nounwind
+declare void @llvm.va_end(i8*) #4
+
+; Function Attrs: noinline nounwind optnone uwtable
+declare hidden i8* @xrealloc(i8*, i64) #3
+
+; Function Attrs: noinline nounwind optnone uwtable
+define hidden i8* @strmake(i8* %fmt, ...) #3 {
+; CHECK-LABEL: strmake:
+entry:
+  %fmt.addr = alloca i8*, align 8, addrspace(32)
+  %n = alloca i32, align 4, addrspace(32)
+  %size = alloca i64, align 8, addrspace(32)
+  %ap = alloca [1 x %struct.__va_list_tag], align 16, addrspace(32)
+  %p = alloca i8*, align 8, addrspace(32)
+  store i8* %fmt, i8* addrspace(32)* %fmt.addr, align 8
+  store i64 100, i64 addrspace(32)* %size, align 8
+  br label %for.cond
+
+for.cond:                                         ; preds = %if.end12, %entry
+  %0 = load i64, i64 addrspace(32)* %size, align 8
+  %call = call i8* @xmalloc(i64 %0)
+  store i8* %call, i8* addrspace(32)* %p, align 8
+  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag] addrspace(32)* %ap, i32 0, i32 0
+  %1 = addrspacecast %struct.__va_list_tag addrspace(32)* %arraydecay to %struct.__va_list_tag*
+  %2 = bitcast %struct.__va_list_tag* %1 to i8*
+  call void @llvm.va_start(i8* %2)
+; CHECK: leal -240(%rbp), %[[AP_END:.*]]
+; CHECK: movl %[[AP_END]], -48(%ebp)
+; CHECK: leal 16(%rbp), %[[ARGS:.*]]
+; CHECK: movl %[[ARGS]], -56(%ebp)
+; CHECK: movl $48, -60(%ebp)
+; CHECK: movl $8, -64(%ebp)
+  %3 = load i8*, i8* addrspace(32)* %p, align 8
+  %4 = load i64, i64 addrspace(32)* %size, align 8
+  %5 = load i8*, i8* addrspace(32)* %fmt.addr, align 8
+  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag] addrspace(32)* %ap, i32 0, i32 0
+  %call2 = call i32 @vsnprintf(i8* %3, i64 %4, i8* %5, %struct.__va_list_tag addrspace(32)* %arraydecay1)
+  store i32 %call2, i32 addrspace(32)* %n, align 4
+  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag] addrspace(32)* %ap, i32 0, i32 0
+  %6 = addrspacecast %struct.__va_list_tag addrspace(32)* %arraydecay3 to %struct.__va_list_tag*
+  %7 = bitcast %struct.__va_list_tag* %6 to i8*
+  call void @llvm.va_end(i8* %7)
+  %8 = load i32, i32 addrspace(32)* %n, align 4
+  %cmp = icmp eq i32 %8, -1
+  br i1 %cmp, label %if.then, label %if.else
+
+if.then:                                          ; preds = %for.cond
+  %9 = load i64, i64 addrspace(32)* %size, align 8
+  %mul = mul i64 %9, 2
+  store i64 %mul, i64 addrspace(32)* %size, align 8
+  br label %if.end12
+
+if.else:                                          ; preds = %for.cond
+  %10 = load i32, i32 addrspace(32)* %n, align 4
+  %conv = sext i32 %10 to i64
+  %11 = load i64, i64 addrspace(32)* %size, align 8
+  %cmp4 = icmp uge i64 %conv, %11
+  br i1 %cmp4, label %if.then6, label %if.else8
+
+if.then6:                                         ; preds = %if.else
+  %12 = load i32, i32 addrspace(32)* %n, align 4
+  %add = add nsw i32 %12, 1
+  %conv7 = sext i32 %add to i64
+  store i64 %conv7, i64 addrspace(32)* %size, align 8
+  br label %if.end
+
+if.else8:                                         ; preds = %if.else
+  %13 = load i8*, i8* addrspace(32)* %p, align 8
+  %14 = load i32, i32 addrspace(32)* %n, align 4
+  %add9 = add nsw i32 %14, 1
+  %conv10 = sext i32 %add9 to i64
+  %call11 = call i8* @xrealloc(i8* %13, i64 %conv10)
+  ret i8* %call11
+
+if.end:                                           ; preds = %if.then6
+  br label %if.end12
+
+if.end12:                                         ; preds = %if.end, %if.then
+  %15 = load i8*, i8* addrspace(32)* %p, align 8
+  call void @free(i8* %15) #4
+  br label %for.cond
+}
+
+declare dso_local i32 @vsnprintf(i8*, i64, i8*, %struct.__va_list_tag addrspace(32)*) #1
+
+; Function Attrs: nounwind
+declare dso_local void @free(i8*) #5
+
+attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #2 = { noreturn nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #3 = { noinline nounwind optnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #4 = { nounwind }
+attributes #5 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #6 = { noreturn nounwind }
+
diff -rN --unified llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-vectorshuffle.ll llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-vectorshuffle.ll
--- llvm-toolchain-7-7.0.1/test/CodeGen/X86/p32-vectorshuffle.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/CodeGen/X86/p32-vectorshuffle.ll	2019-05-19 11:21:52.895903000 +0000
@@ -0,0 +1,27 @@
+; RUN: llc < %s | FileCheck %s
+target datalayout = "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-apple-macosx10.13.0-wine32"
+
+; Function Attrs: nounwind ssp uwtable
+define dso_local fastcc void @foo() unnamed_addr {
+entry:
+  br i1 undef, label %exit, label %if.end.i14
+
+if.end.i14:                                       ; preds = %entry
+  %0 = load <2 x i32>, <2 x i32> addrspace(32)* undef, align 8
+  %shuffle = shufflevector <2 x i32> %0, <2 x i32> undef, <4 x i32> <i32 0, i32 1, i32 0, i32 1>
+  %1 = sub <4 x i32> zeroinitializer, %shuffle
+  store <4 x i32> %1, <4 x i32>* undef, align 16
+  unreachable
+
+exit:                                             ; preds = %entry
+  ret void
+}
+
+; CHECK-LABEL: _foo:
+; CHECK: movq	(%{{e?}}[[PTR:.*]]{{d?}}), %[[MM0:xmm[0-9]+]]
+; CHECK: pshufd	$68, %[[MM0]], %[[MM0]]
+; CHECK: pxor	%[[MM1:xmm[0-9]+]], %[[MM1]]
+; CHECK: psubd	%[[MM0]], %[[MM1]]
+; CHECK: movdqa	%[[MM1]], (%{{r?}}[[PTR]])
+
diff -rN --unified llvm-toolchain-7-7.0.1/test/Transforms/InstCombine/p32-memcmp-simplify.ll llvm-toolchain-7-7.0.1.patched/test/Transforms/InstCombine/p32-memcmp-simplify.ll
--- llvm-toolchain-7-7.0.1/test/Transforms/InstCombine/p32-memcmp-simplify.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/Transforms/InstCombine/p32-memcmp-simplify.ll	2019-05-19 11:21:52.905903000 +0000
@@ -0,0 +1,44 @@
+; RUN: opt -S -instcombine %s | FileCheck %s
+target datalayout = "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-apple-macosx10.13.0-wine32"
+
+; Test that this doesn't crash.
+
+@.str.12 = external dso_local unnamed_addr addrspace(32) constant [5 x i8], align 1
+
+; Function Attrs: nounwind ssp uwtable
+define internal fastcc i8* @next_dll_path() unnamed_addr #0 {
+entry:
+  switch i32 undef, label %sw.default [
+    i32 0, label %sw.bb
+    i32 1, label %sw.bb13
+  ]
+
+sw.bb:                                            ; preds = %entry
+  %call = call i32 @memcmp(i8* undef, i8 addrspace(32)* getelementptr inbounds ([5 x i8], [5 x i8] addrspace(32)* @.str.12, i32 0, i32 0), i64 4)
+  %tobool = icmp ne i32 %call, 0
+  br i1 %tobool, label %if.end, label %if.then
+
+; CHECK:      sw.bb:
+; CHECK-NEXT:   %call = call i32 @memcmp(i8* undef, i8 addrspace(32)* getelementptr inbounds ([5 x i8], [5 x i8] addrspace(32)* @.str.12, i32 0, i32 0), i64 4)
+; CHECK-NEXT:   %tobool = icmp eq i32 %call, 0
+; CHECK-NEXT:   br i1 %tobool, label %if.then, label %if.end
+
+if.then:
+  br label %if.end
+
+if.end:
+  unreachable
+
+sw.bb13:
+  unreachable
+
+sw.default:
+  unreachable
+}
+
+; Function Attrs: nounwind readonly
+declare i32 @memcmp(i8* nocapture, i8 addrspace(32)* nocapture, i64) local_unnamed_addr #1
+
+attributes #0 = { nounwind ssp }
+attributes #1 = { nounwind readonly }
diff -rN --unified llvm-toolchain-7-7.0.1/test/Transforms/Util/libcalls-ptr32.ll llvm-toolchain-7-7.0.1.patched/test/Transforms/Util/libcalls-ptr32.ll
--- llvm-toolchain-7-7.0.1/test/Transforms/Util/libcalls-ptr32.ll	1970-01-01 00:00:00.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/test/Transforms/Util/libcalls-ptr32.ll	2019-05-19 11:21:52.905903000 +0000
@@ -0,0 +1,19 @@
+; RUN: opt -S -instcombine -o - %s | FileCheck %s
+
+target datalayout = "e-m:o-p32:32:32-A32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-apple-macosx10.13.0-wine32"
+
+@.str = private unnamed_addr constant [2 x i8] c"y\00", align 1
+
+define i8* @foo(i8 addrspace(32)* %a) {
+  %1 = call i8* @strstr(i8 addrspace(32)* %a, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str, i64 0, i64 0))
+  ret i8* %1
+}
+
+; CHECK-LABEL: define i8* @foo(i8 addrspace(32)* %a
+; CHECK: %[[CSTR_AS:.*]] = addrspacecast i8 addrspace(32)* %a to i8*
+; CHECK: call i8* @strchr(i8* %[[CSTR_AS]], i32 121)
+
+; This is deliberate. Clang generates a signature like this for the built-in
+; (i.e. known) function, strstr(3), when called with a 32-bit pointer.
+declare i8* @strstr(i8 addrspace(32)*, i8*)
diff -rN --unified llvm-toolchain-7-7.0.1/utils/TableGen/DAGISelMatcher.cpp llvm-toolchain-7-7.0.1.patched/utils/TableGen/DAGISelMatcher.cpp
--- llvm-toolchain-7-7.0.1/utils/TableGen/DAGISelMatcher.cpp	2018-12-16 12:02:54.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/utils/TableGen/DAGISelMatcher.cpp	2019-05-19 11:21:59.995903000 +0000
@@ -234,6 +234,12 @@
                     << '\n';
 }
 
+void EmitRegisterClassMatcher::printImpl(raw_ostream &OS,
+                                         unsigned indent) const {
+  OS.indent(indent) << "EmitRegisterClass " << RC->getName()
+                    << " VT=" << getEnumName(VT) << '\n';
+}
+
 void EmitRegisterMatcher::printImpl(raw_ostream &OS, unsigned indent) const {
   OS.indent(indent) << "EmitRegister ";
   if (Reg)
diff -rN --unified llvm-toolchain-7-7.0.1/utils/TableGen/DAGISelMatcher.h llvm-toolchain-7-7.0.1.patched/utils/TableGen/DAGISelMatcher.h
--- llvm-toolchain-7-7.0.1/utils/TableGen/DAGISelMatcher.h	2018-12-16 12:02:54.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/utils/TableGen/DAGISelMatcher.h	2019-05-19 11:21:59.995903000 +0000
@@ -18,6 +18,7 @@
 
 namespace llvm {
   struct CodeGenRegister;
+  class CodeGenRegisterClass;
   class CodeGenDAGPatterns;
   class Matcher;
   class PatternToMatch;
@@ -76,6 +77,7 @@
     // Node creation/emisssion.
     EmitInteger,          // Create a TargetConstant
     EmitStringInteger,    // Create a TargetConstant from a string.
+    EmitRegisterClass,    // Create a RegClass TargetConstant.
     EmitRegister,         // Create a register.
     EmitConvertToTarget,  // Convert a imm/fpimm to target imm/fpimm
     EmitMergeInputChains, // Merge together a chains for an input.
@@ -790,6 +792,30 @@
   }
 };
 
+/// A target constant whose value is a register class ID.
+class EmitRegisterClassMatcher : public Matcher {
+  const CodeGenRegisterClass *RC;
+  MVT::SimpleValueType VT;
+public:
+  EmitRegisterClassMatcher(const CodeGenRegisterClass *rc,
+                           MVT::SimpleValueType vt)
+    : Matcher(EmitRegisterClass), RC(rc), VT(vt) {}
+
+  const CodeGenRegisterClass *getRegClass() const { return RC; }
+  MVT::SimpleValueType getVT() const { return VT; }
+
+  static bool classof(const Matcher *N) {
+    return N->getKind() == EmitRegisterClass;
+  }
+
+private:
+  void printImpl(raw_ostream &OS, unsigned indent) const override;
+  bool isEqualImpl(const Matcher *M) const override {
+    return cast<EmitRegisterClassMatcher>(M)->RC == RC &&
+           cast<EmitRegisterClassMatcher>(M)->VT == VT;
+  }
+};
+
 /// EmitRegisterMatcher - This creates a new TargetConstant.
 class EmitRegisterMatcher : public Matcher {
   /// Reg - The def for the register that we're emitting.  If this is null, then
diff -rN --unified llvm-toolchain-7-7.0.1/utils/TableGen/DAGISelMatcherEmitter.cpp llvm-toolchain-7-7.0.1.patched/utils/TableGen/DAGISelMatcherEmitter.cpp
--- llvm-toolchain-7-7.0.1/utils/TableGen/DAGISelMatcherEmitter.cpp	2018-12-16 12:02:54.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/utils/TableGen/DAGISelMatcherEmitter.cpp	2019-05-19 11:21:59.995903000 +0000
@@ -590,6 +590,23 @@
     return 3;
   }
 
+  case Matcher::EmitRegisterClass: {
+    const auto *Matcher = cast<EmitRegisterClassMatcher>(N);
+    const CodeGenRegisterClass *RC = Matcher->getRegClass();
+    OS << "OPC_EmitInteger, " << getEnumName(Matcher->getVT()) << ", ";
+    assert(RC);
+    if (RC->EnumValue > 127) {
+      unsigned Bytes = 2 + EmitVBRValue(RC->EnumValue, OS);
+      if (!OmitComments)
+        OS << "/*" << getQualifiedName(RC->getDef()) << "RegClassID*/";
+      OS << '\n';
+      return Bytes;
+    } else {
+      OS << getQualifiedName(RC->getDef()) << "RegClassID,\n";
+      return 3;
+    }
+  }
+
   case Matcher::EmitRegister: {
     const EmitRegisterMatcher *Matcher = cast<EmitRegisterMatcher>(N);
     const CodeGenRegister *Reg = Matcher->getReg();
@@ -968,6 +985,7 @@
     return "OPC_CheckFoldableChainNode"; break;
   case Matcher::EmitInteger: return "OPC_EmitInteger"; break;
   case Matcher::EmitStringInteger: return "OPC_EmitStringInteger"; break;
+  case Matcher::EmitRegisterClass: return "OPC_EmitRegisterClass"; break;
   case Matcher::EmitRegister: return "OPC_EmitRegister"; break;
   case Matcher::EmitConvertToTarget: return "OPC_EmitConvertToTarget"; break;
   case Matcher::EmitMergeInputChains: return "OPC_EmitMergeInputChains"; break;
diff -rN --unified llvm-toolchain-7-7.0.1/utils/TableGen/DAGISelMatcherGen.cpp llvm-toolchain-7-7.0.1.patched/utils/TableGen/DAGISelMatcherGen.cpp
--- llvm-toolchain-7-7.0.1/utils/TableGen/DAGISelMatcherGen.cpp	2018-12-16 12:02:54.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/utils/TableGen/DAGISelMatcherGen.cpp	2019-05-19 11:21:59.995903000 +0000
@@ -638,8 +638,9 @@
     if (Def->isSubClassOf("RegisterOperand"))
       Def = Def->getValueAsDef("RegClass");
     if (Def->isSubClassOf("RegisterClass")) {
-      std::string Value = getQualifiedName(Def) + "RegClassID";
-      AddMatcher(new EmitStringIntegerMatcher(Value, MVT::i32));
+      const CodeGenRegisterClass *RC =
+          CGP.getTargetInfo().getRegBank().getRegClass(Def);
+      AddMatcher(new EmitRegisterClassMatcher(RC, MVT::i32));
       ResultOps.push_back(NextRecordedOperandNo++);
       return;
     }
diff -rN --unified llvm-toolchain-7-7.0.1/utils/lldbDataFormatters.py llvm-toolchain-7-7.0.1.patched/utils/lldbDataFormatters.py
--- llvm-toolchain-7-7.0.1/utils/lldbDataFormatters.py	2018-12-16 12:02:54.000000000 +0000
+++ llvm-toolchain-7-7.0.1.patched/utils/lldbDataFormatters.py	2019-05-19 11:21:59.995903000 +0000
@@ -26,9 +26,7 @@
         self.update() # initialize this provider
 
     def num_children(self):
-        begin = self.begin.GetValueAsUnsigned(0)
-        end = self.end.GetValueAsUnsigned(0)
-        return (end - begin)/self.type_size
+        return self.size.GetValueAsUnsigned(0)
 
     def get_child_index(self, name):
         try:
@@ -49,7 +47,7 @@
 
     def update(self):
         self.begin = self.valobj.GetChildMemberWithName('BeginX')
-        self.end = self.valobj.GetChildMemberWithName('EndX')
+        self.size = self.valobj.GetChildMemberWithName('Size')
         the_type = self.valobj.GetType()
         # If this is a reference type we have to dereference it to get to the
         # template parameter.
